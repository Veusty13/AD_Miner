[
  {
    "title": "Guest accounts",
    "file_name": "guest_accounts.py",
    "control_category": "Permissions",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\nfrom ad_miner.sources.modules.common_analysis import presence_of\n\n\n@register_control\nclass guest_accounts(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"permissions\"\n        self.control_key = \"guest_accounts\"\n\n        self.title = \"Guest accounts\"\n        self.description = \"List of guest accounts\"\n        self.risk = \"The Guest account allows unauthenticated network users to log in as Guest without a password. These unauthorised users can access all resources accessible to the Guest account on the network. This feature means that any shared objects or folders with permissions that allow access to the Guest account, the Domain Guests group, the Guests group, or the Everyone group are accessible on the network, which can lead to data exposure or corruption.\"\n        self.poa = \"Guests accounts should be disabled.\"\n\n        self.guest_accounts = requests_results[\"guest_accounts\"]\n\n    def run(self):\n        page = Page(\n            self.arguments.cache_prefix,\n            \"guest_accounts\",\n            \"Guest accounts\",\n            self.get_dico_description(),\n        )\n        grid = Grid(\"Guest accounts\")\n        grid.setheaders([\"domain\", \"name\", \"enabled\"])\n\n        # Sort accounts with enabled accounts first\n        guest_list = [ude for ude in self.guest_accounts if ude[-1]]\n        guest_list += [ude for ude in self.guest_accounts if not ude[-1]]\n\n        data = []\n        for account_name, domain, is_enabled in guest_list:\n            tmp_data = {\"domain\": '<i class=\"bi bi-globe2\"></i> ' + domain}\n            tmp_data[\"name\"] = '<i class=\"bi bi-person-fill\"></i> ' + account_name\n            tmp_data[\"enabled\"] = (\n                '<i class=\"bi bi-unlock-fill text-danger\"></i> Enabled'\n                if is_enabled\n                else '<i class=\"bi bi-lock-fill text-success\"></i> Disabled'\n            )\n            data.append(tmp_data)\n\n        grid.setData(data)\n        page.addComponent(grid)\n        page.render()\n\n        self.data = len([ude for ude in self.guest_accounts if ude[-1]])\n        self.name_description = f\"{self.data} guests accounts are enabled\"\n\n    def get_rating(self) -> int:\n        return presence_of([ude for ude in self.guest_accounts if ude[-1]])\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "ad_miner/sources/modules/common_analysis.py": {
        "imported_elements": [
          "presence_of"
        ],
        "code_map": {
          "presence_of": "def presence_of(req, criticity=1, threshold=0):\n    if req is None:\n        return -1\n    if len(req) > threshold:\n        return criticity\n    return 5"
        }
      }
    },
    "requests_keys": [
      "guest_accounts"
    ]
  },
  {
    "title": "\"Pre-Windows 2000 Compatible Access\" group",
    "file_name": "pre_windows_2000_compatible_access_group.py",
    "control_category": "Permissions",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\n\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\nfrom ad_miner.sources.modules import generic_formating\n\n\n@register_control\nclass pre_windows_2000_compatible_access_group(Control):\n    \"Docstring of my control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"permissions\"\n        self.control_key = \"pre_windows_2000_compatible_access_group\"\n\n        self.title = '\"Pre-Windows 2000 Compatible Access\" group'\n        self.description = (\n            'Inadequate object in \"Pre-Windows 2000 Compatible Access\" group.'\n        )\n        self.risk = 'Membership of the \"Pre-Windows 2000 Compatible Access\" group allows to enumerate elements of the Active Directory.'\n        self.poa = 'The Pre-Windows 2000 Compatible Access group must contain only \"Authenticated Users\".'\n\n        self.pre_windows_2000_compatible_access_group = requests_results[\n            \"pre_windows_2000_compatible_access_group\"\n        ]\n\n    def run(self):\n        if self.pre_windows_2000_compatible_access_group is None:\n            self.pre_windows_2000_compatible_access_group = []\n\n        page = Page(\n            self.arguments.cache_prefix,\n            \"pre_windows_2000_compatible_access_group\",\n            \"Pre-Windows 2000 Compatible Access group\",\n            self.get_dico_description(),\n        )\n        grid = Grid(\"Pre-Windows 2000 Compatible Access\")\n        grid.setheaders([\"Domain\", \"Name\", \"Rating\"])\n\n        # Sort accounts with anonymous accounts first\n        sorted_list = [\n            dni\n            for dni in self.pre_windows_2000_compatible_access_group\n            if \"1-5-7\" in dni[2]\n        ]\n        sorted_list += [\n            dni\n            for dni in self.pre_windows_2000_compatible_access_group\n            if \"1-5-7\" not in dni[2]\n        ]\n\n        data = []\n\n        for domain, account_name, objectid, type_list in sorted_list:\n            tmp_data = {\"Domain\": '<i class=\"bi bi-globe2\"></i> ' + domain}\n\n            type_clean = generic_formating.clean_label(type_list)\n\n            tmp_data[\"Name\"] = (\n                f\"{generic_formating.get_label_icon(type_clean)} {account_name}\"\n            )\n\n            tmp_data[\"Rating\"] = (\n                '<i class=\"bi bi-star-fill\" style=\"color: orange\"></i><i class=\"bi bi-star-fill\" style=\"color: orange\"></i><i class=\"bi bi-star\" style=\"color: orange\"></i>'\n                if \"1-5-7\" not in objectid\n                else '<i class=\"bi bi-star-fill\" style=\"color: red\"></i><i class=\"bi bi-star-fill\" style=\"color: red\"></i><i class=\"bi bi-star-fill\" style=\"color: red\"></i>  Anonymous'\n            )\n            data.append(tmp_data)\n\n        grid.setData(data)\n        page.addComponent(grid)\n        page.render()\n\n        self.data = len(self.pre_windows_2000_compatible_access_group)\n        self.name_description = f\"{len(self.pre_windows_2000_compatible_access_group)} inadequate membership users in Pre-Win $2000$ Compatible Access group\"\n\n    def get_rating(self) -> int:\n        if self.pre_windows_2000_compatible_access_group is None:\n            return -1\n        if True in [\n            \"1-5-7\" in dni[2] for dni in self.pre_windows_2000_compatible_access_group\n        ]:\n            return 2\n        elif len(self.pre_windows_2000_compatible_access_group) > 0:\n            return 3\n        else:\n            return 5\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/__init__.py": {
        "imported_elements": [
          "generic_formating"
        ],
        "code_map": {}
      }
    },
    "requests_keys": [
      "pre_windows_2000_compatible_access_group"
    ]
  },
  {
    "title": "Kerberos unconstrained delegations",
    "file_name": "non-dc_with_unconstrained_delegations.py",
    "control_category": "Kerberos",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\nfrom ad_miner.sources.modules import logger\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\nfrom ad_miner.sources.modules.node_neo4j import Node\nfrom ad_miner.sources.modules.path_neo4j import Path\n\nfrom ad_miner.sources.modules.utils import grid_data_stringify\nfrom ad_miner.sources.modules.common_analysis import presence_of, createGraphPage\n\nfrom urllib.parse import quote\n\n\n@register_control\nclass non_dc_with_unconstrained_delegations(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"kerberos\"\n\n        # Do NOT change existing control_key, as it will break evolution with older ad miner versions\n        self.control_key = \"non-dc_with_unconstrained_delegations\"\n\n        self.title = \"Kerberos unconstrained delegations\"\n        self.description = \"These objects are allowed to connect to any service with the identity of another user who connected to them.\"\n        self.interpretation = \"\"\n        self.risk = \"These objects can impersonate any domain and eventually lead to full compromise of the infrastructure. Optimally, this list should be empty as delegation should be set up with constrained delegation.\"\n        self.poa = \"Unless necessary, switch to constrained delegation for a safer infrastructure.\"\n\n        self.kud = requests_results[\"kud\"]\n        self.kud_graphs = {}\n\n        self.graph_path_objects_to_unconstrained_delegation_users = {\n            \"description\": \"Path to user accounts that are allowed to connect to any service with the identity of another user who connected to them.\",\n            \"risk\": \"These accounts can impersonate any domain and eventually lead to full compromise of the infrastructure. Optimally, this list should be empty as delegation should be set up with constrained delegation.\",\n            \"poa\": \"Unless necessary, switch to constrained delegation for a safer infrastructure.\",\n        }\n\n    def run(self):\n        if self.kud is None:\n            return\n        logger.print_debug(\"Generate paths to Kerberos Unconstrained Delegations\")\n\n        for path in self.kud:\n            if not self.kud_graphs.get(path.nodes[-1].name):\n                self.kud_graphs[path.nodes[-1].name] = [path]\n            else:\n                self.kud_graphs[path.nodes[-1].name].append(path)\n\n        page = Page(\n            self.arguments.cache_prefix,\n            \"non-dc_with_unconstrained_delegations\",\n            \"Path to Unconstrained Delegations\",\n            self.get_dico_description(),\n        )\n        grid = Grid(\n            \"Numbers of path to domain admin using Kerberos Unconstrained Delegations\"\n        )\n        grid_data = []\n\n        self.kud_list = self.kud_graphs.keys()\n\n        for end_node in self.kud_list:\n            # if len(self.kud_graphs[end_node]):\n            node = self.kud_graphs[end_node][0].nodes[-1]\n            node.relation_type = \"UnconstrainedDelegations\"\n            domain = node.domain\n            end = Node(\n                id=42424243,\n                labels=\"Domain\",\n                name=domain,\n                domain=\"end\",\n                tenant_id=None,\n                relation_type=\"UnconstrainedDelegations\",\n            )\n            path = Path([self.kud_graphs[end_node][0].nodes[-1], end])\n            self.kud_graphs[end_node].append(path)\n\n            createGraphPage(\n                self.arguments.cache_prefix,\n                end_node + \"_kud_graph\",\n                \"Paths to Unconstrained Delegations\",\n                self.graph_path_objects_to_unconstrained_delegation_users,\n                self.kud_graphs[end_node],\n                self.requests_results,\n            )\n\n            tmp_data = {}\n\n            if node.labels == \"User\":\n                pretty_name = f'<i class=\"bi bi-person-fill\"></i> {end_node}'\n            elif node.labels == \"Computer\":\n                pretty_name = f'<i class=\"bi bi-pc-display\"></i> {end_node}'\n            else:\n                pretty_name = end_node\n\n            tmp_data[\"Configured for Kerberos Unconstrained Delegation\"] = pretty_name\n            tmp_data[\"Compromise Paths\"] = grid_data_stringify(\n                {\n                    \"value\": f'{len(self.kud_graphs[end_node])} <i class=\"bi bi-shuffle 000001\"></i>',\n                    \"link\": \"%s_kud_graph.html\" % quote(str(end_node)),\n                }\n            )\n\n            grid_data.append(tmp_data)\n        headers = [\n            \"Configured for Kerberos Unconstrained Delegation\",\n            \"Compromise Paths\",\n        ]\n        grid.setheaders(headers)\n        grid.setData(grid_data)\n        page.addComponent(grid)\n        page.render()\n\n        self.data = len(self.kud_list) if self.kud_list else 0\n\n        # TODO define the sentence that will be displayed in the 'smolcard' view and in the center of the mainpage\n        self.name_description = f\"{self.data} objects with unconstrained delegations\"\n\n    def get_rating(self) -> int:\n        return presence_of(self.kud_list, criticity=1)\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/__init__.py": {
        "imported_elements": [
          "logger"
        ],
        "code_map": {}
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "ad_miner/sources/modules/node_neo4j.py": {
        "imported_elements": [
          "Node"
        ],
        "code_map": {
          "Node": "class Node:\n\n    # TODO PARSE LABELS HERE\n    def __init__(self, id, labels, name, domain, tenant_id, relation_type):\n        self.id = id\n        self.labels = labels\n        self.name = name\n        self.domain = str(domain)\n        self.tenant_id = tenant_id\n        self.relation_type = relation_type\n\n    # Needed to use set() on a list of nodes (to remove duplicates from lists)\n    def __hash__(self):\n        return hash(self.id)\n\n    def __eq__(self, other):\n        if not isinstance(other, Node):\n            return NotImplemented\n        ret = (\n            (self.id == other.id)\n            and (self.labels == other.labels)\n            and (self.name == other.name)\n            and (self.domain == other.domain)\n            and (self.tenant_id == other.tenant_id)\n            and (self.relation_type == other.relation_type)\n        )\n        return ret"
        }
      },
      "ad_miner/sources/modules/path_neo4j.py": {
        "imported_elements": [
          "Path"
        ],
        "code_map": {
          "Path": "class Path:\n    def __init__(self, nodes):\n        self.nodes = nodes\n\n    def __eq__(self, other):\n        if not isinstance(other, Path):\n            return NotImplemented\n        if len(self.nodes) != len(other.nodes):\n            return False\n\n        ret = True\n        for i in range(len(self.nodes)):\n            ret = ret and (self.nodes[i] == other.nodes[i])\n        return ret\n\n    def reverse(self):\n        self.nodes.reverse()\n        for i in range(len(self.nodes) - 1):\n            self.nodes[i].relation_type = self.nodes[i + 1].relation_type\n        self.nodes[-1].relation_type = \"\""
        }
      },
      "ad_miner/sources/modules/utils.py": {
        "imported_elements": [
          "grid_data_stringify"
        ],
        "code_map": {
          "grid_data_stringify": "def grid_data_stringify(raw_data: dict) -> str:\n    \"\"\"\n    Transform a dict to a string for the grid formating. This is a dumb fix for the sorting with hyperlink.\n    dict format :\n    {\n        \"link\",\n        \"value\",\n        \"before_link\"\n    }\n    \"\"\"\n    link = raw_data['link'].replace(sep, '_').replace('/', '_')\n    try:\n        return f\"{raw_data['before_link']} <a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\"\n    except KeyError:\n        return f\"<a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\""
        }
      },
      "ad_miner/sources/modules/common_analysis.py": {
        "imported_elements": [
          "presence_of",
          ""
        ],
        "code_map": {
          "presence_of": "def presence_of(req, criticity=1, threshold=0):\n    if req is None:\n        return -1\n    if len(req) > threshold:\n        return criticity\n    return 5"
        }
      },
      "/Users/steverassinot/Repos/AD_Miner/urllib/parse/__init__.py": {
        "imported_elements": [
          "quote"
        ],
        "code_map": {}
      }
    },
    "requests_keys": [
      "kud"
    ]
  },
  {
    "title": "Computers admin of other computers",
    "file_name": "computers_admin_of_computers.py",
    "control_category": "Permissions",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\n\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\nfrom ad_miner.sources.modules.utils import grid_data_stringify\nfrom ad_miner.sources.modules import generic_formating, generic_computing\nfrom ad_miner.sources.modules.common_analysis import (\n    findAndCreatePathToDaFromComputersList,\n    hasPathToDA,\n)\nimport json\nfrom urllib.parse import quote\n\n\n@register_control\nclass computers_admin_of_computers(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"permissions\"\n        self.control_key = \"computers_admin_of_computers\"\n\n        self.title = \"Computers admin of other computers\"\n        self.description = \"Some machine accounts have administration privileges over other computers accounts.\"\n        self.risk = \"This controls reveals computers (i.e., the computer machine account) that have local administration privileges over other computers. This weakness can be leveraged by any domain user to relay coerced connections and eventually obtain local administration privileges over target computer. Coerced authentication can be triggered using numerous techniques such as EFSRPC (e.g., using PetitPotam). This attack requires network access over target machine and that SMB signing be not required (which is default).\"\n        self.poa = \"Microsoft's primary goal is not to mitigate coerced-authentication based attacks. Indeed, the general recommendation is to require SMB signing and also to ensure that unnecessarry relayable services (e.g., SMB, RPC, etc.) be filtered to users.\"\n\n        self.dico_description_computer_admin = {\n            \"description\": \"List of computers admin of other machines.\",\n            \"risk\": \"This controls reveals computers (i.e., the computer machine account) that have local administration privileges over other computers. This weakness can be leveraged by any domain user to relay coerced connections and eventually obtain local administration privileges over target computer. Coerced authentication can be triggered using numerous techniques such as EFSRPC (e.g., using PetitPotam). This attack requires network access over target machine and that SMB signing be not required (which is default).\",\n            \"poa\": \"Microsoft's primary goal is not to mitigate coerced-authentication based attacks. Indeed, the general recommendation is to require SMB signing and also to ensure that unnecessarry relayable services (e.g., SMB, RPC, etc.) be filtered to users.\",\n        }\n\n        self.list_computers_admin_computers = requests_results[\n            \"computers_admin_on_computers\"\n        ]\n\n    def run(self):\n        if self.list_computers_admin_computers is None:\n            return\n        computers_admin_to_count = generic_computing.getCountValueFromKey(\n            self.list_computers_admin_computers, \"source_computer\"\n        )\n        self.count_computers_admins = len(computers_admin_to_count)\n        computers_admin_to_count_target = generic_computing.getCountValueFromKey(\n            self.list_computers_admin_computers, \"target_computer\"\n        )\n        self.count_computers_admins_target = len(computers_admin_to_count_target)\n        computers_admin_to_list = generic_computing.getListAdminTo(\n            self.list_computers_admin_computers, \"source_computer\", \"target_computer\"\n        )\n        self.computers_admin_data_grid = []\n        for admin_computer, computers_list in computers_admin_to_list.items():\n            if admin_computer is not None and computers_list is not None:\n                num_path, nb_domains = findAndCreatePathToDaFromComputersList(\n                    self.requests_results,\n                    self.arguments,\n                    admin_computer,\n                    computers_list,\n                )\n                sortClass1 = str(computers_admin_to_count[admin_computer]).zfill(6)\n                sortClass2 = str(num_path).zfill(6)\n\n                tmp_line = {\n                    \"Computer Admin\": '<i class=\"bi bi-pc-display\"></i> '\n                    + admin_computer,\n                    \"Computers count\": grid_data_stringify(\n                        {\n                            \"value\": f\"{computers_admin_to_count[admin_computer]} computers\",\n                            \"link\": f\"computer_admin_{quote(str(admin_computer))}.html\",\n                            \"before_link\": f\"<i class='bi bi-pc-display {sortClass1}'></i>\",\n                        }\n                    ),\n                }\n                if num_path > 0:\n                    tmp_line[\"Paths to domain admin\"] = grid_data_stringify(\n                        {\n                            \"value\": f\"{num_path} paths to DA ({nb_domains} domain{'s' if nb_domains>1 else ''} impacted)\",\n                            \"link\": f\"computers_path_to_da_from_{quote(str(admin_computer))}.html\",\n                            \"before_link\": f\"<i class='bi bi-shuffle {sortClass2}' aria-hidden='true'></i>\",\n                        }\n                    )\n                else:\n                    tmp_line[\"Paths to domain admin\"] = \"-\"\n\n                self.computers_admin_data_grid.append(tmp_line)\n        self.computers_admin_data_grid.sort(\n            key=lambda x: x[\"Computers count\"], reverse=True\n        )\n\n        # Compute page computers : numbers of administrable computers\n        page = Page(\n            self.arguments.cache_prefix,\n            \"computers_admin_of_computers\",\n            \"Computers admin of other computers\",\n            self.get_dico_description(),\n        )\n        grid = Grid(\"Computers admins of other computers\")\n        grid.setheaders([\"Computer Admin\", \"Computers count\", \"Paths to domain admin\"])\n        grid.setData(json.dumps(self.computers_admin_data_grid))\n        page.addComponent(grid)\n        page.render()\n\n        # Compute page for each computer who have admin computer\n        for computer, values in computers_admin_to_list.items():\n            if computer is not None:\n                page = Page(\n                    self.arguments.cache_prefix,\n                    \"computer_admin_\" + computer,\n                    \"Admin of computer \" + computer,\n                    self.dico_description_computer_admin,\n                )\n                grid = Grid(\"List of computers where %s is admin\" % (computer))\n                grid.addheader(computer)\n                computers_admin_to_list = generic_formating.formatGridValues1Columns(\n                    values, grid.getHeaders()\n                )\n\n                grid.setData(computers_admin_to_list)\n                page.addComponent(grid)\n                page.render()\n            else:\n                print(\"Bug\")\n                # List of computers with most users admin page (and if to handle empty cases)\n\n        self.data = self.count_computers_admins if self.count_computers_admins else 0\n\n        # TODO define the sentence that will be displayed in the 'smolcard' view and in the center of the mainpage\n        self.name_description = f\"{self.count_computers_admins} computers admin of {self.count_computers_admins_target} computers\"\n\n    def get_rating(self) -> int:\n        return hasPathToDA(self.list_computers_admin_computers)\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "ad_miner/sources/modules/utils.py": {
        "imported_elements": [
          "grid_data_stringify"
        ],
        "code_map": {
          "grid_data_stringify": "def grid_data_stringify(raw_data: dict) -> str:\n    \"\"\"\n    Transform a dict to a string for the grid formating. This is a dumb fix for the sorting with hyperlink.\n    dict format :\n    {\n        \"link\",\n        \"value\",\n        \"before_link\"\n    }\n    \"\"\"\n    link = raw_data['link'].replace(sep, '_').replace('/', '_')\n    try:\n        return f\"{raw_data['before_link']} <a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\"\n    except KeyError:\n        return f\"<a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\""
        }
      },
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/__init__.py": {
        "imported_elements": [
          "generic_formating",
          ""
        ],
        "code_map": {}
      },
      "ad_miner/sources/modules/common_analysis.py": {
        "imported_elements": [
          "("
        ],
        "code_map": {}
      },
      "/Users/steverassinot/Repos/AD_Miner/urllib/parse/__init__.py": {
        "imported_elements": [
          "quote"
        ],
        "code_map": {}
      }
    },
    "requests_keys": [
      "computers_admin_on_computers"
    ]
  },
  {
    "title": "Paths to Operators Groups",
    "file_name": "objects_to_operators_member.py",
    "control_category": "Permissions",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\n\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\nfrom ad_miner.sources.modules.graph_class import Graph\nfrom ad_miner.sources.modules.utils import grid_data_stringify\nfrom ad_miner.sources.modules.common_analysis import presence_of\n\nfrom urllib.parse import quote\n\n\n@register_control\nclass objects_to_operators_member(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"permissions\"\n        self.control_key = \"objects_to_operators_member\"\n\n        self.title = \"Paths to Operators Groups\"\n        self.description = \"Objects with a compromission path to an Operator Group.\"\n        self.risk = \"As Oprator Groups have high privilege, a compromission path to one is a major threat to the security of the domain.\"\n        self.poa = \"Review all these paths and try to remove as many dangerous links as possible.\"\n\n        self.objects_to_operators_member = requests_results[\n            \"objects_to_operators_member\"\n        ]\n        self.objects_to_operators_groups = requests_results[\n            \"objects_to_operators_groups\"\n        ]\n\n    def run(self):\n        page = Page(\n            self.arguments.cache_prefix,\n            \"objects_to_operators_member\",\n            \"Paths to Operators Groups\",\n            self.get_dico_description(),\n        )\n        # Build raw data from requests\n        data = {}\n        for path in self.objects_to_operators_groups:\n            try:\n                data[path.nodes[0].name][\"paths\"].append(path)\n                if path.nodes[-1].name not in data[path.nodes[0].name][\"target\"]:\n                    data[path.nodes[0].name][\"target\"].append(path.nodes[-1].name)\n            except KeyError:\n                data[path.nodes[0].name] = {\n                    \"domain\": '<i class=\"bi bi-globe2\"></i> ' + path.nodes[-1].domain,\n                    \"name\": '<i class=\"bi bi-people-fill\"></i> ' + path.nodes[0].name,\n                    \"link\": quote(str(path.nodes[0].name)),\n                    \"target\": [path.nodes[-1].name],\n                    \"paths\": [path],\n                }\n        # print(data)\n        for path in self.objects_to_operators_member:\n            try:\n                data[path.nodes[-1].name][\"paths\"].append(path)\n            except (\n                KeyError\n            ):  # Really **should not** happen, but to prevent crash in case of corrupted cache/db\n                data[path.nodes[-1].name] = {\n                    \"domain\": '<i class=\"bi bi-globe2\"></i> ' + path.nodes[-1].domain,\n                    \"name\": '<i class=\"bi bi-people-fill\"></i> ' + path.nodes[-1].name,\n                    \"link\": quote(str(path.nodes[-1].name)),\n                    \"target\": [\"\"],\n                    \"paths\": [path],\n                }\n\n        # Build grid data\n        grid_data = []\n        for d in data.values():\n            sortClass = str(len(d[\"paths\"])).zfill(6)\n            tmp_grid_data = {\n                \"domain\": d[\"domain\"],\n                \"name\": d[\"name\"],\n                \"paths\": grid_data_stringify(\n                    {\n                        \"value\": f\"{len(d['paths'])} paths target{'s' if len(d['target'])>1 else ''}\",\n                        \"link\": f\"objects_to_operators_{quote(str(d['link']))}.html\",\n                        \"before_link\": f\"<i class='{sortClass} bi bi-shuffle' aria-hidden='true'></i>\",\n                    }\n                ),\n                \"targets\": \",\".join(d[\"target\"]),\n            }\n            grid_data.append(tmp_grid_data)\n            # Build graph data\n            page_graph = Page(\n                self.arguments.cache_prefix,\n                f\"objects_to_operators_{d['link']}\",\n                f\"Paths to Operator group using {d['name']}\",\n                self.get_dico_description(),\n            )\n            graph = Graph()\n            graph.setPaths(d[\"paths\"])\n            page_graph.addComponent(graph)\n            page_graph.render()\n\n        self.objects_to_operators_member = data.keys()\n        grid = Grid(\"Objects with path to Operator Groups\")\n        grid.setheaders([\"domain\", \"name\", \"paths\", \"targets\"])\n        grid.setData(grid_data)\n        page.addComponent(grid)\n        page.render()\n\n        self.data = (\n            len(self.objects_to_operators_member)\n            if len(self.objects_to_operators_member)\n            else 0\n        )\n        self.name_description = f\"{self.data} paths to Operators Groups\"\n\n    def get_rating(self) -> int:\n        return presence_of(self.objects_to_operators_member)\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "ad_miner/sources/modules/graph_class.py": {
        "imported_elements": [
          "Graph"
        ],
        "code_map": {
          "Graph": "class Graph:\n    def __init__(self, template=\"graph\", path_limit=80000):\n        self.template_base_path = HTML_DIRECTORY / \"components/graph/\"\n        self.template = template\n        self.paths = []\n        self.nodes = {}\n        self.relations = []\n        self.relations_hashes = {}\n        self.path_limit = path_limit\n        self.ghost_computer = {}\n        self.ghost_user = {}\n        self.dc_computer = {}\n        self.user_da = {}\n        self.group_da = {}\n        self.enabled_users = {}\n        self.kerberoastable_users = {}\n        self.disabled_users_dict = {}\n\n    def addPath(self, path):\n        self.paths.append(path)\n\n    def setPaths(self, paths):\n        self.paths = paths\n\n    def addGhostComputers(self, ghost_computer):\n        self.ghost_computer = ghost_computer\n\n    def addGhostUsers(self, ghost_user):\n        self.ghost_user = ghost_user\n\n    def addDCComputers(self, dc_computer):\n        self.dc_computer = dc_computer\n\n    def addUserDA(self, user_da):\n        self.user_da = user_da\n\n    def addGroupDA(self, group_da):\n        self.group_da = group_da\n\n    def addDisabledUsers(self, disabled_users):\n        self.disabled_users_dict = {}\n        for d in disabled_users:\n            self.disabled_users_dict[d[\"name\"]] = True\n\n    def addKerberoastableUsers(self, kerberoastable_users):\n        self.kerberoastable_users = kerberoastable_users\n\n    def render(self, page_f):\n\n        # Write header\n        with open(\n            self.template_base_path / (self.template + \"_header.html\"), \"r\"\n        ) as header_f:\n            html_header = header_f.read()\n            page_f.write(html_header)\n\n        for index, path in enumerate(self.paths):\n            for i in range(len(path.nodes)):\n\n                node = path.nodes[i]\n\n                # Compute node style\n                if i == 0:\n                    node_position = \"start\"\n                elif i == len(path.nodes) - 1:\n                    node_position = \"end\"\n                else:\n                    node_position = \"intermediate\"\n\n                # Add new labels here. A corresponding svg icon should be defined\n                # dico_icon in the icon.js file.\n                list_labels = [\n                    \"User\",\n                    \"Foreignsecurityprincipal\",\n                    \"GPO\",\n                    \"Computer\",\n                    \"OU\",\n                    \"Group\",\n                    \"Domain\",\n                    \"ADLocalGroup\",\n                    \"Container\",\n                    \"Unknown\",\n                    \"Group_cluster\",\n                    \"Device\",\n                    \"AZTenant\",\n                    \"AZRole\",\n                ]\n\n                if node.labels in list_labels:\n                    label_instance = node.labels\n                elif path.nodes[i].labels[2:] in list_labels:\n                    label_instance = node.labels[2:]\n                else:\n                    label_instance = \"Unknown\"\n\n                node_attributes = []\n\n                # Add DA icon if node is DC, DA or Domain\n                if (\n                    (\n                        label_instance == \"Computer\"\n                        and self.dc_computer.get(node.name, False)\n                    )\n                    or (label_instance == \"User\" and self.user_da.get(node.name, False))\n                    or (\n                        label_instance == \"Group\"\n                        and self.group_da.get(node.name, False)\n                    )\n                    or label_instance == \"Domain\"\n                ):\n                    node_attributes.append(\"da\")\n\n                # Add ghost icon if ghost\n                if (\n                    label_instance == \"User\" and self.ghost_user.get(node.name, False)\n                ) or (\n                    label_instance == \"Computer\"\n                    and self.ghost_computer.get(node.name, False)\n                ):\n                    node_attributes.append(\"ghost\")\n\n                if label_instance == \"User\" and self.disabled_users_dict.get(\n                    node.name, False\n                ):\n                    node_attributes.append(\"disabled\")\n\n                if label_instance == \"User\" and self.kerberoastable_users.get(\n                    node.name, False\n                ):\n                    node_attributes.append(\"kerberoastable\")\n\n                # New nodes attributes that should be added to the node icon\n                # should be added here to the node_attributes list.\n                # A corresponding svg icon should the be added to the\n                # dico_icon in icon.js\n\n                if not self.nodes.get(path.nodes[i].id):\n\n                    final_graph_node = {\n                        \"id\": path.nodes[i].id,\n                        \"label\": path.nodes[i].name,\n                        \"domain\": path.nodes[i].domain,\n                        \"shape\": \"image\",\n                        \"instance\": label_instance,\n                        \"position\": node_position,\n                        \"attributes\": node_attributes,\n                    }\n                    self.nodes[path.nodes[i].id] = final_graph_node\n\n                if i != 0:\n                    relation = {\n                        \"from\": path.nodes[i - 1].id,\n                        \"to\": path.nodes[i].id,\n                        \"label\": path.nodes[i - 1].relation_type,\n                    }\n\n                    # Avoid relation duplicated to keep graph clean\n                    # Use hashes list for better performance\n                    hash_rel = hash(\n                        str(relation[\"from\"])\n                        + str(relation[\"to\"])\n                        + str(relation[\"label\"])\n                    )\n                    if not self.relations_hashes.get(hash_rel):\n                        self.relations.append(relation)\n                        self.relations_hashes[hash_rel] = True\n\n        nodes = list(self.nodes.values())\n        for n in nodes:  # Sanitize None values (otherwise it creates a bug in JS)\n            if n[\"label\"] == None:\n                n[\"label\"] = \"???\"\n        page_f.write(f'<script type=\"text/javascript\">window.data_nodes = {nodes};\\n')\n        page_f.write(f\"window.data_edges = {self.relations};</script>\\n\")"
        }
      },
      "ad_miner/sources/modules/utils.py": {
        "imported_elements": [
          "grid_data_stringify"
        ],
        "code_map": {
          "grid_data_stringify": "def grid_data_stringify(raw_data: dict) -> str:\n    \"\"\"\n    Transform a dict to a string for the grid formating. This is a dumb fix for the sorting with hyperlink.\n    dict format :\n    {\n        \"link\",\n        \"value\",\n        \"before_link\"\n    }\n    \"\"\"\n    link = raw_data['link'].replace(sep, '_').replace('/', '_')\n    try:\n        return f\"{raw_data['before_link']} <a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\"\n    except KeyError:\n        return f\"<a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\""
        }
      },
      "ad_miner/sources/modules/common_analysis.py": {
        "imported_elements": [
          "presence_of"
        ],
        "code_map": {
          "presence_of": "def presence_of(req, criticity=1, threshold=0):\n    if req is None:\n        return -1\n    if len(req) > threshold:\n        return criticity\n    return 5"
        }
      },
      "/Users/steverassinot/Repos/AD_Miner/urllib/parse/__init__.py": {
        "imported_elements": [
          "quote"
        ],
        "code_map": {}
      }
    },
    "requests_keys": [
      "objects_to_operators_member",
      "objects_to_operators_groups"
    ]
  },
  {
    "title": "Users FGPP",
    "file_name": "fgpp.py",
    "control_category": "Misc",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\n\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\n\n\n@register_control\nclass fgpp(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"misc\"\n        self.control_key = \"fgpp\"\n\n        self.title = \"Users FGPP\"\n        self.description = \"FGPP applied to a user, directly or via a group\"\n        self.risk = \"FGPP change password and lockout policies if defined\"\n        self.poa = \"The FGPP values overwrite the GPO values\"\n\n        self.fgpps = requests_results[\"get_fgpp\"]\n\n    def run(self):\n        fgpps = self.fgpps\n        # create the page\n        page = Page(\n            self.arguments.cache_prefix,\n            \"fgpp\",\n            \"Users FGPP\",\n            self.get_dico_description(),\n        )\n        # create the grid\n        grid = Grid(\"Users FGPP\")\n        # create the headers\n        headers = [\n            \"affected object\",\n            \"fgpp name\",\n            \"minimumPasswordLength\",\n            \"minimumPasswordAge\",\n            \"maximumPasswordAge\",\n            \"clearTextPassword\",\n            \"passwordHistorySize\",\n            \"passwordComplexity\",\n            \"lockoutDuration\",\n            \"lockoutThreshold\",\n            \"lockoutObservationWindow\",\n        ]\n        # get the grid data\n        grid_data = []\n        for (\n            obj,\n            fgppName,\n            minPassLen,\n            minPassAge,\n            maxPassAge,\n            clearTextPass,\n            passHistSize,\n            passComp,\n            lockThre,\n            lockDur,\n            lockObsWin,\n        ) in fgpps:\n            tmp_data = {}\n            tmp_data[\"affected object\"] = obj if obj != None else \"X\"\n            tmp_data[\"fgpp name\"] = fgppName if fgppName != None else \"X\"\n            tmp_data[\"minimumPasswordLength\"] = (\n                minPassLen if minPassLen != None else \"X\"\n            )\n            tmp_data[\"minimumPasswordAge\"] = minPassAge if minPassAge != None else \"X\"\n            tmp_data[\"maximumPasswordAge\"] = maxPassAge if maxPassAge != None else \"X\"\n            tmp_data[\"clearTextPassword\"] = (\n                clearTextPass if clearTextPass != None else \"X\"\n            )\n            tmp_data[\"passwordHistorySize\"] = (\n                passHistSize if passHistSize != None else \"X\"\n            )\n            tmp_data[\"passwordComplexity\"] = passComp if passComp != None else \"X\"\n            tmp_data[\"lockoutDuration\"] = lockDur if lockDur != None else \"X\"\n            tmp_data[\"lockoutThreshold\"] = lockThre if lockThre != None else \"X\"\n            tmp_data[\"lockoutObservationWindow\"] = (\n                lockObsWin if lockObsWin != None else \"X\"\n            )\n            grid_data.append(tmp_data)\n\n        grid.setheaders(headers)\n        grid.setData(grid_data)\n        page.addComponent(grid)\n        page.render()\n\n        self.data = len(self.fgpps)\n        self.name_description = f\"{self.data} FGPP defined\"\n\n    def get_rating(self) -> int:\n        return -1 if len(self.fgpps) == 0 else 5\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      }
    },
    "requests_keys": [
      "get_fgpp"
    ]
  },
  {
    "title": "Machine accounts with inadequate privileges",
    "file_name": "computers_members_high_privilege.py",
    "control_category": "Permissions",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\n\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\nfrom ad_miner.sources.modules.common_analysis import presence_of\n\n\n@register_control\nclass computers_members_high_privilege(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"permissions\"\n        self.control_key = \"computers_members_high_privilege\"\n\n        self.title = \"Machine accounts with inadequate privileges\"\n        self.description = \"List of computers with high privileges.\"\n        self.risk = \"Ideally, this list should be reduced to the minimum required. If these machines are compromised by an attacker, they will provide them with the corresponding privileges, which could be very dangerous.\"\n        self.poa = \"Check for any anomaly in this list.\"\n\n        self.computers_members_high_privilege = requests_results[\n            \"computers_members_high_privilege\"\n        ]\n        if self.computers_members_high_privilege is None:\n            self.computers_members_high_privilege_uniq = None\n        else:\n            self.computers_members_high_privilege_uniq = list(\n                dict.fromkeys(\n                    d[\"computer\"] for d in self.computers_members_high_privilege\n                )\n            )\n\n    def run(self):\n        if self.computers_members_high_privilege is None:\n            return\n        page = Page(\n            self.arguments.cache_prefix,\n            \"computers_members_high_privilege\",\n            \"Machine accounts with inadequate privileges\",\n            self.get_dico_description(),\n        )\n        grid = Grid(\"List of computer admins\")\n        for d in self.computers_members_high_privilege:\n            d[\"domain\"] = '<i class=\"bi bi-globe2\"></i> ' + d[\"domain\"]\n            d[\"computer\"] = '<i class=\"bi bi-pc-display\"></i> ' + d[\"computer\"]\n            d[\"group\"] = '<i class=\"bi bi-people-fill\"></i> ' + d[\"group\"]\n        grid.setheaders([\"domain\", \"computer\", \"group\"])\n        grid.setData(self.computers_members_high_privilege)\n        page.addComponent(grid)\n        page.render()\n\n        self.data = (\n            len(self.computers_members_high_privilege_uniq)\n            if self.computers_members_high_privilege_uniq\n            else 0\n        )\n\n        self.name_description = f\"{self.data} computers with high privs.\"\n\n    def get_rating(self) -> int:\n        return presence_of(self.computers_members_high_privilege_uniq)\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "ad_miner/sources/modules/common_analysis.py": {
        "imported_elements": [
          "presence_of"
        ],
        "code_map": {
          "presence_of": "def presence_of(req, criticity=1, threshold=0):\n    if req is None:\n        return -1\n    if len(req) > threshold:\n        return criticity\n    return 5"
        }
      }
    },
    "requests_keys": [
      "computers_members_high_privilege"
    ]
  },
  {
    "title": "Paths to the AdminSDHolder container",
    "file_name": "vuln_permissions_adminsdholder.py",
    "control_category": "Permissions",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\n\nfrom ad_miner.sources.modules.common_analysis import presence_of, createGraphPage\n\n\n@register_control\nclass vuln_permissions_adminsdholder(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"permissions\"\n        self.control_key = \"vuln_permissions_adminsdholder\"\n\n        self.title = \"Paths to the AdminSDHolder container\"\n        self.description = \"Paths to the AdminSDHolder container\"\n\n        self.vuln_permissions_adminsdholder = requests_results[\n            \"vuln_permissions_adminsdholder\"\n        ]\n\n    def run(self):\n        createGraphPage(\n            self.arguments.cache_prefix,\n            \"vuln_permissions_adminsdholder\",\n            \"Objects with path to the adminSDHolder object\",\n            self.get_dico_description(),\n            self.vuln_permissions_adminsdholder,\n            self.requests_results,\n        )\n        self.data = (\n            len(self.vuln_permissions_adminsdholder)\n            if self.vuln_permissions_adminsdholder\n            else 0\n        )\n\n        self.name_description = f\"{self.data} paths to an AdminSDHolder container\"\n\n    def get_rating(self) -> int:\n        return presence_of(self.vuln_permissions_adminsdholder, criticity=1)\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/common_analysis.py": {
        "imported_elements": [
          "presence_of",
          ""
        ],
        "code_map": {
          "presence_of": "def presence_of(req, criticity=1, threshold=0):\n    if req is None:\n        return -1\n    if len(req) > threshold:\n        return criticity\n    return 5"
        }
      }
    },
    "requests_keys": [
      "vuln_permissions_adminsdholder"
    ]
  },
  {
    "title": "Shadow Credentials on privileged accounts",
    "file_name": "users_shadow_credentials.py",
    "control_category": "Kerberos",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\n\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\nfrom ad_miner.sources.modules.graph_class import Graph\n\nfrom ad_miner.sources.modules.utils import grid_data_stringify\nfrom ad_miner.sources.modules.common_analysis import presence_of\n\nfrom urllib.parse import quote\n\n\n@register_control\nclass users_shadow_credentials(Control):  # TODO change the class name\n    \"Legacy control\"  # TODO small documentation here\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"kerberos\"\n        self.control_key = \"users_shadow_credentials\"\n\n        self.title = \"Shadow Credentials on privileged accounts\"\n        self.description = \"The following list shows users having sufficient privileges to perform shadow credentials on target privileged users.\"\n        self.risk = \"This list should be strictly empty, as it otherwise represents a major security flaw. This attack allows impersonnation of privileged users. Performing this attack relies on a particular kerberos authentication mode and would not be noticed by victims.\"\n        self.poa = \"All these users should have their privilege reduced so that this attack is not possible anymore.\"\n\n        self.users_shadow_credentials = requests_results[\"users_shadow_credentials\"]\n        self.users_shadow_credentials_uniq = []\n\n    def run(self):\n        if self.users_shadow_credentials is None:\n            return\n        page = Page(\n            self.arguments.cache_prefix,\n            \"users_shadow_credentials\",\n            \"List of non-privileged users that can perform shadow credentials on privileged accounts\",\n            self.get_dico_description(),\n        )\n        # Build raw data from requests\n        data = {}\n        for path in self.users_shadow_credentials:\n            try:\n                data[path.nodes[0]][\"paths\"].append(path)\n                if path.nodes[-1].name not in data[path.nodes[0]][\"target\"]:\n                    data[path.nodes[0]][\"target\"].append(path.nodes[-1].name)\n            except KeyError:\n                data[path.nodes[0]] = {\n                    \"domain\": path.nodes[0].domain,\n                    \"name\": path.nodes[0].name,\n                    \"target\": [path.nodes[-1].name],\n                    \"paths\": [path],\n                }\n\n        # Build grid data\n        grid_data = []\n        for d in data.values():\n            sortClass = str(len(d[\"paths\"])).zfill(6)\n            tmp_grid_data = {\n                \"domain\": '<i class=\"bi bi-globe2\"></i> ' + d[\"domain\"],\n                \"name\": '<i class=\"bi bi-person-fill\"></i> ' + d[\"name\"],\n                \"target\": grid_data_stringify(\n                    {\n                        \"value\": f\"{len(d['paths'])} paths to {len(d['target'])} target{'s' if len(d['target'])>1 else ''}\",\n                        \"link\": f\"users_shadow_credentials_from_{quote(str(d['name']))}.html\",\n                        \"before_link\": f\"<i class='{sortClass} bi bi-shuffle' aria-hidden='true'></i>\",\n                    }\n                ),\n            }\n            grid_data.append(tmp_grid_data)\n            # Build graph data\n            page_graph = Page(\n                self.arguments.cache_prefix,\n                f\"users_shadow_credentials_from_{d['name']}\",\n                f\"{d['name']} shadow credentials attack paths on privileged accounts\",\n                self.get_dico_description(),\n            )\n            graph = Graph()\n            graph.setPaths(d[\"paths\"])\n            page_graph.addComponent(graph)\n            page_graph.render()\n\n        self.users_shadow_credentials_uniq = data.keys()\n        grid = Grid(\"Shadow credentials\")\n        grid.setheaders([\"domain\", \"name\", \"target\"])\n        grid.setData(grid_data)\n        page.addComponent(grid)\n        page.render()\n\n        self.data = (\n            len(self.users_shadow_credentials_uniq)\n            if self.users_shadow_credentials_uniq\n            else 0\n        )\n\n        self.name_description = f\"{self.data} users can impersonate privileged accounts\"\n\n    def get_rating(self) -> int:\n        return presence_of(self.users_shadow_credentials)\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "ad_miner/sources/modules/graph_class.py": {
        "imported_elements": [
          "Graph"
        ],
        "code_map": {
          "Graph": "class Graph:\n    def __init__(self, template=\"graph\", path_limit=80000):\n        self.template_base_path = HTML_DIRECTORY / \"components/graph/\"\n        self.template = template\n        self.paths = []\n        self.nodes = {}\n        self.relations = []\n        self.relations_hashes = {}\n        self.path_limit = path_limit\n        self.ghost_computer = {}\n        self.ghost_user = {}\n        self.dc_computer = {}\n        self.user_da = {}\n        self.group_da = {}\n        self.enabled_users = {}\n        self.kerberoastable_users = {}\n        self.disabled_users_dict = {}\n\n    def addPath(self, path):\n        self.paths.append(path)\n\n    def setPaths(self, paths):\n        self.paths = paths\n\n    def addGhostComputers(self, ghost_computer):\n        self.ghost_computer = ghost_computer\n\n    def addGhostUsers(self, ghost_user):\n        self.ghost_user = ghost_user\n\n    def addDCComputers(self, dc_computer):\n        self.dc_computer = dc_computer\n\n    def addUserDA(self, user_da):\n        self.user_da = user_da\n\n    def addGroupDA(self, group_da):\n        self.group_da = group_da\n\n    def addDisabledUsers(self, disabled_users):\n        self.disabled_users_dict = {}\n        for d in disabled_users:\n            self.disabled_users_dict[d[\"name\"]] = True\n\n    def addKerberoastableUsers(self, kerberoastable_users):\n        self.kerberoastable_users = kerberoastable_users\n\n    def render(self, page_f):\n\n        # Write header\n        with open(\n            self.template_base_path / (self.template + \"_header.html\"), \"r\"\n        ) as header_f:\n            html_header = header_f.read()\n            page_f.write(html_header)\n\n        for index, path in enumerate(self.paths):\n            for i in range(len(path.nodes)):\n\n                node = path.nodes[i]\n\n                # Compute node style\n                if i == 0:\n                    node_position = \"start\"\n                elif i == len(path.nodes) - 1:\n                    node_position = \"end\"\n                else:\n                    node_position = \"intermediate\"\n\n                # Add new labels here. A corresponding svg icon should be defined\n                # dico_icon in the icon.js file.\n                list_labels = [\n                    \"User\",\n                    \"Foreignsecurityprincipal\",\n                    \"GPO\",\n                    \"Computer\",\n                    \"OU\",\n                    \"Group\",\n                    \"Domain\",\n                    \"ADLocalGroup\",\n                    \"Container\",\n                    \"Unknown\",\n                    \"Group_cluster\",\n                    \"Device\",\n                    \"AZTenant\",\n                    \"AZRole\",\n                ]\n\n                if node.labels in list_labels:\n                    label_instance = node.labels\n                elif path.nodes[i].labels[2:] in list_labels:\n                    label_instance = node.labels[2:]\n                else:\n                    label_instance = \"Unknown\"\n\n                node_attributes = []\n\n                # Add DA icon if node is DC, DA or Domain\n                if (\n                    (\n                        label_instance == \"Computer\"\n                        and self.dc_computer.get(node.name, False)\n                    )\n                    or (label_instance == \"User\" and self.user_da.get(node.name, False))\n                    or (\n                        label_instance == \"Group\"\n                        and self.group_da.get(node.name, False)\n                    )\n                    or label_instance == \"Domain\"\n                ):\n                    node_attributes.append(\"da\")\n\n                # Add ghost icon if ghost\n                if (\n                    label_instance == \"User\" and self.ghost_user.get(node.name, False)\n                ) or (\n                    label_instance == \"Computer\"\n                    and self.ghost_computer.get(node.name, False)\n                ):\n                    node_attributes.append(\"ghost\")\n\n                if label_instance == \"User\" and self.disabled_users_dict.get(\n                    node.name, False\n                ):\n                    node_attributes.append(\"disabled\")\n\n                if label_instance == \"User\" and self.kerberoastable_users.get(\n                    node.name, False\n                ):\n                    node_attributes.append(\"kerberoastable\")\n\n                # New nodes attributes that should be added to the node icon\n                # should be added here to the node_attributes list.\n                # A corresponding svg icon should the be added to the\n                # dico_icon in icon.js\n\n                if not self.nodes.get(path.nodes[i].id):\n\n                    final_graph_node = {\n                        \"id\": path.nodes[i].id,\n                        \"label\": path.nodes[i].name,\n                        \"domain\": path.nodes[i].domain,\n                        \"shape\": \"image\",\n                        \"instance\": label_instance,\n                        \"position\": node_position,\n                        \"attributes\": node_attributes,\n                    }\n                    self.nodes[path.nodes[i].id] = final_graph_node\n\n                if i != 0:\n                    relation = {\n                        \"from\": path.nodes[i - 1].id,\n                        \"to\": path.nodes[i].id,\n                        \"label\": path.nodes[i - 1].relation_type,\n                    }\n\n                    # Avoid relation duplicated to keep graph clean\n                    # Use hashes list for better performance\n                    hash_rel = hash(\n                        str(relation[\"from\"])\n                        + str(relation[\"to\"])\n                        + str(relation[\"label\"])\n                    )\n                    if not self.relations_hashes.get(hash_rel):\n                        self.relations.append(relation)\n                        self.relations_hashes[hash_rel] = True\n\n        nodes = list(self.nodes.values())\n        for n in nodes:  # Sanitize None values (otherwise it creates a bug in JS)\n            if n[\"label\"] == None:\n                n[\"label\"] = \"???\"\n        page_f.write(f'<script type=\"text/javascript\">window.data_nodes = {nodes};\\n')\n        page_f.write(f\"window.data_edges = {self.relations};</script>\\n\")"
        }
      },
      "ad_miner/sources/modules/utils.py": {
        "imported_elements": [
          "grid_data_stringify"
        ],
        "code_map": {
          "grid_data_stringify": "def grid_data_stringify(raw_data: dict) -> str:\n    \"\"\"\n    Transform a dict to a string for the grid formating. This is a dumb fix for the sorting with hyperlink.\n    dict format :\n    {\n        \"link\",\n        \"value\",\n        \"before_link\"\n    }\n    \"\"\"\n    link = raw_data['link'].replace(sep, '_').replace('/', '_')\n    try:\n        return f\"{raw_data['before_link']} <a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\"\n    except KeyError:\n        return f\"<a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\""
        }
      },
      "ad_miner/sources/modules/common_analysis.py": {
        "imported_elements": [
          "presence_of"
        ],
        "code_map": {
          "presence_of": "def presence_of(req, criticity=1, threshold=0):\n    if req is None:\n        return -1\n    if len(req) > threshold:\n        return criticity\n    return 5"
        }
      },
      "/Users/steverassinot/Repos/AD_Miner/urllib/parse/__init__.py": {
        "imported_elements": [
          "quote"
        ],
        "code_map": {}
      }
    },
    "requests_keys": [
      "users_shadow_credentials"
    ]
  },
  {
    "title": "AS-REP Roastable accounts",
    "file_name": "as_rep.py",
    "control_category": "Kerberos",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\n\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\nfrom ad_miner.sources.modules.common_analysis import containsDAs\n\nimport json\n\n\n@register_control\nclass as_rep(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"kerberos\"\n        self.control_key = \"as_rep\"\n\n        self.title = \"AS-REP Roastable accounts\"\n        self.description = \"These accounts do not need to authenticate to receive a response from the KDC containing the hash of the password of the account.\"\n        self.risk = \"Ideally, this list should be strictly empty. With the KRB_AS_REP, an attacker can find the password of the account offline and then take complete control of the account.\"\n        self.poa = \"Change the configuration of these accounts and make sure to not disable the need to authenticate.\"\n\n        self.users_kerberos_as_rep = requests_results[\"nb_as-rep_roastable_accounts\"]\n\n    def run(self):\n        if self.users_kerberos_as_rep is None:\n            return\n        page = Page(\n            self.arguments.cache_prefix,\n            \"as_rep\",\n            \"List of all users with AS-REP\",\n            self.get_dico_description(),\n        )\n        grid = Grid(\"Users with AS-REP\")\n        grid.setheaders([\"domain\", \"name\", \"is_Domain_Admin\"])\n        grid.setData(json.dumps(self.users_kerberos_as_rep))\n        page.addComponent(grid)\n        page.render()\n\n        self.data = len(self.users_kerberos_as_rep) if self.users_kerberos_as_rep else 0\n\n        self.name_description = f\"{self.data} accounts are AS-REP-roastable\"\n\n    def get_rating(self) -> int:\n        return containsDAs(self.users_kerberos_as_rep)\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "ad_miner/sources/modules/common_analysis.py": {
        "imported_elements": [
          "containsDAs"
        ],
        "code_map": {
          "containsDAs": "def containsDAs(req, criticity=1):\n    if req is None:\n        return -1\n\n    for object in req:\n        if object.get(\"is_Domain_Admin\"):\n            if object[\"is_Domain_Admin\"] == True:\n                return criticity\n        # if object.get(\"is_da\"):\n        #     if object[\"is_da\"] == True:\n        #         return criticity\n\n    if len(req) > 0:\n        return criticity + 1\n\n    return 5"
        }
      }
    },
    "requests_keys": [
      "nb_as-rep_roastable_accounts"
    ]
  },
  {
    "title": "Ghost computers",
    "file_name": "computers_last_connexion.py",
    "control_category": "Misc",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\n\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\nfrom ad_miner.sources.modules.utils import days_format\nfrom ad_miner.sources.modules.common_analysis import percentage_superior\n\n\n@register_control\nclass computers_last_connexion(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"misc\"\n        self.control_key = \"computers_last_connexion\"\n\n        # TODO define the control page title and texts\n        self.title = \"Ghost computers\"\n        self.description = \"Computer last logon to help identify computer objects that still exist in the domain but were most likely decommissioned.\"\n        self.risk = \"Computers with a last logon larger than 60 days are considered ghost and are most likely to correspond to computers that have been improperly terminated. Although these computers may no longer exist physically, privileges that they may have been granted may still be abused in attack path. For example, if the machine account of a ghost computer A has local administration privileges over computer B and if current ACEs allow writing over that ghost computer's msDs-KeyCredentialLink attribute, then this can be abused to obtain admin access over computer B.\"\n        self.poa = \"Confirm that listed ghost computers no longer exist and delete corresponding objects from Active Directory.\"\n\n        self.computers_with_last_connection_date = requests_results[\n            \"computers_not_connected_since\"\n        ]\n        self.computers_not_connected_since_60 = list(\n            filter(\n                lambda computer: int(computer[\"days\"]) > 60,\n                self.computers_with_last_connection_date,\n            )\n        )\n        self.list_total_computers = requests_results[\"nb_computers\"]\n\n    def run(self):\n        if self.computers_with_last_connection_date is None:\n            return\n        page = Page(\n            self.arguments.cache_prefix,\n            \"computers_last_connexion\",\n            \"Ghost computers\",\n            self.get_dico_description(),\n        )\n\n        data = []\n        for c in self.computers_not_connected_since_60:\n            data.append(\n                {\n                    \"name\": '<i class=\"bi bi-pc-display\"></i> ' + c[\"name\"],\n                    \"Last logon\": days_format(c[\"days\"]),\n                    \"Last password set\": days_format(c[\"pwdlastset\"]),\n                    \"Enabled\": str(c[\"enabled\"]),\n                }\n            )\n        grid = Grid(\"Computers not connected since\")\n        grid.setheaders([\"name\", \"Last logon\", \"Last password set\", \"Enabled\"])\n        grid.setData(data)\n        page.addComponent(grid)\n        page.render()\n\n        self.data = (\n            len(self.computers_not_connected_since_60)\n            if self.computers_not_connected_since_60\n            else 0\n        )\n\n        self.name_description = f\"{self.data} ghost computers\"\n\n    def get_rating(self) -> int:\n        return percentage_superior(\n            self.computers_not_connected_since_60,\n            self.list_total_computers,\n            criticity=2,\n            percentage=0.5,\n            presence=True,\n        )\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "ad_miner/sources/modules/utils.py": {
        "imported_elements": [
          "days_format"
        ],
        "code_map": {
          "days_format": "def days_format(nb_days: int, critical_time=90) -> str:\n    \"\"\"\n    Returns the date in a nice format\n    \"\"\"\n\n    critical_time = int(critical_time)\n\n    sortClass = str(nb_days).zfill(6)\n    if nb_days is None:\n        return f\"<i class='{sortClass} bi bi-x-circle' style='color: rgb(255, 89, 94);'></i> Unknown\"\n    if nb_days > 19000:\n        return f\"<i class='{sortClass} bi bi-x-circle' style='color: rgb(255, 89, 94);'></i> Never\"\n    y = nb_days // 365\n    m = (nb_days % 365) // 30\n    d = (nb_days % 365) % 30\n\n    color = \"#b00404\" if nb_days > 2 * critical_time else \"#e36402\" if nb_days > critical_time else \"#0a6e01\"\n\n    if y > 0:\n        return f\"<i class='{sortClass} bi bi-calendar3' style='color: {color};'></i> {y} year{'s' if y > 1 else ''}, {m} month{'s' if m > 1 else ''} and {d} day{'s' if d > 1 else ''}\"\n    elif m > 0:\n        return f\"<i class='{sortClass} bi bi-calendar3' style='color: {color};'></i> {m} month{'s' if m > 1 else ''} and {d} day{'s' if d > 1 else ''}\"\n    else:\n        return f\"<i class='{sortClass} bi bi-calendar3' style='color: {color};'></i> {d} day{'s' if d > 1 else ''}\""
        }
      },
      "ad_miner/sources/modules/common_analysis.py": {
        "imported_elements": [
          "percentage_superior"
        ],
        "code_map": {
          "percentage_superior": "def percentage_superior(req, base, criticity=1, percentage=0, presence=False):\n    if req is None:\n        return -1\n    if base is None:\n        return -1\n    if len(base) == 0:\n        return -1\n\n    if len(base) and len(req) / len(base) > percentage:\n        return criticity\n\n    if presence:\n        if len(req) > 0:\n            return criticity + 1\n    return 5"
        }
      }
    },
    "requests_keys": [
      "nb_computers",
      "computers_not_connected_since"
    ]
  },
  {
    "title": "Kerberos RBCD against computers",
    "file_name": "graph_list_objects_rbcd.py",
    "control_category": "Kerberos",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\n\nfrom ad_miner.sources.modules import logger\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\nfrom ad_miner.sources.modules.utils import grid_data_stringify\nfrom ad_miner.sources.modules.common_analysis import presence_of, createGraphPage\n\nfrom urllib.parse import quote\nfrom tqdm import tqdm\n\n\n@register_control\nclass graph_list_objects_rbcd(Control):  # TODO change the class name\n    \"Docstring of my control\"  # TODO small documentation here\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"kerberos\"\n        self.control_key = \"graph_list_objects_rbcd\"\n\n        self.title = \"Kerberos RBCD against computers\"\n        self.description = (\n            \"Users that can perform Ressource-Based Constrained Delegation attacks\"\n        )\n        self.risk = \"Users that have GenericWrite ACE on machines can perform RBCD attacks. Thanks to the GenericWrite access, the attacker can edit the 'msDS-AllowedToActOnBehalfOfOtherIdentity' attribute of the targeted machine and add an attacker-controlled account to it in order to impersonate any account of the domain. In short, if the attacker has GenericWrite over the target machine, then they can have local administration privileges. An attacker could take advantage of this misconfiguration to further compromise the domains.\"\n        self.poa = \"In order to perform RBCD attacks, the attackers need to use an account with a Service Principal Name. In order to make it more difficult for them, you cant reduce the 'MachineAccountQuota' domain-level attribute to 0 so that an attacker cannot create an SPN-enabled account for himself. What's more, review all the GenericWrite ACEs you can find and ask yourself if they are legitimate or if they could be removed.\"\n\n        self.dico_description_rbcd_to_da = {\n            \"title\": \"Compromission paths to domain admins\",\n            \"description\": \"Compromission paths from some Active Directory object to domain admin privileges.\",\n            \"risk\": \"Compromission paths to domain admin represent the exposed attack surface that the AD environment presents to the attacker in order to gain privileges in the domain(s). If an attacker exploits one of these paths, they will be able to gain privileges in the domain(s) and cause some serious damage.\",\n            \"poa\": \"Review the paths, make sure they are not exploitable. If they are, cut the link between the Active Directory objects in order to reduce the attack surface.\",\n        }\n\n        self.rbcd_paths = requests_results[\"graph_rbcd\"]\n        self.rbcd_paths_to_da = requests_results[\"graph_rbcd_to_da\"]\n\n        self.rbcd_to_da_graphs = {}\n        self.rbcd_graphs = {}\n\n        self.rbcd_nb_start_nodes = 0\n        self.rbcd_nb_end_nodes = 0\n\n    def run(self):\n        if self.rbcd_paths is None:\n            return\n        logger.print_debug(\"Generate paths of objects that can RCBD on a computer\")\n\n        for path in self.rbcd_paths_to_da:\n            starting_node = path.nodes[0]\n            starting_node_name = starting_node.name\n            if starting_node_name not in list(self.rbcd_to_da_graphs.keys()):\n                self.rbcd_to_da_graphs[starting_node_name] = {}\n                self.rbcd_to_da_graphs[starting_node_name][\"paths\"] = []\n            if path not in self.rbcd_to_da_graphs[starting_node_name][\"paths\"]:\n                self.rbcd_to_da_graphs[starting_node_name][\"paths\"].append(path)\n\n        for object_name in list(self.rbcd_to_da_graphs.keys()):\n            createGraphPage(\n                self.arguments.cache_prefix,\n                \"rbcd_target_\" + object_name + \"_paths_to_da\",\n                \"Path to DA from \" + object_name + \" RBCD target\",\n                self.dico_description_rbcd_to_da,\n                self.rbcd_to_da_graphs[object_name][\"paths\"],\n                requests_results=self.requests_results,\n            )\n\n        ending_nodes_names_distinct = []\n\n        for path in tqdm(self.rbcd_paths):\n            starting_node = path.nodes[0]\n            starting_node_name = starting_node.name\n            ending_node = path.nodes[-1]\n            ending_node_name = ending_node.name\n\n            if starting_node_name not in list(self.rbcd_graphs.keys()):\n                self.rbcd_nb_start_nodes += 1\n                self.rbcd_graphs[starting_node_name] = {}\n                self.rbcd_graphs[starting_node_name][\"paths\"] = []\n                self.rbcd_graphs[starting_node_name][\"nb_paths_to_da\"] = 0\n                self.rbcd_graphs[starting_node_name][\"destinations\"] = []\n                self.rbcd_graphs[starting_node_name][\"domain\"] = starting_node.domain\n            if path not in self.rbcd_graphs[starting_node_name][\"paths\"]:\n                self.rbcd_graphs[starting_node_name][\"paths\"].append(path)\n            if (\n                ending_node_name\n                not in self.rbcd_graphs[starting_node_name][\"destinations\"]\n            ):\n                self.rbcd_graphs[starting_node_name][\"destinations\"].append(\n                    ending_node_name\n                )\n            if ending_node_name not in ending_nodes_names_distinct:\n                self.rbcd_nb_end_nodes += 1\n                ending_nodes_names_distinct.append(ending_node_name)\n\n        for object_name in list(self.rbcd_graphs.keys()):\n\n            createGraphPage(\n                self.arguments.cache_prefix,\n                object_name + \"_rbcd_graph\",\n                \"Attack paths of accounts that can RBCD\",\n                self.get_dico_description(),\n                self.rbcd_graphs[object_name][\"paths\"],\n                self.requests_results,\n            )\n\n            sub_page = Page(\n                self.arguments.cache_prefix,\n                \"graph_list_objects_rbcd_to_da_from_\" + object_name,\n                \"Paths to DA from rbcd targets\",\n                self.dico_description_rbcd_to_da,\n            )\n            sub_grid = Grid(\"RBCD targets that have a path to DA from \" + object_name)\n            sub_grid_data = []\n\n            for destination in self.rbcd_graphs[object_name][\"destinations\"]:\n\n                sub_tmp_data = {}\n                sub_tmp_data[\"Name\"] = destination\n                if destination in list(self.rbcd_to_da_graphs.keys()):\n                    self.rbcd_graphs[object_name][\"nb_paths_to_da\"] += len(\n                        self.rbcd_to_da_graphs[destination][\"paths\"]\n                    )\n                    sortClass = str(\n                        len(self.rbcd_to_da_graphs[destination][\"paths\"])\n                    ).zfill(6)\n                    sub_tmp_data[\"Paths to DA\"] = grid_data_stringify(\n                        {\n                            \"value\": f'{len(self.rbcd_to_da_graphs[destination][\"paths\"])} path{\"s\" if len(self.rbcd_to_da_graphs[destination][\"paths\"]) > 1 else \"\"} to <i class=\"bi bi-gem\"></i> DA',\n                            \"link\": \"rbcd_target_%s_paths_to_da.html\"\n                            % quote(str(destination)),\n                            \"before_link\": f'<i class=\"bi bi-shuffle {sortClass}\"></i>',\n                        }\n                    )\n                else:\n                    sub_tmp_data[\"Paths to DA\"] = \"-\"\n                sub_grid_data.append(sub_tmp_data)\n            sub_headers = [\"Name\", \"Paths to DA\"]\n            sub_grid.setheaders(sub_headers)\n            sub_grid.setData(sub_grid_data)\n            sub_page.addComponent(sub_grid)\n            sub_page.render()\n\n        page = Page(\n            self.arguments.cache_prefix,\n            \"graph_list_objects_rbcd\",\n            \"Kerberos RBCD against computers\",\n            self.get_dico_description(),\n        )\n        grid = Grid(\"Objects that can perform an RBCD attack on computers\")\n        headers = [\"Domain\", \"Name\", \"Paths to targets\", \"Paths to DA\"]\n        grid.setheaders(headers)\n        grid_data = []\n\n        if len(list(self.rbcd_graphs.keys())) != 0:\n            for object_name in list(self.rbcd_graphs.keys()):\n                tmp_data = {}\n                tmp_data[\"Domain\"] = (\n                    '<i class=\"bi bi-globe2\"></i> '\n                    + self.rbcd_graphs[object_name][\"domain\"]\n                )\n                tmp_data[\"Name\"] = '<i class=\"bi bi-person-fill\"></i> ' + object_name\n                sortClass1 = str(len(self.rbcd_graphs[object_name][\"paths\"])).zfill(6)\n                tmp_data[\"Paths to targets\"] = grid_data_stringify(\n                    {\n                        \"value\": f'{len(self.rbcd_graphs[object_name][\"paths\"])} path{\"s\" if len(self.rbcd_graphs[object_name][\"paths\"]) > 1 else \"\"} to <i class=\"bi bi-bullseye\"></i> targets',\n                        \"link\": \"%s_rbcd_graph.html\" % quote(str(object_name)),\n                        \"before_link\": f'<i class=\"bi bi-shuffle {sortClass1}\"></i>',\n                    }\n                )\n                if self.rbcd_graphs[object_name][\"nb_paths_to_da\"] > 0:\n                    sortClass2 = str(\n                        self.rbcd_graphs[object_name][\"nb_paths_to_da\"]\n                    ).zfill(6)\n                    tmp_data[\"Paths to DA\"] = grid_data_stringify(\n                        {\n                            \"value\": f'{self.rbcd_graphs[object_name][\"nb_paths_to_da\"]} path{\"s\" if self.rbcd_graphs[object_name][\"nb_paths_to_da\"] > 1 else \"\"} to <i class=\"bi bi-gem\"></i> DA',\n                            \"link\": \"graph_list_objects_rbcd_to_da_from_%s.html\"\n                            % quote(str(object_name)),\n                            \"before_link\": f'<i class=\"bi bi-shuffle {sortClass2}\"></i>',\n                        }\n                    )\n                else:\n                    tmp_data[\"Paths to DA\"] = \"-\"\n                grid_data.append(tmp_data)\n        grid.setData(grid_data)\n        page.addComponent(grid)\n        page.render()\n\n        # TODO define the metric of your control\n        # it will be stored in the data json\n        self.data = len(list(self.rbcd_graphs.keys())) if self.rbcd_graphs else 0\n\n        # TODO define the sentence that will be displayed in the 'smolcard' view and in the center of the mainpage\n        self.name_description = f\"{self.rbcd_nb_start_nodes} users can perform an RBCD attack on {self.rbcd_nb_end_nodes} computers\"\n\n    def get_rating(self) -> int:\n        return min(\n            presence_of(list(self.rbcd_graphs.keys()), criticity=2),\n            presence_of(list(self.rbcd_to_da_graphs.keys()), criticity=1),\n        )\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/__init__.py": {
        "imported_elements": [
          "logger"
        ],
        "code_map": {}
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "ad_miner/sources/modules/utils.py": {
        "imported_elements": [
          "grid_data_stringify"
        ],
        "code_map": {
          "grid_data_stringify": "def grid_data_stringify(raw_data: dict) -> str:\n    \"\"\"\n    Transform a dict to a string for the grid formating. This is a dumb fix for the sorting with hyperlink.\n    dict format :\n    {\n        \"link\",\n        \"value\",\n        \"before_link\"\n    }\n    \"\"\"\n    link = raw_data['link'].replace(sep, '_').replace('/', '_')\n    try:\n        return f\"{raw_data['before_link']} <a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\"\n    except KeyError:\n        return f\"<a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\""
        }
      },
      "ad_miner/sources/modules/common_analysis.py": {
        "imported_elements": [
          "presence_of",
          ""
        ],
        "code_map": {
          "presence_of": "def presence_of(req, criticity=1, threshold=0):\n    if req is None:\n        return -1\n    if len(req) > threshold:\n        return criticity\n    return 5"
        }
      },
      "/Users/steverassinot/Repos/AD_Miner/urllib/parse/__init__.py": {
        "imported_elements": [
          "quote"
        ],
        "code_map": {}
      },
      "/Users/steverassinot/Repos/AD_Miner/tqdm/__init__.py": {
        "imported_elements": [
          "tqdm"
        ],
        "code_map": {}
      }
    },
    "requests_keys": [
      "graph_rbcd_to_da",
      "graph_rbcd"
    ]
  },
  {
    "title": "Objects with SID history",
    "file_name": "has_sid_history.py",
    "control_category": "Permissions",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\nfrom ad_miner.sources.modules import generic_formating, generic_computing\n\nfrom ad_miner.sources.modules.common_analysis import presence_of\n\nfrom urllib.parse import quote\n\n\n@register_control\nclass has_sid_history(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"permissions\"\n        self.control_key = \"has_sid_history\"\n\n        self.title = \"Objects with SID history\"\n        self.description = \"SID History (Security Identifier History) is a feature that allows a user or group to retain access to resources that they had permissions for in a different domain. This feature is particularly useful in scenarios involving domain migrations, domain trust relationships, or domain reorganizations.\"\n        self.risk = \" If an attacker gains control of an account with SID History entries, they may be able to use those historical SIDs to gain unauthorized access to resources in old domains. This is particularly concerning if the attacker can exploit vulnerabilities or weak security practices in the old domain.\"\n        self.poa = \"Regularly review and clean up SID History entries for users and groups that no longer require access to resources in old domains.\"\n\n        self.has_sid_history = requests_results[\"has_sid_history\"]\n        self.users_admin_on_computers = requests_results[\"users_admin_on_computers\"]\n\n        self.users_admin_computer_list = generic_computing.getListAdminTo(\n            self.users_admin_on_computers, \"user\", \"computer\"\n        )\n\n    def run(self):\n        page = Page(\n            self.arguments.cache_prefix,\n            \"has_sid_history\",\n            \"Objects who can abuse SID History\",\n            self.get_dico_description(),\n        )\n        grid = Grid(\"Objects who can abuse SID History\")\n        headers = [\"Has SID History\", \"Admin of\", \"Target\", \"admin of\"]\n\n        # add icons for type of object\n        star_icon = \"<i class='bi bi-star-fill' style='color:gold; text-shadow: 0px 0px 1px black, 0px 0px 1px black, 0px 0px 1px black, 0px 0px 1px black;' title='This SID history allows for access to more computers'></i>\"\n        for row in self.has_sid_history:\n            # add admin of columns\n            row[\"Admin of\"] = \"-\"\n            row[\"admin of\"] = \"-\"\n            target_count = 0\n            origin_count = 0\n            for d in self.users_admin_on_computers:\n                name_user = d[\"user\"]\n                if row[\"Has SID History\"] == name_user:\n                    origin_count = len(self.users_admin_computer_list[name_user])\n                    row[\"Admin of\"] = (\n                        f\"<i class='bi bi-pc-display-horizontal 000003'></i> <a style='color: blue' target='_blank' href='users_admin_of_computers_details.html?parameter={quote(name_user)}'> {origin_count} computer{'s' if origin_count > 0 else ''} </a>\"\n                    )\n\n                if row[\"Target\"] == name_user:\n                    target_count = len(self.users_admin_computer_list[name_user])\n                    row[\"admin of\"] = (\n                        f\"<i class='bi bi-pc-display-horizontal 000003'></i> <a style='color: blue' target='_blank' href='users_admin_of_computers_details.html?parameter={quote(name_user)}'> {target_count} computer{'s' if target_count > 0 else ''} </a>\"\n                    )\n\n            # add user icons\n            type_label_a = generic_formating.clean_label(row[\"Type_a\"])\n            row[\"Has SID History\"] = (\n                f\"{generic_formating.get_label_icon(type_label_a)} {row['Has SID History']}\"\n            )\n\n            type_label_b = generic_formating.clean_label(row[\"Type_b\"])\n            row[\"Target\"] = (\n                f\"{generic_formating.get_label_icon(type_label_b)} {row['Target']}\"\n            )\n\n            # add star icon\n            if target_count > origin_count:\n                row[\"Has SID History\"] = star_icon + \" \" + row[\"Has SID History\"]\n                row[\"Target\"] = star_icon + \" \" + row[\"Target\"]\n\n        grid.setheaders(headers)\n        grid.setData(self.has_sid_history)\n\n        page.addComponent(grid)\n        page.render()\n\n        self.data = len(self.has_sid_history)\n        self.name_description = f\"{len(self.has_sid_history)} objects with SID history\"\n\n    def get_rating(self) -> int:\n        return presence_of(self.has_sid_history, 2)\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/__init__.py": {
        "imported_elements": [
          "generic_formating",
          ""
        ],
        "code_map": {}
      },
      "ad_miner/sources/modules/common_analysis.py": {
        "imported_elements": [
          "presence_of"
        ],
        "code_map": {
          "presence_of": "def presence_of(req, criticity=1, threshold=0):\n    if req is None:\n        return -1\n    if len(req) > threshold:\n        return criticity\n    return 5"
        }
      },
      "/Users/steverassinot/Repos/AD_Miner/urllib/parse/__init__.py": {
        "imported_elements": [
          "quote"
        ],
        "code_map": {}
      }
    },
    "requests_keys": [
      "has_sid_history",
      "users_admin_on_computers"
    ]
  },
  {
    "title": "Privileged account outside the protected users group",
    "file_name": "privileged_accounts_outside_Protected_Users.py",
    "control_category": "Permissions",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\nfrom ad_miner.sources.modules.common_analysis import presence_of\n\n\n@register_control\nclass privileged_accounts_outside_Protected_Users(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"permissions\"\n        self.control_key = \"privileged_accounts_outside_Protected_Users\"\n\n        self.title = \"Privileged account outside the protected users group\"\n        self.description = (\n            \"Privileged accounts not protected by the Protected Users group.\"\n        )\n        self.risk = \"The Protected Users group should be used to harden authentication and encryption mechanisms for sensitive accounts.\"\n        self.poa = \"Privileged accounts must be part of the Protected Users group.\"\n\n        self.users_nb_domain_admins = requests_results[\"nb_domain_admins\"]\n\n    def run(self):\n        if self.users_nb_domain_admins is None:\n            self.users_nb_domain_admins = []\n\n        page = Page(\n            self.arguments.cache_prefix,\n            \"privileged_accounts_outside_Protected_Users\",\n            \"Priviledged accounts not part of the Protected Users group\",\n            self.get_dico_description(),\n        )\n        grid = Grid(\"Priviledged accounts not part of the Protected Users group\")\n        grid.setheaders(\n            [\n                \"domain\",\n                \"name\",\n                \"domain admin\",\n                \"schema admin\",\n                \"enterprise admin\",\n                \"key admin\",\n                \"enterprise key admin\",\n                \"builtin admin\",\n                \"protected user\",\n            ]\n        )\n\n        data = []\n\n        for dic in self.users_nb_domain_admins:\n            if \"Protected Users\" in dic[\"admin type\"]:\n                continue\n            tmp_data = {\"domain\": '<i class=\"bi bi-globe2\"></i> ' + dic[\"domain\"]}\n            tmp_data[\"name\"] = '<i class=\"bi bi-gem\"></i> ' + dic[\"name\"]\n            tmp_data[\"domain admin\"] = (\n                '<i class=\"bi bi-check-square-fill\"></i><span style=\"display:none\">True</span>'\n                if \"Domain Admin\" in dic[\"admin type\"]\n                else '<i class=\"bi bi-square\"></i>'\n            )\n            tmp_data[\"schema admin\"] = (\n                '<i class=\"bi bi-check-square-fill\"></i><span style=\"display:none\">True</span>'\n                if \"Schema Admin\" in dic[\"admin type\"]\n                else '<i class=\"bi bi-square\"></i>'\n            )\n            tmp_data[\"enterprise admin\"] = (\n                '<i class=\"bi bi-check-square-fill\"></i><span style=\"display:none\">True</span>'\n                if \"Enterprise Admin\" in dic[\"admin type\"]\n                else '<i class=\"bi bi-square\"></i>'\n            )\n            tmp_data[\"key admin\"] = (\n                '<i class=\"bi bi-check-square-fill\"></i><span style=\"display:none\">True</span>'\n                if \"_ Key Admin\" in dic[\"admin type\"]\n                else '<i class=\"bi bi-square\"></i>'\n            )\n            tmp_data[\"enterprise key admin\"] = (\n                '<i class=\"bi bi-check-square-fill\"></i><span style=\"display:none\">True</span>'\n                if \"Enterprise Key Admin\" in dic[\"admin type\"]\n                else '<i class=\"bi bi-square\"></i>'\n            )\n            tmp_data[\"builtin admin\"] = (\n                '<i class=\"bi bi-check-square-fill\"></i><span style=\"display:none\">True</span>'\n                if \"Builtin Administrator\" in dic[\"admin type\"]\n                else '<i class=\"bi bi-square\"></i>'\n            )\n            tmp_data[\"protected user\"] = (\n                '<i class=\"bi bi-x-circle\" style=\"color: rgb(255, 89, 94);\"></i> Unprotected'\n            )\n            data.append(tmp_data)\n\n        grid.setData(data)\n        page.addComponent(grid)\n        page.render()\n\n        self.data = len(\n            [\n                dic\n                for dic in self.users_nb_domain_admins\n                if \"Protected Users\" not in dic[\"admin type\"]\n            ]\n        )\n\n        # TODO define the sentence that will be displayed in the 'smolcard' view and in the center of the mainpage\n        self.name_description = (\n            f\"{self.data} priviledged accounts not in Protected Users group\"\n        )\n\n    def get_rating(self) -> int:\n        return presence_of(\n            [\n                dic\n                for dic in self.users_nb_domain_admins\n                if \"Protected Users\" not in dic[\"admin type\"]\n            ]\n        )\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "ad_miner/sources/modules/common_analysis.py": {
        "imported_elements": [
          "presence_of"
        ],
        "code_map": {
          "presence_of": "def presence_of(req, criticity=1, threshold=0):\n    if req is None:\n        return -1\n    if len(req) > threshold:\n        return criticity\n    return 5"
        }
      }
    },
    "requests_keys": [
      "nb_domain_admins"
    ]
  },
  {
    "title": "Dormant accounts",
    "file_name": "dormants_accounts.py",
    "control_category": "Misc",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\n\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\nfrom ad_miner.sources.modules.utils import days_format\nfrom ad_miner.sources.modules.common_analysis import percentage_superior\n\n\n@register_control\nclass dormants_accounts(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"misc\"\n        self.control_key = \"dormants_accounts\"\n\n        self.title = \"Dormant accounts\"\n        self.description = \"List of all users who have their accounts unused for a long period of time.\"\n        self.risk = \"As dormant accounts represent an anomaly, this list should be reduced as much as possible. Unused accounts are a vector of attack as they keep their privilege.\"\n        self.poa = (\n            \"Dormant accounts should be disabled when confirmed as not used anymore.\"\n        )\n\n        self.users = requests_results[\"nb_enabled_accounts\"]\n\n        self.users_dormant_accounts = requests_results[\"dormant_accounts\"]\n        self.users_not_connected_for_3_months = (\n            [user[\"name\"] for user in self.users_dormant_accounts if user[\"days\"] > 90]\n            if self.users_dormant_accounts is not None\n            else None\n        )\n        self.admin_list = requests_results[\"admin_list\"]\n\n    def run(self):\n        if self.users_dormant_accounts is None:\n            return\n\n        page = Page(\n            self.arguments.cache_prefix,\n            \"dormants_accounts\",\n            \"Dormant accounts\",\n            self.get_dico_description(),\n        )\n        grid = Grid(\"Dormants accounts\")\n        grid.setheaders([\"domain\", \"name\", \"last logon\", \"Account Creation Date\"])\n\n        data = []\n        for dict in self.users_dormant_accounts:\n            tmp_data = {\"domain\": '<i class=\"bi bi-globe2\"></i> ' + dict[\"domain\"]}\n\n            tmp_data[\"name\"] = (\n                (\n                    '<i class=\"bi bi-gem\" title=\"This user is domain admin\"></i> '\n                    + dict[\"name\"]\n                )\n                if dict[\"name\"] in self.admin_list\n                else '<i class=\"bi bi-person-fill\"></i> ' + dict[\"name\"]\n            )\n\n            tmp_data[\"last logon\"] = days_format(dict[\"days\"])\n            tmp_data[\"Account Creation Date\"] = days_format(dict[\"accountCreationDate\"])\n\n            data.append(tmp_data)\n\n        grid.setData(data)\n        page.addComponent(grid)\n        page.render()\n\n        self.data = (\n            len(self.users_dormant_accounts) if self.users_dormant_accounts else 0\n        )\n\n        self.name_description = f\"{self.data} dormant accounts\"\n\n    def get_rating(self) -> int:\n        return percentage_superior(\n            self.users_dormant_accounts,\n            self.users,\n            criticity=2,\n            percentage=0.5,\n            presence=True,\n        )\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "ad_miner/sources/modules/utils.py": {
        "imported_elements": [
          "days_format"
        ],
        "code_map": {
          "days_format": "def days_format(nb_days: int, critical_time=90) -> str:\n    \"\"\"\n    Returns the date in a nice format\n    \"\"\"\n\n    critical_time = int(critical_time)\n\n    sortClass = str(nb_days).zfill(6)\n    if nb_days is None:\n        return f\"<i class='{sortClass} bi bi-x-circle' style='color: rgb(255, 89, 94);'></i> Unknown\"\n    if nb_days > 19000:\n        return f\"<i class='{sortClass} bi bi-x-circle' style='color: rgb(255, 89, 94);'></i> Never\"\n    y = nb_days // 365\n    m = (nb_days % 365) // 30\n    d = (nb_days % 365) % 30\n\n    color = \"#b00404\" if nb_days > 2 * critical_time else \"#e36402\" if nb_days > critical_time else \"#0a6e01\"\n\n    if y > 0:\n        return f\"<i class='{sortClass} bi bi-calendar3' style='color: {color};'></i> {y} year{'s' if y > 1 else ''}, {m} month{'s' if m > 1 else ''} and {d} day{'s' if d > 1 else ''}\"\n    elif m > 0:\n        return f\"<i class='{sortClass} bi bi-calendar3' style='color: {color};'></i> {m} month{'s' if m > 1 else ''} and {d} day{'s' if d > 1 else ''}\"\n    else:\n        return f\"<i class='{sortClass} bi bi-calendar3' style='color: {color};'></i> {d} day{'s' if d > 1 else ''}\""
        }
      },
      "ad_miner/sources/modules/common_analysis.py": {
        "imported_elements": [
          "percentage_superior"
        ],
        "code_map": {
          "percentage_superior": "def percentage_superior(req, base, criticity=1, percentage=0, presence=False):\n    if req is None:\n        return -1\n    if base is None:\n        return -1\n    if len(base) == 0:\n        return -1\n\n    if len(base) and len(req) / len(base) > percentage:\n        return criticity\n\n    if presence:\n        if len(req) > 0:\n            return criticity + 1\n    return 5"
        }
      }
    },
    "requests_keys": [
      "admin_list",
      "dormant_accounts",
      "nb_enabled_accounts"
    ]
  },
  {
    "title": "Tier-0 violation (sessions)",
    "file_name": "dom_admin_on_non_dc.py",
    "control_category": "Permissions",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\nfrom ad_miner.sources.modules.utils import grid_data_stringify\n\nfrom ad_miner.sources.modules.common_analysis import createGraphPage, presence_of\n\nfrom urllib.parse import quote\n\n\n@register_control\nclass dom_admin_on_non_dc(Control):\n    \"Docstring of my control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"permissions\"\n        self.control_key = \"dom_admin_on_non_dc\"\n\n        self.title = \"Tier-0 violation (sessions)\"\n        self.description = \"Domain admins connected to non DC computers. If an attacker compromises any of these computers, he will instantly obtain domain administration privileges.\"\n        self.risk = \"Ideally, this page should be empty. Domain administrators connecting to computers leave credentials traces in memory, which could lead to a complete compromission of the Active Directory.\"\n        self.poa = \"If this page is not empty, modify the configuration so that no domain admins are connected to non DC computers.\"\n\n        self.users_domain_admin_on_nondc = requests_results[\"dom_admin_on_non_dc\"]\n\n    def run(self):\n        if self.users_domain_admin_on_nondc is None:\n            return\n        dico = {}\n        for path in self.users_domain_admin_on_nondc:\n            da = path.nodes[-1].name\n            if da not in dico:\n                dico[da] = {\n                    \"paths\": [],\n                    \"computers\": [],\n                    \"domains_impacted\": {},\n                    \"domain\": path.nodes[-1].domain,\n                }\n            dico[da][\"paths\"].append(path)\n            dico[da][\"computers\"].append(path.nodes[0].name)\n            dico[da][\"domains_impacted\"][path.nodes[0].domain] = 0\n\n        page = Page(\n            self.arguments.cache_prefix,\n            \"dom_admin_on_non_dc\",\n            \"Tier-0 violation (sessions)\",\n            self.get_dico_description(),\n        )\n        grid = Grid(\"Tier-0 violation (sessions)\")\n        grid.setheaders(\n            [\"Domain\", \"Domain Admin\", \"Computers\", \"Paths\", \"Domains impacted\"]\n        )\n        data = []\n        for da in dico.keys():\n            tmp = {}\n            tmp[\"Domain\"] = '<i class=\"bi bi-globe2\"></i> ' + dico[da][\"domain\"]\n            tmp[\"Domain Admin\"] = '<i class=\"bi bi-gem\"></i> ' + da\n            nb_computers = len(dico[da][\"computers\"])\n            tmp[\"Computers\"] = grid_data_stringify(\n                {\n                    \"link\": f\"dom_admin_on_non_dc_list_of_{quote(str(da.replace(' ', '_')))}.html\",\n                    \"value\": f'{nb_computers} computer{\"s\" if  nb_computers > 1 else \"\"} impacted',\n                    \"before_link\": f\"<i class='<i bi bi-pc-display-horizontal {str(nb_computers).zfill(6)}'></i> \",\n                }\n            )\n            nb_domains = len(dico[da][\"domains_impacted\"].keys())\n            tmp[\"Domains impacted\"] = grid_data_stringify(\n                {\n                    \"link\": f\"dom_admin_on_non_dc_domain_list_of_{quote(str(da.replace(' ', '_')))}.html\",\n                    \"value\": f'{nb_domains} domain{\"s\" if nb_domains > 1 else \"\"} impacted',\n                    \"before_link\": f\"<i class='<i bi bi-globe2 {str(nb_domains).zfill(6)}'></i> \",\n                }\n            )\n            nb_paths = len(dico[da][\"paths\"])\n            tmp[\"Paths\"] = grid_data_stringify(\n                {\n                    \"link\": f\"dom_admin_on_non_dc_paths_from_{quote(str(da.replace(' ', '_')))}.html\",\n                    \"value\": f'{nb_paths} path{\"s\" if  nb_paths > 1 else \"\"}',\n                    \"before_link\": f\"<i class='<i bi bi-shuffle {str(nb_paths).zfill(6)}'></i> \",\n                }\n            )\n            data.append(tmp)\n            createGraphPage(\n                self.arguments.cache_prefix,\n                f\"dom_admin_on_non_dc_paths_from_{str(da.replace(' ', '_'))}\",\n                f\"Sessions of {da} on non-DC computers\",\n                self.get_dico_description(),\n                dico[da][\"paths\"],\n                self.requests_results,\n            )\n            computer_list_page = Page(\n                self.arguments.cache_prefix,\n                f\"dom_admin_on_non_dc_list_of_{str(da.replace(' ', '_'))}\",\n                f\"Computers storing sensitive connection informations of {da}\",\n                self.get_dico_description(),\n            )\n            computer_list_grid = Grid(\n                f\"Computers storing sensitive connection informations of {da}\"\n            )\n            computer_list_grid.setheaders([\"Computer\"])\n            computer_list_data = [\n                {\"Computer\": '<i class=\"bi bi-pc-display-horizontal\"></i> ' + c}\n                for c in dico[da][\"computers\"]\n            ]\n            computer_list_grid.setData(computer_list_data)\n            computer_list_page.addComponent(computer_list_grid)\n            computer_list_page.render()\n\n            domain_list = dico[da][\"domains_impacted\"].keys()\n            domain_list_page = Page(\n                self.arguments.cache_prefix,\n                f\"dom_admin_on_non_dc_domain_list_of_{str(da.replace(' ', '_'))}\",\n                f\"Domains of computers storing sensitive connection informations of {da}\",\n                self.get_dico_description(),\n            )\n            domain_list_grid = Grid(\n                f\"Domains of computers storing sensitive connection informations of {da}\"\n            )\n            domain_list_grid.setheaders([\"Domain\"])\n            domain_list_data = [\n                {\"Domain\": '<i class=\"bi bi-globe2\"></i> ' + c} for c in domain_list\n            ]\n            domain_list_grid.setData(domain_list_data)\n            domain_list_page.addComponent(domain_list_grid)\n            domain_list_page.render()\n        grid.setData(data)\n        page.addComponent(grid)\n        page.render()\n\n        self.data = (\n            len(self.users_domain_admin_on_nondc)\n            if self.users_domain_admin_on_nondc\n            else 0\n        )\n\n        self.name_description = f\"{self.data} Tier-0 sessions on non-Tier-0 computers\"\n\n    def get_rating(self) -> int:\n        return presence_of(self.users_domain_admin_on_nondc)\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "ad_miner/sources/modules/utils.py": {
        "imported_elements": [
          "grid_data_stringify"
        ],
        "code_map": {
          "grid_data_stringify": "def grid_data_stringify(raw_data: dict) -> str:\n    \"\"\"\n    Transform a dict to a string for the grid formating. This is a dumb fix for the sorting with hyperlink.\n    dict format :\n    {\n        \"link\",\n        \"value\",\n        \"before_link\"\n    }\n    \"\"\"\n    link = raw_data['link'].replace(sep, '_').replace('/', '_')\n    try:\n        return f\"{raw_data['before_link']} <a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\"\n    except KeyError:\n        return f\"<a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\""
        }
      },
      "ad_miner/sources/modules/common_analysis.py": {
        "imported_elements": [
          "createGraphPage",
          ""
        ],
        "code_map": {
          "createGraphPage": "def createGraphPage(\n    render_prefix, page_name, page_title, page_description, graph_data, requests_results\n):\n    page = Page(render_prefix, page_name, page_title, page_description)\n    graph = Graph()\n    graph.setPaths(graph_data)\n\n    graph.addGhostComputers(requests_results[\"dico_ghost_computer\"])\n    graph.addGhostUsers(requests_results[\"dico_ghost_user\"])\n    graph.addDCComputers(requests_results[\"dico_dc_computer\"])\n    graph.addUserDA(requests_results[\"dico_user_da\"])\n    graph.addGroupDA(requests_results[\"dico_da_group\"])\n    graph.addKerberoastableUsers(requests_results[\"dico_is_kerberoastable\"])\n\n    page.addComponent(graph)\n    page.render()"
        }
      },
      "/Users/steverassinot/Repos/AD_Miner/urllib/parse/__init__.py": {
        "imported_elements": [
          "quote"
        ],
        "code_map": {}
      }
    },
    "requests_keys": [
      "dico_ghost_computer",
      "dico_da_group",
      "dom_admin_on_non_dc",
      "dico_dc_computer",
      "dico_is_kerberoastable",
      "dico_ghost_user",
      "dico_user_da"
    ]
  },
  {
    "title": "Access to LAPS passwords",
    "file_name": "can_read_laps.py",
    "control_category": "Passwords",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\n\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\n\n\n@register_control\nclass can_read_laps(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"passwords\"\n        self.control_key = \"can_read_laps\"\n\n        self.title = \"Access to LAPS passwords\"\n        self.description = \"Accounts that can read LAPS local administrator passwords.\"\n        self.risk = \"These objects can read LAPS local administrator passwords. Objects with rights to read LAPS passwords are a potential threat as they can read the password of the local administrator account.\"\n        self.poa = (\n            \"Review the accounts and make sure that their privileges are legitimate.\"\n        )\n\n        self.can_read_laps = requests_results[\"can_read_laps\"]\n        self.users_nb_domain_admins = requests_results[\"nb_domain_admins\"]\n\n    def run(self):\n        if self.can_read_laps is None:\n            return\n        page = Page(\n            self.arguments.cache_prefix,\n            \"can_read_laps\",\n            \"Objects able to read LAPS password\",\n            self.get_dico_description(),\n        )\n        grid = Grid(\"Objects able to LAPS passwords\")\n        grid.setheaders([\"domain\", \"name\"])\n        self.can_read_laps_parsed = [\n            {\n                \"domain\": '<i class=\"bi bi-globe2\"></i> ' + user[\"domain\"],\n                \"name\": '<i class=\"bi bi-person-fill\"></i> ' + user[\"name\"],\n            }\n            for user in self.can_read_laps\n            if user[\"domain\"] is not None and user[\"name\"] is not None\n        ]\n        grid.setData(self.can_read_laps_parsed)\n        page.addComponent(grid)\n        page.render()\n\n        self.data = len(self.can_read_laps_parsed)\n\n        self.name_description = (\n            f\"{len(self.can_read_laps_parsed)} accounts can read LAPS passwords\"\n        )\n\n    def get_rating(self) -> int:\n        return (\n            2\n            if len(self.can_read_laps_parsed) > len(self.users_nb_domain_admins)\n            else 5\n        )\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      }
    },
    "requests_keys": [
      "nb_domain_admins",
      "can_read_laps"
    ]
  },
  {
    "title": "Objects can read GMSA passwords of administrators",
    "file_name": "can_read_gmsapassword_of_adm.py",
    "control_category": "Passwords",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\n\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\nfrom ad_miner.sources.modules.graph_class import Graph\nfrom ad_miner.sources.modules.utils import grid_data_stringify\nfrom ad_miner.sources.modules.common_analysis import presence_of\n\nfrom urllib.parse import quote\n\n\n@register_control\nclass can_read_gmsapassword_of_adm(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n\n        self.category = \"passwords\"\n\n        self.control_key = \"can_read_gmsapassword_of_adm\"\n\n        self.title = \"Objects can read GMSA passwords of administrators\"\n        self.description = \"GMSA stands for Group Managed Service Account. GMSAs are a special type of service account that are designed to provide improved security and manageability for service applications. GMSAs have their own passwords that are managed by the Active Directory and automatically rotated, making them more secure than traditional service accounts.\"\n        self.risk = \"Being able to read GMSA passwords means that accounts can be fully compromised.\"\n        self.poa = \"Review these rights to ensure they are legitimate and useful.\"\n\n        self.can_read_gmsapassword_of_adm = requests_results[\n            \"can_read_gmsapassword_of_adm\"\n        ]\n\n    def run(self):\n        if self.can_read_gmsapassword_of_adm is None:\n            return\n        # page = Page(\n        #     self.arguments.cache_prefix,\n        #     \"can_read_gmsapassword_of_adm\",\n        #     \"Objects allowed to read the GMSA of objects with admincount=True\",\n        #     \"can_read_gmsapassword_of_adm\",\n        # )\n        # grid = Grid(\"Number of accounts or groups with unexpected SID history\")\n        # grid.setheaders([\"domain\", \"object_allowed\", \"object_targeted\"])\n        # grid.setData(self.can_read_gmsapassword_of_adm)\n        # page.addComponent(grid)\n        # page.render()\n        page = Page(\n            self.arguments.cache_prefix,\n            \"can_read_gmsapassword_of_adm\",\n            \"List of non-privileged users that can read GMSAPassword on privileged accounts\",\n            self.get_dico_description(),\n        )\n        # Build raw data from requests\n        data = {}\n        for path in self.can_read_gmsapassword_of_adm:\n            try:\n                data[path.nodes[0]][\"paths\"].append(path)\n                if path.nodes[-1].name not in data[path.nodes[0]][\"target\"]:\n                    data[path.nodes[0]][\"target\"].append(path.nodes[-1].name)\n            except KeyError:\n                data[path.nodes[0]] = {\n                    \"domain\": path.nodes[0].domain,\n                    \"name\": path.nodes[0].name,\n                    \"target\": [path.nodes[-1].name],\n                    \"paths\": [path],\n                }\n\n        # Build grid data\n        grid_data = []\n        for d in data.values():\n            sortClass = str(len(d[\"paths\"])).zfill(6)\n            tmp_grid_data = {\n                \"domain\": '<i class=\"bi bi-globe2\"></i> ' + d[\"domain\"],\n                \"name\": '<i class=\"bi bi-person-fill\"></i> ' + d[\"name\"],\n                \"target\": grid_data_stringify(\n                    {\n                        \"value\": f\"{len(d['paths'])} paths to {len(d['target'])} target{'s' if len(d['target'])>1 else ''}\",\n                        \"link\": f\"can_read_gmsapassword_of_adm_from_{quote(str(d['name']))}.html\",\n                        \"before_link\": f\"<i class='{sortClass} bi bi-shuffle' aria-hidden='true'></i>\",\n                    }\n                ),\n            }\n            grid_data.append(tmp_grid_data)\n            # Build graph data\n            page_graph = Page(\n                self.arguments.cache_prefix,\n                f\"can_read_gmsapassword_of_adm_from_{d['name']}\",\n                f\"{d['name']} can read GMSA Password attack paths on privileged accounts\",\n                \"can_read_gmsapassword_of_adm\",\n            )\n            graph = Graph()\n            graph.setPaths(d[\"paths\"])\n            page_graph.addComponent(graph)\n            page_graph.render()\n\n        self.can_read_gmsapassword_of_adm = data.keys()\n        grid = Grid(\"Users that can read GMSA Password\")\n        grid.setheaders([\"domain\", \"name\", \"target\"])\n        grid.setData(grid_data)\n        page.addComponent(grid)\n        page.render()\n\n        # TODO define the metric of your control\n        # it will be stored in the data json\n        self.data = (\n            len(self.can_read_gmsapassword_of_adm)\n            if self.can_read_gmsapassword_of_adm\n            else 0\n        )\n\n        # TODO define the sentence that will be displayed in the 'smolcard' view and in the center of the mainpage\n        self.name_description = f\"{len(self.can_read_gmsapassword_of_adm)} can read GMSA passwords of Administrators\"\n\n    def get_rating(self) -> int:\n        return presence_of(self.can_read_gmsapassword_of_adm)\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "ad_miner/sources/modules/graph_class.py": {
        "imported_elements": [
          "Graph"
        ],
        "code_map": {
          "Graph": "class Graph:\n    def __init__(self, template=\"graph\", path_limit=80000):\n        self.template_base_path = HTML_DIRECTORY / \"components/graph/\"\n        self.template = template\n        self.paths = []\n        self.nodes = {}\n        self.relations = []\n        self.relations_hashes = {}\n        self.path_limit = path_limit\n        self.ghost_computer = {}\n        self.ghost_user = {}\n        self.dc_computer = {}\n        self.user_da = {}\n        self.group_da = {}\n        self.enabled_users = {}\n        self.kerberoastable_users = {}\n        self.disabled_users_dict = {}\n\n    def addPath(self, path):\n        self.paths.append(path)\n\n    def setPaths(self, paths):\n        self.paths = paths\n\n    def addGhostComputers(self, ghost_computer):\n        self.ghost_computer = ghost_computer\n\n    def addGhostUsers(self, ghost_user):\n        self.ghost_user = ghost_user\n\n    def addDCComputers(self, dc_computer):\n        self.dc_computer = dc_computer\n\n    def addUserDA(self, user_da):\n        self.user_da = user_da\n\n    def addGroupDA(self, group_da):\n        self.group_da = group_da\n\n    def addDisabledUsers(self, disabled_users):\n        self.disabled_users_dict = {}\n        for d in disabled_users:\n            self.disabled_users_dict[d[\"name\"]] = True\n\n    def addKerberoastableUsers(self, kerberoastable_users):\n        self.kerberoastable_users = kerberoastable_users\n\n    def render(self, page_f):\n\n        # Write header\n        with open(\n            self.template_base_path / (self.template + \"_header.html\"), \"r\"\n        ) as header_f:\n            html_header = header_f.read()\n            page_f.write(html_header)\n\n        for index, path in enumerate(self.paths):\n            for i in range(len(path.nodes)):\n\n                node = path.nodes[i]\n\n                # Compute node style\n                if i == 0:\n                    node_position = \"start\"\n                elif i == len(path.nodes) - 1:\n                    node_position = \"end\"\n                else:\n                    node_position = \"intermediate\"\n\n                # Add new labels here. A corresponding svg icon should be defined\n                # dico_icon in the icon.js file.\n                list_labels = [\n                    \"User\",\n                    \"Foreignsecurityprincipal\",\n                    \"GPO\",\n                    \"Computer\",\n                    \"OU\",\n                    \"Group\",\n                    \"Domain\",\n                    \"ADLocalGroup\",\n                    \"Container\",\n                    \"Unknown\",\n                    \"Group_cluster\",\n                    \"Device\",\n                    \"AZTenant\",\n                    \"AZRole\",\n                ]\n\n                if node.labels in list_labels:\n                    label_instance = node.labels\n                elif path.nodes[i].labels[2:] in list_labels:\n                    label_instance = node.labels[2:]\n                else:\n                    label_instance = \"Unknown\"\n\n                node_attributes = []\n\n                # Add DA icon if node is DC, DA or Domain\n                if (\n                    (\n                        label_instance == \"Computer\"\n                        and self.dc_computer.get(node.name, False)\n                    )\n                    or (label_instance == \"User\" and self.user_da.get(node.name, False))\n                    or (\n                        label_instance == \"Group\"\n                        and self.group_da.get(node.name, False)\n                    )\n                    or label_instance == \"Domain\"\n                ):\n                    node_attributes.append(\"da\")\n\n                # Add ghost icon if ghost\n                if (\n                    label_instance == \"User\" and self.ghost_user.get(node.name, False)\n                ) or (\n                    label_instance == \"Computer\"\n                    and self.ghost_computer.get(node.name, False)\n                ):\n                    node_attributes.append(\"ghost\")\n\n                if label_instance == \"User\" and self.disabled_users_dict.get(\n                    node.name, False\n                ):\n                    node_attributes.append(\"disabled\")\n\n                if label_instance == \"User\" and self.kerberoastable_users.get(\n                    node.name, False\n                ):\n                    node_attributes.append(\"kerberoastable\")\n\n                # New nodes attributes that should be added to the node icon\n                # should be added here to the node_attributes list.\n                # A corresponding svg icon should the be added to the\n                # dico_icon in icon.js\n\n                if not self.nodes.get(path.nodes[i].id):\n\n                    final_graph_node = {\n                        \"id\": path.nodes[i].id,\n                        \"label\": path.nodes[i].name,\n                        \"domain\": path.nodes[i].domain,\n                        \"shape\": \"image\",\n                        \"instance\": label_instance,\n                        \"position\": node_position,\n                        \"attributes\": node_attributes,\n                    }\n                    self.nodes[path.nodes[i].id] = final_graph_node\n\n                if i != 0:\n                    relation = {\n                        \"from\": path.nodes[i - 1].id,\n                        \"to\": path.nodes[i].id,\n                        \"label\": path.nodes[i - 1].relation_type,\n                    }\n\n                    # Avoid relation duplicated to keep graph clean\n                    # Use hashes list for better performance\n                    hash_rel = hash(\n                        str(relation[\"from\"])\n                        + str(relation[\"to\"])\n                        + str(relation[\"label\"])\n                    )\n                    if not self.relations_hashes.get(hash_rel):\n                        self.relations.append(relation)\n                        self.relations_hashes[hash_rel] = True\n\n        nodes = list(self.nodes.values())\n        for n in nodes:  # Sanitize None values (otherwise it creates a bug in JS)\n            if n[\"label\"] == None:\n                n[\"label\"] = \"???\"\n        page_f.write(f'<script type=\"text/javascript\">window.data_nodes = {nodes};\\n')\n        page_f.write(f\"window.data_edges = {self.relations};</script>\\n\")"
        }
      },
      "ad_miner/sources/modules/utils.py": {
        "imported_elements": [
          "grid_data_stringify"
        ],
        "code_map": {
          "grid_data_stringify": "def grid_data_stringify(raw_data: dict) -> str:\n    \"\"\"\n    Transform a dict to a string for the grid formating. This is a dumb fix for the sorting with hyperlink.\n    dict format :\n    {\n        \"link\",\n        \"value\",\n        \"before_link\"\n    }\n    \"\"\"\n    link = raw_data['link'].replace(sep, '_').replace('/', '_')\n    try:\n        return f\"{raw_data['before_link']} <a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\"\n    except KeyError:\n        return f\"<a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\""
        }
      },
      "ad_miner/sources/modules/common_analysis.py": {
        "imported_elements": [
          "presence_of"
        ],
        "code_map": {
          "presence_of": "def presence_of(req, criticity=1, threshold=0):\n    if req is None:\n        return -1\n    if len(req) > threshold:\n        return criticity\n    return 5"
        }
      },
      "/Users/steverassinot/Repos/AD_Miner/urllib/parse/__init__.py": {
        "imported_elements": [
          "quote"
        ],
        "code_map": {}
      }
    },
    "requests_keys": [
      "can_read_gmsapassword_of_adm"
    ]
  },
  {
    "title": "Shadow credentials on domain controllers",
    "file_name": "dc_impersonation.py",
    "control_category": "Misc",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\n\nfrom ad_miner.sources.modules.common_analysis import createGraphPage, presence_of\n\n\n@register_control\nclass dc_impersonation(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"misc\"\n        self.control_key = \"dc_impersonation\"\n\n        self.title = \"Shadow credentials on domain controllers\"\n        self.description = \"Non-domain admins that can directly or indirectly impersonate a Domain Controller\"\n        self.risk = \"The ability to impersonate the machine account of a domain controller allows to perform very powerful attacks such as DCSync. The accounts listed here are not member of domain admin groups but can still impersonate domain controllers, effectively giving them the privileges to dump all the data of Active Directory (including all users password hashes). If any of these accounts is compromised, then the domain it is attached to is can be considered compromised as well.\"\n        self.poa = \"Review the accounts to check if this privilege is legitimate. If not, remove it.\"\n\n        self.users_dc_impersonation = requests_results[\"dc_impersonation\"]\n        if self.users_dc_impersonation != None:\n            self.users_dc_impersonation_count = len(self.users_dc_impersonation)\n        else:\n            self.users_dc_impersonation_count = 0\n\n    def run(self):\n\n        createGraphPage(\n            self.arguments.cache_prefix,\n            \"dc_impersonation\",\n            \"Shadow credentials on domain controllers\",\n            self.get_dico_description(),\n            self.users_dc_impersonation,\n            requests_results=self.requests_results,\n        )\n        self.data = (\n            self.users_dc_impersonation_count\n            if self.users_dc_impersonation_count\n            else 0\n        )\n\n        self.name_description = f\"{self.data} paths to impersonate DCs\"\n\n    def get_rating(self) -> int:\n        return presence_of(self.users_dc_impersonation)\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/common_analysis.py": {
        "imported_elements": [
          "createGraphPage",
          ""
        ],
        "code_map": {
          "createGraphPage": "def createGraphPage(\n    render_prefix, page_name, page_title, page_description, graph_data, requests_results\n):\n    page = Page(render_prefix, page_name, page_title, page_description)\n    graph = Graph()\n    graph.setPaths(graph_data)\n\n    graph.addGhostComputers(requests_results[\"dico_ghost_computer\"])\n    graph.addGhostUsers(requests_results[\"dico_ghost_user\"])\n    graph.addDCComputers(requests_results[\"dico_dc_computer\"])\n    graph.addUserDA(requests_results[\"dico_user_da\"])\n    graph.addGroupDA(requests_results[\"dico_da_group\"])\n    graph.addKerberoastableUsers(requests_results[\"dico_is_kerberoastable\"])\n\n    page.addComponent(graph)\n    page.render()"
        }
      }
    },
    "requests_keys": [
      "dico_ghost_computer",
      "dico_da_group",
      "dico_dc_computer",
      "dico_is_kerberoastable",
      "dico_ghost_user",
      "dc_impersonation",
      "dico_user_da"
    ]
  },
  {
    "title": "Old KRBTGT password",
    "file_name": "krb_last_change.py",
    "control_category": "Kerberos",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\n\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\nfrom ad_miner.sources.modules.utils import days_format\nfrom ad_miner.sources.modules.common_analysis import time_since\n\n\n@register_control\nclass krb_last_change(Control):  # TODO change the class name\n    \"Docstring of my control\"  # TODO small documentation here\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"kerberos\"\n        self.control_key = \"krb_last_change\"\n\n        self.title = \"Old KRBTGT password\"\n        self.description = \"Last change of password for KRBTGT account.\"\n        self.risk = \"The more regularly these passwords are changed, the better. If KRBTGT account is compromised, the whole infrastructure is as well.\"\n        self.poa = \"Check that KRBTGT accounts had their passwords changed recently.\"\n\n        self.users_krb_pwd_last_set = requests_results[\"krb_pwd_last_change\"]\n\n    def run(self):\n        if self.users_krb_pwd_last_set is None:\n            return\n        page = Page(\n            self.arguments.cache_prefix,\n            \"krb_last_change\",\n            \"KRBTGT account\",\n            self.get_dico_description(),\n        )\n        grid = Grid(\"KRBTGT account\")\n        grid.setheaders(\n            [\"domain\", \"name\", \"Last password change\", \"Account Creation Date\"]\n        )\n\n        data = []\n        for dict in self.users_krb_pwd_last_set:\n            tmp_data = {\"domain\": '<i class=\"bi bi-globe2\"></i> ' + dict[\"domain\"]}\n            tmp_data[\"name\"] = (\n                '<i class=\"bi bi-ticket-perforated-fill\"></i> ' + dict[\"name\"]\n            )\n            tmp_data[\"Last password change\"] = days_format(dict[\"pass_last_change\"])\n            tmp_data[\"Account Creation Date\"] = days_format(dict[\"accountCreationDate\"])\n            data.append(tmp_data)\n\n        grid.setData(data)\n        page.addComponent(grid)\n        page.render()\n\n        self.data = max(\n            [dict[\"pass_last_change\"] for dict in self.users_krb_pwd_last_set],\n            default=0,\n        )\n\n        self.name_description = f\"krbtgt not updated in > {self.data} days\"\n\n    def get_rating(self) -> int:\n        return time_since(\n            max(\n                [dict[\"pass_last_change\"] for dict in self.users_krb_pwd_last_set],\n                default=None,\n            ),\n            age=1 * 365,\n            criticity=2,\n        )\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "ad_miner/sources/modules/utils.py": {
        "imported_elements": [
          "days_format"
        ],
        "code_map": {
          "days_format": "def days_format(nb_days: int, critical_time=90) -> str:\n    \"\"\"\n    Returns the date in a nice format\n    \"\"\"\n\n    critical_time = int(critical_time)\n\n    sortClass = str(nb_days).zfill(6)\n    if nb_days is None:\n        return f\"<i class='{sortClass} bi bi-x-circle' style='color: rgb(255, 89, 94);'></i> Unknown\"\n    if nb_days > 19000:\n        return f\"<i class='{sortClass} bi bi-x-circle' style='color: rgb(255, 89, 94);'></i> Never\"\n    y = nb_days // 365\n    m = (nb_days % 365) // 30\n    d = (nb_days % 365) % 30\n\n    color = \"#b00404\" if nb_days > 2 * critical_time else \"#e36402\" if nb_days > critical_time else \"#0a6e01\"\n\n    if y > 0:\n        return f\"<i class='{sortClass} bi bi-calendar3' style='color: {color};'></i> {y} year{'s' if y > 1 else ''}, {m} month{'s' if m > 1 else ''} and {d} day{'s' if d > 1 else ''}\"\n    elif m > 0:\n        return f\"<i class='{sortClass} bi bi-calendar3' style='color: {color};'></i> {m} month{'s' if m > 1 else ''} and {d} day{'s' if d > 1 else ''}\"\n    else:\n        return f\"<i class='{sortClass} bi bi-calendar3' style='color: {color};'></i> {d} day{'s' if d > 1 else ''}\""
        }
      },
      "ad_miner/sources/modules/common_analysis.py": {
        "imported_elements": [
          "time_since"
        ],
        "code_map": {
          "time_since": "def time_since(req, age=90, criticity=1):  # req as days\n    if req is None:\n        return -1\n    if req > age:\n        return criticity\n\n    return 5"
        }
      }
    },
    "requests_keys": [
      "krb_pwd_last_change"
    ]
  },
  {
    "title": "Cross-domain paths to Domain Admin",
    "file_name": "da_to_da.py",
    "control_category": "Permissions",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\nfrom ad_miner.sources.modules.graph_class import Graph\nfrom ad_miner.sources.modules.utils import grid_data_stringify\nfrom ad_miner.sources.modules.common_analysis import presence_of\n\nfrom urllib.parse import quote\n\n\n@register_control\nclass da_to_da(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"permissions\"\n        self.control_key = \"da_to_da\"\n\n        self.title = \"Cross-domain paths to Domain Admin\"\n        self.description = \"From a domain admin group of a given domain, it shows the paths the domain admin groups of every other domains.\"\n        self.risk = \"If a path exists between two domains, it means that if the first domain is fully compromised, the second one can quickly be compromised as well. A malicious entity could use these paths to rapidly compromise all domains.\"\n        self.poa = \"Review the paths of compromission between domains and remove links if possible.\"\n\n        self.da_to_da = requests_results[\"da_to_da\"]\n        self.collected_domains = requests_results[\"nb_domain_collected\"]\n\n        self.crossDomain = 0\n\n    def run(self):\n        # get the result of the cypher request (a list of Path objects)\n        paths = self.da_to_da\n        # create the page\n        page = Page(\n            self.arguments.cache_prefix,\n            \"da_to_da\",\n            \"Cross-domain paths to Domain Admin\",\n            self.get_dico_description(),\n        )\n        # create the grid\n        grid = Grid(\"Cross-domain paths to Domain Admin\")\n        # create the headers (domains)\n        headers = []\n        # future list of dicts\n        pathLengthss = []\n        graphDatas = {}\n        if paths == None:\n            grid.setheaders([\"FROM / TO\"])\n            grid.setData([])\n            return\n        # for each path\n        for domain in self.collected_domains:\n            domain = domain[0]\n            headers.append(domain)\n            graphDatas[domain] = {}\n            pathLengthss.append(\n                {\"FROM / TO\": '<i class=\"bi bi-globe2\"></i> ' + domain, domain: \"-\"}\n            )\n        for path in paths:\n            # headers and pathLengths share the same index and it is cheaper to use headers here\n            try:\n                rowIndex = headers.index(path.nodes[0].name.split(\"@\")[1])\n            except ValueError:\n                # Dirty fix in case there is a domain missing\n                unknown_domain = path.nodes[0].name.split(\"@\")[1]\n                headers.append(unknown_domain)\n                graphDatas[unknown_domain] = {}\n                pathLengthss.append(\n                    {\n                        \"FROM / TO\": '<i class=\"bi bi-globe2\"></i> ' + unknown_domain,\n                        unknown_domain: \"-\",\n                    }\n                )\n                rowIndex = headers.index(unknown_domain)\n\n            # change value of the cell\n            try:\n                pathLengthss[rowIndex][path.nodes[-1].name.split(\"@\")[1]] = {\n                    \"value\": pathLengthss[rowIndex][path.nodes[-1].name.split(\"@\")[1]][\n                        \"value\"\n                    ]\n                    + 1,\n                    \"link\": quote(\n                        path.nodes[0].name.split(\"@\")[1]\n                        + \"_to_\"\n                        + path.nodes[-1].name.split(\"@\")[1]\n                    )\n                    + \".html\",\n                }\n            except KeyError:\n                pathLengthss[rowIndex][path.nodes[-1].name.split(\"@\")[1]] = {\n                    \"value\": 1,\n                    \"link\": quote(\n                        path.nodes[0].name.split(\"@\")[1]\n                        + \"_to_\"\n                        + path.nodes[-1].name.split(\"@\")[1]\n                    )\n                    + \".html\",\n                }\n\n            # add a path to the list\n            try:\n                graphDatas[path.nodes[0].name.split(\"@\")[1]][\n                    path.nodes[-1].name.split(\"@\")[1]\n                ].append(path)\n            except KeyError:\n                graphDatas[path.nodes[0].name.split(\"@\")[1]][\n                    path.nodes[-1].name.split(\"@\")[1]\n                ] = [path]\n\n        # fill the grid\n        headers.insert(0, \"FROM / TO\")\n\n        # Add some nice touch to the grid ;)\n        for row in pathLengthss:\n            # Add some text and icon to cells with links\n            for key in row.keys():\n                if key == \"FROM / TO\":\n                    continue\n                if row[key] == \"-\":\n                    continue\n                else:\n                    sortClass = str(row[key][\"value\"]).zfill(6)\n                    row[key][\n                        \"value\"\n                    ] = f\"{row[key]['value']} path{'s' if row[key]['value'] > 1 else ''}\"\n                    row[key][\n                        \"before_link\"\n                    ] = f\"<i class='bi bi-shuffle {sortClass}' aria-hidden='true'></i>\"\n                    row[key] = grid_data_stringify(row[key])\n            # Add some text to empty cells\n            for header in headers:\n                if header not in row.keys():\n                    row[header] = \"-\"\n\n        grid.setheaders(headers)\n        grid.setData(pathLengthss)\n\n        # create pages and graphs for each link\n        for inputDomain, outputDomains in graphDatas.items():\n            alreadySeenOutputDomains = []\n            for outputDomain, paths in outputDomains.items():\n                intGraph = Graph()\n                # add each path to the graph\n                for path in paths:\n                    if not (outputDomain in alreadySeenOutputDomains):\n                        # found a new domain reachable by the given input domain\n                        self.crossDomain += 1\n                        # each output domain is added once seen and the list is reset for each new input domain\n                        alreadySeenOutputDomains.append(outputDomain)\n                    intGraph.addPath(path)\n                intPage = Page(\n                    self.arguments.cache_prefix,\n                    inputDomain + \"_to_\" + outputDomain,\n                    \"Paths through Domain Admins between \"\n                    + inputDomain\n                    + \" and \"\n                    + outputDomain,\n                    self.get_dico_description(),\n                )\n                intPage.addComponent(intGraph)\n                intPage.render()\n\n        page.addComponent(grid)\n        page.render()\n\n        self.data = self.crossDomain\n        self.name_description = f\"{self.crossDomain} cross-domain paths to Domain Admin\"\n\n    def get_rating(self) -> int:\n        return presence_of(self.da_to_da)\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "ad_miner/sources/modules/graph_class.py": {
        "imported_elements": [
          "Graph"
        ],
        "code_map": {
          "Graph": "class Graph:\n    def __init__(self, template=\"graph\", path_limit=80000):\n        self.template_base_path = HTML_DIRECTORY / \"components/graph/\"\n        self.template = template\n        self.paths = []\n        self.nodes = {}\n        self.relations = []\n        self.relations_hashes = {}\n        self.path_limit = path_limit\n        self.ghost_computer = {}\n        self.ghost_user = {}\n        self.dc_computer = {}\n        self.user_da = {}\n        self.group_da = {}\n        self.enabled_users = {}\n        self.kerberoastable_users = {}\n        self.disabled_users_dict = {}\n\n    def addPath(self, path):\n        self.paths.append(path)\n\n    def setPaths(self, paths):\n        self.paths = paths\n\n    def addGhostComputers(self, ghost_computer):\n        self.ghost_computer = ghost_computer\n\n    def addGhostUsers(self, ghost_user):\n        self.ghost_user = ghost_user\n\n    def addDCComputers(self, dc_computer):\n        self.dc_computer = dc_computer\n\n    def addUserDA(self, user_da):\n        self.user_da = user_da\n\n    def addGroupDA(self, group_da):\n        self.group_da = group_da\n\n    def addDisabledUsers(self, disabled_users):\n        self.disabled_users_dict = {}\n        for d in disabled_users:\n            self.disabled_users_dict[d[\"name\"]] = True\n\n    def addKerberoastableUsers(self, kerberoastable_users):\n        self.kerberoastable_users = kerberoastable_users\n\n    def render(self, page_f):\n\n        # Write header\n        with open(\n            self.template_base_path / (self.template + \"_header.html\"), \"r\"\n        ) as header_f:\n            html_header = header_f.read()\n            page_f.write(html_header)\n\n        for index, path in enumerate(self.paths):\n            for i in range(len(path.nodes)):\n\n                node = path.nodes[i]\n\n                # Compute node style\n                if i == 0:\n                    node_position = \"start\"\n                elif i == len(path.nodes) - 1:\n                    node_position = \"end\"\n                else:\n                    node_position = \"intermediate\"\n\n                # Add new labels here. A corresponding svg icon should be defined\n                # dico_icon in the icon.js file.\n                list_labels = [\n                    \"User\",\n                    \"Foreignsecurityprincipal\",\n                    \"GPO\",\n                    \"Computer\",\n                    \"OU\",\n                    \"Group\",\n                    \"Domain\",\n                    \"ADLocalGroup\",\n                    \"Container\",\n                    \"Unknown\",\n                    \"Group_cluster\",\n                    \"Device\",\n                    \"AZTenant\",\n                    \"AZRole\",\n                ]\n\n                if node.labels in list_labels:\n                    label_instance = node.labels\n                elif path.nodes[i].labels[2:] in list_labels:\n                    label_instance = node.labels[2:]\n                else:\n                    label_instance = \"Unknown\"\n\n                node_attributes = []\n\n                # Add DA icon if node is DC, DA or Domain\n                if (\n                    (\n                        label_instance == \"Computer\"\n                        and self.dc_computer.get(node.name, False)\n                    )\n                    or (label_instance == \"User\" and self.user_da.get(node.name, False))\n                    or (\n                        label_instance == \"Group\"\n                        and self.group_da.get(node.name, False)\n                    )\n                    or label_instance == \"Domain\"\n                ):\n                    node_attributes.append(\"da\")\n\n                # Add ghost icon if ghost\n                if (\n                    label_instance == \"User\" and self.ghost_user.get(node.name, False)\n                ) or (\n                    label_instance == \"Computer\"\n                    and self.ghost_computer.get(node.name, False)\n                ):\n                    node_attributes.append(\"ghost\")\n\n                if label_instance == \"User\" and self.disabled_users_dict.get(\n                    node.name, False\n                ):\n                    node_attributes.append(\"disabled\")\n\n                if label_instance == \"User\" and self.kerberoastable_users.get(\n                    node.name, False\n                ):\n                    node_attributes.append(\"kerberoastable\")\n\n                # New nodes attributes that should be added to the node icon\n                # should be added here to the node_attributes list.\n                # A corresponding svg icon should the be added to the\n                # dico_icon in icon.js\n\n                if not self.nodes.get(path.nodes[i].id):\n\n                    final_graph_node = {\n                        \"id\": path.nodes[i].id,\n                        \"label\": path.nodes[i].name,\n                        \"domain\": path.nodes[i].domain,\n                        \"shape\": \"image\",\n                        \"instance\": label_instance,\n                        \"position\": node_position,\n                        \"attributes\": node_attributes,\n                    }\n                    self.nodes[path.nodes[i].id] = final_graph_node\n\n                if i != 0:\n                    relation = {\n                        \"from\": path.nodes[i - 1].id,\n                        \"to\": path.nodes[i].id,\n                        \"label\": path.nodes[i - 1].relation_type,\n                    }\n\n                    # Avoid relation duplicated to keep graph clean\n                    # Use hashes list for better performance\n                    hash_rel = hash(\n                        str(relation[\"from\"])\n                        + str(relation[\"to\"])\n                        + str(relation[\"label\"])\n                    )\n                    if not self.relations_hashes.get(hash_rel):\n                        self.relations.append(relation)\n                        self.relations_hashes[hash_rel] = True\n\n        nodes = list(self.nodes.values())\n        for n in nodes:  # Sanitize None values (otherwise it creates a bug in JS)\n            if n[\"label\"] == None:\n                n[\"label\"] = \"???\"\n        page_f.write(f'<script type=\"text/javascript\">window.data_nodes = {nodes};\\n')\n        page_f.write(f\"window.data_edges = {self.relations};</script>\\n\")"
        }
      },
      "ad_miner/sources/modules/utils.py": {
        "imported_elements": [
          "grid_data_stringify"
        ],
        "code_map": {
          "grid_data_stringify": "def grid_data_stringify(raw_data: dict) -> str:\n    \"\"\"\n    Transform a dict to a string for the grid formating. This is a dumb fix for the sorting with hyperlink.\n    dict format :\n    {\n        \"link\",\n        \"value\",\n        \"before_link\"\n    }\n    \"\"\"\n    link = raw_data['link'].replace(sep, '_').replace('/', '_')\n    try:\n        return f\"{raw_data['before_link']} <a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\"\n    except KeyError:\n        return f\"<a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\""
        }
      },
      "ad_miner/sources/modules/common_analysis.py": {
        "imported_elements": [
          "presence_of"
        ],
        "code_map": {
          "presence_of": "def presence_of(req, criticity=1, threshold=0):\n    if req is None:\n        return -1\n    if len(req) > threshold:\n        return criticity\n    return 5"
        }
      },
      "/Users/steverassinot/Repos/AD_Miner/urllib/parse/__init__.py": {
        "imported_elements": [
          "quote"
        ],
        "code_map": {}
      }
    },
    "requests_keys": [
      "nb_domain_collected",
      "da_to_da"
    ]
  },
  {
    "title": "Functional level of the domain",
    "file_name": "vuln_functional_level.py",
    "control_category": "Misc",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\n\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\n\n\n@register_control\nclass vuln_functional_level(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"misc\"\n        self.control_key = \"vuln_functional_level\"\n\n        self.title = \"Functional level of the domain\"\n        self.description = \"The functional level of an Active Directory domain refers to the level of compatibility and functionality that the domain supports. It determines which features and capabilities are available for the domain controllers within that domain.\"\n        self.risk = \"Using a low functional level in Active Directory can present security risks, primarily because older functional levels may lack certain security features and improvements that have been introduced in newer versions of Windows Server.\"\n        self.poa = \"To mitigate these security risks, it's generally advisable to raise the functional level of your Active Directory domains to a level that corresponds to the version of Windows Server you are running, or at least to a reasonably recent level that provides essential security features.\"\n\n        self.vuln_functional_level = requests_results[\"vuln_functional_level\"]\n\n    def run(self):\n        if self.vuln_functional_level is None:\n            return\n        page = Page(\n            self.arguments.cache_prefix,\n            \"vuln_functional_level\",\n            \"Number of insufficient forest and domains functional levels\",\n            self.get_dico_description(),\n        )\n        grid = Grid(\"Number of insufficient forest and domains functional levels\")\n        final_data = []\n        for dico in self.vuln_functional_level:\n            d = dico.copy()\n            if d[\"Level maturity\"] is None:\n                continue\n            elif d[\"Level maturity\"] <= 1:\n                color = \"red\"\n            elif d[\"Level maturity\"] <= 3:\n                color = \"orange\"\n            else:\n                color = \"green\"\n            d[\n                \"Level maturity\"\n            ] = f'<i class=\"bi bi-star-fill\" style=\"color: {color}\"></i>' * d[\n                \"Level maturity\"\n            ] + f'<i class=\"bi bi-star\" style=\"color: {color}\"></i>' * (\n                5 - d[\"Level maturity\"]\n            )\n            final_data.append(d)\n        grid.setheaders([\"Level maturity\", \"Full name\", \"Functional level\"])\n        grid.setData(final_data)\n        page.addComponent(grid)\n        page.render()\n\n        self.data = len(self.vuln_functional_level) if self.vuln_functional_level else 0\n\n        self.name_description = (\n            f\"{self.data} insufficient forest and domains functional levels\"\n        )\n\n    def get_rating(self) -> int:\n        req = self.vuln_functional_level\n        if req != None and req != []:\n            return min([ret[\"Level maturity\"] for ret in req])  # TODO\n        else:\n            return -1\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      }
    },
    "requests_keys": [
      "vuln_functional_level"
    ]
  },
  {
    "title": "Inadequate number of domain admins",
    "file_name": "nb_domain_admins.py",
    "control_category": "Permissions",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\n\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\n\nfrom ad_miner.sources.modules.common_analysis import presence_of\n\n\n@register_control\nclass nb_domain_admins(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"permissions\"\n        self.control_key = \"nb_domain_admins\"\n\n        self.title = \"Inadequate number of domain admins\"\n        self.description = \"These accounts are the most privileged and have unlimited access to the AD infrastructure.\"\n        self.risk = \"Domain admin accounts have unlimited access over the Active Directory infrastructure. Compromise of a domain account will provide attackers full access over the infrastructure. Such privileges should be stricly provided on a need-to-know basis.\"\n        self.poa = \"Make sure that domain admins shown here effectively need this level of privileges. Also, make sure that these accounts are used solely for activities that require domain administration (i.e., these accounts should not be used for daily routines and should never be used outside of domain controllers)\"\n\n        self.users_nb_domain_admins = requests_results[\"nb_domain_admins\"]\n\n    def run(self):\n        if self.users_nb_domain_admins is None:\n            self.max_da_per_domain = 0\n            return\n        page = Page(\n            self.arguments.cache_prefix,\n            \"nb_domain_admins\",\n            \"List of domain admins\",\n            self.get_dico_description(),\n        )\n        # Count the max number of domain admins per domain\n        count_da = {}\n        for da in self.users_nb_domain_admins:\n            try:\n                count_da[da[\"domain\"]] += 1\n            except KeyError:\n                count_da[da[\"domain\"]] = 1\n        self.max_da_per_domain = max(count_da.values(), default=0)\n\n        data = []\n\n        for da in self.users_nb_domain_admins:\n            tmp_data = {}\n            tmp_data[\"domain\"] = '<i class=\"bi bi-globe2\"></i> ' + da[\"domain\"]\n            tmp_data[\"name\"] = '<i class=\"bi bi-gem\"></i> ' + da[\"name\"]\n            tmp_data[\"domain admin\"] = (\n                '<i class=\"bi bi-check-square-fill\"></i><span style=\"display:none\">True</span>'\n                if \"Domain Admin\" in da[\"admin type\"]\n                else '<i class=\"bi bi-square\"></i>'\n            )\n            tmp_data[\"schema admin\"] = (\n                '<i class=\"bi bi-check-square-fill\"></i><span style=\"display:none\">True</span>'\n                if \"Schema Admin\" in da[\"admin type\"]\n                else '<i class=\"bi bi-square\"></i>'\n            )\n            tmp_data[\"enterprise admin\"] = (\n                '<i class=\"bi bi-check-square-fill\"></i><span style=\"display:none\">True</span>'\n                if \"Enterprise Admin\" in da[\"admin type\"]\n                else '<i class=\"bi bi-square\"></i>'\n            )\n            tmp_data[\"protected users\"] = (\n                '<i class=\"bi bi-check-square-fill\"></i><span style=\"display:none\">True</span>'\n                if \"Protected Users\" in da[\"admin type\"]\n                else '<i class=\"bi bi-square\"></i>'\n            )\n            tmp_data[\"key admin\"] = (\n                '<i class=\"bi bi-check-square-fill\"></i><span style=\"display:none\">True</span>'\n                if \"_ Key Admin\" in da[\"admin type\"]\n                else '<i class=\"bi bi-square\"></i>'\n            )\n            tmp_data[\"enterprise key admin\"] = (\n                '<i class=\"bi bi-check-square-fill\"></i><span style=\"display:none\">True</span>'\n                if \"Enterprise Key Admin\" in da[\"admin type\"]\n                else '<i class=\"bi bi-square\"></i>'\n            )\n            tmp_data[\"builtin admin\"] = (\n                '<i class=\"bi bi-check-square-fill\"></i><span style=\"display:none\">True</span>'\n                if \"Builtin Administrator\" in da[\"admin type\"]\n                else '<i class=\"bi bi-square\"></i>'\n            )\n            data.append(tmp_data)\n\n        grid = Grid(\"Domain admins\")\n        grid.setheaders(\n            [\n                \"domain\",\n                \"name\",\n                \"domain admin\",\n                \"schema admin\",\n                \"enterprise admin\",\n                \"protected users\",\n                \"key admin\",\n                \"enterprise key admin\",\n                \"builtin admin\",\n            ]\n        )\n        grid.setData(data)\n        page.addComponent(grid)\n        page.render()\n\n        self.data = (\n            len(self.users_nb_domain_admins) if self.users_nb_domain_admins else 0\n        )\n        self.name_description = f\"{self.data} domain admins\"\n\n    def get_rating(self) -> int:\n        return presence_of([\"1\"] * self.max_da_per_domain, criticity=2, threshold=10)\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "ad_miner/sources/modules/common_analysis.py": {
        "imported_elements": [
          "presence_of"
        ],
        "code_map": {
          "presence_of": "def presence_of(req, criticity=1, threshold=0):\n    if req is None:\n        return -1\n    if len(req) > threshold:\n        return criticity\n    return 5"
        }
      }
    },
    "requests_keys": [
      "nb_domain_admins"
    ]
  },
  {
    "title": "OUs without any member",
    "file_name": "empty_ous.py",
    "control_category": "Misc",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\n\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\n\n\n@register_control\nclass empty_ous(Control):  # TODO change the class name\n    \"Docstring of my control\"  # TODO small documentation here\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"misc\"\n        self.control_key = \"empty_ous\"\n\n        self.title = \"OUs without any member\"\n        self.description = \"These OUs do not contain any user, computer or any other group, which probably means they are not used anymore.\"\n        self.risk = \"As unused OUs still retain their privilege but are less monitored, an attacker could exploit one of these to gain further access to the information system.\"\n        self.poa = \"Review these OUs and check wether they should have lesser privilege or be deleted.\"\n\n        self.empty_ous = requests_results[\"get_empty_ous\"]\n        self.groups = requests_results[\"nb_groups\"]\n\n    def run(self):\n        page = Page(\n            self.arguments.cache_prefix,\n            \"empty_ous\",\n            \"OUs with no object\",\n            self.get_dico_description(),\n        )\n        grid = Grid(\"OUs without any object in it\")\n        headers = [\"Empty Organizational Unit\", \"Full Reference\"]\n\n        for d in self.empty_ous:\n            d[\"Empty Organizational Unit\"] = (\n                '<i class=\"bi bi-building\"></i> ' + d[\"Empty Organizational Unit\"]\n            )\n\n        grid.setheaders(headers)\n        grid.setData(self.empty_ous)\n\n        page.addComponent(grid)\n        page.render()\n\n        self.data = len(self.empty_ous)\n        self.name_description = f\"{self.data} OUs without any member\"\n\n    def get_rating(self) -> int:\n        if len(self.groups) > 0:\n            return (\n                2\n                if len(self.empty_ous) / len(self.groups) > 0.40\n                else 3 if len(self.empty_ous) / len(self.groups) > 0.20 else 5\n            )\n        return -1\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      }
    },
    "requests_keys": [
      "nb_groups",
      "get_empty_ous"
    ]
  },
  {
    "title": "Non-tier 0 local admin privs on ADCS",
    "file_name": "objects_to_adcs.py",
    "control_category": "Permissions",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\n\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\nfrom ad_miner.sources.modules.graph_class import Graph\n\nfrom ad_miner.sources.modules.utils import grid_data_stringify\nfrom ad_miner.sources.modules.common_analysis import presence_of\n\nfrom urllib.parse import quote\n\n\n@register_control\nclass objects_to_adcs(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"permissions\"\n\n        # Do NOT change existing control_key, as it will break evolution with older ad miner versions\n        self.control_key = \"objects_to_adcs\"\n\n        self.title = \"Non-tier 0 local admin privs on ADCS\"\n        self.description = \"ADCS (Active Directory Certificate Services) is a Windows Server feature that provides a customizable certification authority (CA) for issuing and managing digital certificates. Digital certificates are used to authenticate and secure communication between devices, servers, and users on a network.\"\n        self.interpretation = \"\"\n        self.risk = \"These ADCS servers can be compromised, which means that an attacker can issue fraudulent certificates, which can be used to impersonate legitimate users or servers on the network. This can lead to unauthorized access to sensitive information, data theft, or network disruption.\"\n        self.poa = \"Ensure that the existing privileges on these ADCS servers are legitimate and limit them to administrators optimaly.\"\n\n        self.objects_to_adcs = requests_results[\"objects_to_adcs\"]\n\n        self.path_to_adcs_name_description = {\n            \"title\": \"Non-tier 0 local admin privs on ADCS\",\n            \"description\": \"Non-tier 0 local admin privs on ADCS\",\n            \"risk\": \"This ADCS server can be compromised, which means that an attacker can issue fraudulent certificates, which can be used to impersonate legitimate users or servers on the network. This can lead to unauthorized access to sensitive information, data theft, or network disruption.\",\n            \"poa\": \"Ensure that the existing privileges on this ADCS server are legitimate and limit them to administrators optimaly.\",\n        }\n\n    def run(self):\n        if self.objects_to_adcs is None:\n            return\n\n        self.total_paths = 0\n\n        page = Page(\n            self.arguments.cache_prefix,\n            \"objects_to_adcs\",\n            \"Non-tier 0 local admin privs on ADCS\",\n            self.get_dico_description(),\n        )\n        grid = Grid(\"Objects to ADCS servers\")\n        grid.setheaders([\"Domain\", \"Name\", \"Path to ADCS\"])\n\n        self.ADCS_path_sorted = {}\n        self.ADCS_entry_point = []\n\n        for path in self.objects_to_adcs:\n            self.ADCS_entry_point.append(path.nodes[0].name)\n            try:\n                self.ADCS_path_sorted[path.nodes[-1].name].append(path)\n            except KeyError:\n                self.ADCS_path_sorted[path.nodes[-1].name] = [path]\n\n        self.ADCS_entry_point = list(set(self.ADCS_entry_point))\n\n        cleaned_data = []\n\n        for key, paths in self.ADCS_path_sorted.items():\n            tmp_data = {}\n            tmp_data[\"Domain\"] = (\n                '<i class=\"bi bi-globe2\"></i> ' + paths[0].nodes[-1].domain\n            )\n            tmp_data[\"Name\"] = '<i class=\"bi bi-server\"></i> ' + key\n            nb_path_to_adcs = len(paths)\n            self.total_paths += nb_path_to_adcs\n            sortClass = str(nb_path_to_adcs).zfill(6)\n            tmp_data[\"Path to ADCS\"] = grid_data_stringify(\n                {\n                    \"link\": \"path_to_adcs_%s.html\" % quote(str(key)),\n                    \"value\": f\"{nb_path_to_adcs} paths to ADCS\",\n                    \"before_link\": f\"<i class='bi bi-shuffle {sortClass}' aria-hidden='true'></i>\",\n                }\n            )\n            cleaned_data.append(tmp_data)\n\n            graph_page = Page(\n                self.arguments.cache_prefix,\n                \"path_to_adcs_%s\" % key,\n                \"Path to ADCS through \" + key,\n                self.path_to_adcs_name_description,\n            )\n            graph = Graph()\n            graph.setPaths(paths)\n            graph_page.addComponent(graph)\n            graph_page.render()\n\n        grid.setData(cleaned_data)\n        page.addComponent(grid)\n        page.render()\n\n        self.data = self.total_paths\n\n        self.name_description = (\n            f\"{self.data} non-tier-0 with local admin privileges on ADCS\"\n        )\n\n    def get_rating(self) -> int:\n        return presence_of(self.ADCS_path_sorted.keys())\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "ad_miner/sources/modules/graph_class.py": {
        "imported_elements": [
          "Graph"
        ],
        "code_map": {
          "Graph": "class Graph:\n    def __init__(self, template=\"graph\", path_limit=80000):\n        self.template_base_path = HTML_DIRECTORY / \"components/graph/\"\n        self.template = template\n        self.paths = []\n        self.nodes = {}\n        self.relations = []\n        self.relations_hashes = {}\n        self.path_limit = path_limit\n        self.ghost_computer = {}\n        self.ghost_user = {}\n        self.dc_computer = {}\n        self.user_da = {}\n        self.group_da = {}\n        self.enabled_users = {}\n        self.kerberoastable_users = {}\n        self.disabled_users_dict = {}\n\n    def addPath(self, path):\n        self.paths.append(path)\n\n    def setPaths(self, paths):\n        self.paths = paths\n\n    def addGhostComputers(self, ghost_computer):\n        self.ghost_computer = ghost_computer\n\n    def addGhostUsers(self, ghost_user):\n        self.ghost_user = ghost_user\n\n    def addDCComputers(self, dc_computer):\n        self.dc_computer = dc_computer\n\n    def addUserDA(self, user_da):\n        self.user_da = user_da\n\n    def addGroupDA(self, group_da):\n        self.group_da = group_da\n\n    def addDisabledUsers(self, disabled_users):\n        self.disabled_users_dict = {}\n        for d in disabled_users:\n            self.disabled_users_dict[d[\"name\"]] = True\n\n    def addKerberoastableUsers(self, kerberoastable_users):\n        self.kerberoastable_users = kerberoastable_users\n\n    def render(self, page_f):\n\n        # Write header\n        with open(\n            self.template_base_path / (self.template + \"_header.html\"), \"r\"\n        ) as header_f:\n            html_header = header_f.read()\n            page_f.write(html_header)\n\n        for index, path in enumerate(self.paths):\n            for i in range(len(path.nodes)):\n\n                node = path.nodes[i]\n\n                # Compute node style\n                if i == 0:\n                    node_position = \"start\"\n                elif i == len(path.nodes) - 1:\n                    node_position = \"end\"\n                else:\n                    node_position = \"intermediate\"\n\n                # Add new labels here. A corresponding svg icon should be defined\n                # dico_icon in the icon.js file.\n                list_labels = [\n                    \"User\",\n                    \"Foreignsecurityprincipal\",\n                    \"GPO\",\n                    \"Computer\",\n                    \"OU\",\n                    \"Group\",\n                    \"Domain\",\n                    \"ADLocalGroup\",\n                    \"Container\",\n                    \"Unknown\",\n                    \"Group_cluster\",\n                    \"Device\",\n                    \"AZTenant\",\n                    \"AZRole\",\n                ]\n\n                if node.labels in list_labels:\n                    label_instance = node.labels\n                elif path.nodes[i].labels[2:] in list_labels:\n                    label_instance = node.labels[2:]\n                else:\n                    label_instance = \"Unknown\"\n\n                node_attributes = []\n\n                # Add DA icon if node is DC, DA or Domain\n                if (\n                    (\n                        label_instance == \"Computer\"\n                        and self.dc_computer.get(node.name, False)\n                    )\n                    or (label_instance == \"User\" and self.user_da.get(node.name, False))\n                    or (\n                        label_instance == \"Group\"\n                        and self.group_da.get(node.name, False)\n                    )\n                    or label_instance == \"Domain\"\n                ):\n                    node_attributes.append(\"da\")\n\n                # Add ghost icon if ghost\n                if (\n                    label_instance == \"User\" and self.ghost_user.get(node.name, False)\n                ) or (\n                    label_instance == \"Computer\"\n                    and self.ghost_computer.get(node.name, False)\n                ):\n                    node_attributes.append(\"ghost\")\n\n                if label_instance == \"User\" and self.disabled_users_dict.get(\n                    node.name, False\n                ):\n                    node_attributes.append(\"disabled\")\n\n                if label_instance == \"User\" and self.kerberoastable_users.get(\n                    node.name, False\n                ):\n                    node_attributes.append(\"kerberoastable\")\n\n                # New nodes attributes that should be added to the node icon\n                # should be added here to the node_attributes list.\n                # A corresponding svg icon should the be added to the\n                # dico_icon in icon.js\n\n                if not self.nodes.get(path.nodes[i].id):\n\n                    final_graph_node = {\n                        \"id\": path.nodes[i].id,\n                        \"label\": path.nodes[i].name,\n                        \"domain\": path.nodes[i].domain,\n                        \"shape\": \"image\",\n                        \"instance\": label_instance,\n                        \"position\": node_position,\n                        \"attributes\": node_attributes,\n                    }\n                    self.nodes[path.nodes[i].id] = final_graph_node\n\n                if i != 0:\n                    relation = {\n                        \"from\": path.nodes[i - 1].id,\n                        \"to\": path.nodes[i].id,\n                        \"label\": path.nodes[i - 1].relation_type,\n                    }\n\n                    # Avoid relation duplicated to keep graph clean\n                    # Use hashes list for better performance\n                    hash_rel = hash(\n                        str(relation[\"from\"])\n                        + str(relation[\"to\"])\n                        + str(relation[\"label\"])\n                    )\n                    if not self.relations_hashes.get(hash_rel):\n                        self.relations.append(relation)\n                        self.relations_hashes[hash_rel] = True\n\n        nodes = list(self.nodes.values())\n        for n in nodes:  # Sanitize None values (otherwise it creates a bug in JS)\n            if n[\"label\"] == None:\n                n[\"label\"] = \"???\"\n        page_f.write(f'<script type=\"text/javascript\">window.data_nodes = {nodes};\\n')\n        page_f.write(f\"window.data_edges = {self.relations};</script>\\n\")"
        }
      },
      "ad_miner/sources/modules/utils.py": {
        "imported_elements": [
          "grid_data_stringify"
        ],
        "code_map": {
          "grid_data_stringify": "def grid_data_stringify(raw_data: dict) -> str:\n    \"\"\"\n    Transform a dict to a string for the grid formating. This is a dumb fix for the sorting with hyperlink.\n    dict format :\n    {\n        \"link\",\n        \"value\",\n        \"before_link\"\n    }\n    \"\"\"\n    link = raw_data['link'].replace(sep, '_').replace('/', '_')\n    try:\n        return f\"{raw_data['before_link']} <a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\"\n    except KeyError:\n        return f\"<a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\""
        }
      },
      "ad_miner/sources/modules/common_analysis.py": {
        "imported_elements": [
          "presence_of"
        ],
        "code_map": {
          "presence_of": "def presence_of(req, criticity=1, threshold=0):\n    if req is None:\n        return -1\n    if len(req) > threshold:\n        return criticity\n    return 5"
        }
      },
      "/Users/steverassinot/Repos/AD_Miner/urllib/parse/__init__.py": {
        "imported_elements": [
          "quote"
        ],
        "code_map": {}
      }
    },
    "requests_keys": [
      "objects_to_adcs"
    ]
  },
  {
    "title": "Users that have powerful cross-domain privileges",
    "file_name": "cross_domain_admin_privileges.py",
    "control_category": "Permissions",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\nfrom ad_miner.sources.modules.utils import grid_data_stringify\nfrom ad_miner.sources.modules.common_analysis import createGraphPage\n\nimport copy\n\n\n@register_control\nclass cross_domain_admin_privileges(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"permissions\"\n        self.control_key = \"cross_domain_admin_privileges\"\n\n        self.title = \"Users that have powerful cross-domain privileges\"\n        self.description = \"Users privileges are not limited to their domains. Sometimes some users may have direct or non-direct local admin or even domain admin privilege on a foreign domain.\"\n        self.risk = \"Cross-domain privileges are quite dangerous and will help attackers to pivot to other domains if they manage to compromise a domain\"\n        self.poa = \"Review these privileges, this list should be as little as possible.\"\n\n        self.cross_domain_local_admins_paths = requests_results[\n            \"cross_domain_local_admins\"\n        ]\n        self.cross_domain_domain_admins_paths = requests_results[\n            \"cross_domain_domain_admins\"\n        ]\n\n    def run(self):\n        # get the result of the cypher request (a list of Path objects)\n        paths_local_admins = self.cross_domain_local_admins_paths\n\n        paths_domain_admins = self.cross_domain_domain_admins_paths\n        # create the page\n        page = Page(\n            self.arguments.cache_prefix,\n            \"cross_domain_admin_privileges\",\n            \"Cross-Domain admin privileges\",\n            self.get_dico_description(),\n        )\n        # create the grid\n        grid = Grid(\"Cross-Domain admin privileges\")\n        # create the headers (domains)\n        headers = [\n            \"user\",\n            \"crossLocalAdminAsGraph\",\n            \"crossLocalAdminAsList\",\n            \"crossDomainAdminAsGraph\",\n            \"crossDomainAdminAsList\",\n        ]\n\n        data_local_admins = {}\n        for path in paths_local_admins:\n            user = path.nodes[0].name\n            target_domain = path.nodes[-1].domain\n            if user in data_local_admins.keys():\n                # data_local_admins[user].append(path)\n                if target_domain in data_local_admins[user]:\n                    data_local_admins[user][target_domain].append(path)\n                else:\n                    data_local_admins[user][target_domain] = [path]\n            else:\n                data_local_admins[user] = {target_domain: [path]}\n\n        data = {}\n\n        data_domain_admins = {}\n        for path in paths_domain_admins:\n            user = path.nodes[0].name\n            target_domain = path.nodes[-1].domain\n            if user in data_domain_admins.keys():\n                # data_domain_admins[user].append(path)\n                if target_domain in data_domain_admins[user]:\n                    data_domain_admins[user][target_domain].append(path)\n                else:\n                    data_domain_admins[user][target_domain] = [path]\n            else:\n                data_domain_admins[user] = {target_domain: [path]}\n\n        user_keys_raw = list(data_local_admins.keys()) + list(data_domain_admins.keys())\n        unique_users_keys = set(user_keys_raw)\n\n        grid_data = []\n\n        self.cross_domain_total_admin_accounts = len(list(unique_users_keys))\n        self.cross_domain_local_admin_accounts = len(list(data_local_admins))\n        self.cross_domain_domain_admin_accounts = len(list(data_domain_admins))\n\n        for key in unique_users_keys:\n            user = key\n            tmp_data = {}\n\n            tmp_data[\"user\"] = '<i class=\"bi bi-person-fill\"></i> ' + user\n            grid_list_local_admin_targets_data = []\n            grid_list_domain_admin_targets_data = []\n            # create the grid\n            grid_list_local_admin_targets = Grid(\n                \"List of computers from a foreign domain where \"\n                + user\n                + \" happens to be a local admin\"\n            )\n            grid_list_domain_admin_targets = Grid(\n                \"List of foreign domains where \"\n                + user\n                + \" happens to be a domain admin\"\n            )\n            if key in data_local_admins.keys():\n                local_targets = []\n                local_distinct_ends = []\n                for domain in data_local_admins[key]:\n                    list_local_admin_targets_tmp_data = {\n                        \"domain\": '<i class=\"bi bi-globe2\"></i> ' + domain\n                    }\n                    numberofpaths = 0\n                    for path in data_local_admins[key][domain]:\n                        list_local_admin_targets_tmp_data_copy = copy.deepcopy(\n                            list_local_admin_targets_tmp_data\n                        )\n                        last_node_name = path.nodes[-1].name\n                        local_targets.append(path)\n                        if last_node_name not in local_distinct_ends:\n                            local_distinct_ends.append(last_node_name)\n                            sortClass = last_node_name.zfill(6)\n                            list_local_admin_targets_tmp_data_copy[\"target\"] = (\n                                grid_data_stringify(\n                                    {\n                                        \"value\": f\"{last_node_name}\",\n                                        \"link\": \"%s_paths_cross_domain_local_admin.html\"\n                                        % user,\n                                        \"before_link\": f'<i class=\"bi bi-shuffle {sortClass}\"></i>',\n                                    }\n                                )\n                            )\n\n                            grid_list_local_admin_targets_data.append(\n                                list_local_admin_targets_tmp_data_copy\n                            )\n                    nb_local_distinct_ends = len(local_distinct_ends)\n                sortClass = str(nb_local_distinct_ends).zfill(6)\n                tmp_data[\"crossLocalAdminAsGraph\"] = grid_data_stringify(\n                    {\n                        \"value\": f\"{nb_local_distinct_ends} computers impacted\",\n                        \"link\": \"%s_paths_cross_domain_local_admin.html\" % user,\n                        \"before_link\": f'<i class=\"bi bi-shuffle {sortClass}\"></i>',\n                    }\n                )\n                createGraphPage(\n                    self.arguments.cache_prefix,\n                    user + \"_paths_cross_domain_local_admin\",\n                    \"Paths from \"\n                    + user\n                    + \" to machines of privileged groups from other domains making them domainadmin\",\n                    self.get_dico_description(),\n                    local_targets,\n                    self.requests_results,\n                )\n\n                page_list_local_admin_targets = Page(\n                    self.arguments.cache_prefix,\n                    \"cross_domain_local_admins_targets_from_\" + user,\n                    \"List of computers from a foreign domain where \"\n                    + user\n                    + \" happens to be a local admin\",\n                    self.get_dico_description(),\n                )\n                # create the headers (domains)\n                local_admins_list_page_headers = [\"domain\", \"target\"]\n                grid_list_local_admin_targets.setheaders(local_admins_list_page_headers)\n                grid_list_local_admin_targets.setData(\n                    grid_list_local_admin_targets_data\n                )\n                page_list_local_admin_targets.addComponent(\n                    grid_list_local_admin_targets\n                )\n                page_list_local_admin_targets.render()\n                tmp_data[\"crossLocalAdminAsList\"] = grid_data_stringify(\n                    {\n                        \"value\": \"<i class='bi bi-list-columns-reverse'></i></span>\",\n                        \"link\": \"cross_domain_local_admins_targets_from_%s.html\" % user,\n                    }\n                )\n\n            else:\n                tmp_data[\"crossLocalAdminAsGraph\"] = \"-\"\n                tmp_data[\"crossLocalAdminAsList\"] = \"-\"\n\n            if key in data_domain_admins.keys():\n                domain_targets = []\n                domain_distinct_ends = []\n                for domain in data_domain_admins[key]:\n                    list_domain_admin_targets_tmp_data = {\n                        \"domain\": '<i class=\"bi bi-globe2\"></i> ' + domain\n                    }\n\n                    for path in data_domain_admins[key][domain]:\n                        list_domain_admin_targets_tmp_data_copy = copy.deepcopy(\n                            list_domain_admin_targets_tmp_data\n                        )\n                        last_node_name = path.nodes[-1].name\n                        domain_targets.append(path)\n                        if last_node_name not in domain_distinct_ends:\n\n                            domain_distinct_ends.append(last_node_name)\n\n                            sortClass = last_node_name.zfill(6)\n                            list_domain_admin_targets_tmp_data_copy[\"target\"] = (\n                                grid_data_stringify(\n                                    {\n                                        \"value\": f\"{last_node_name}\",\n                                        \"link\": \"%s_paths_cross_domain_domain_admin.html\"\n                                        % user,\n                                        \"before_link\": f'<i class=\"bi bi-shuffle {sortClass}\"></i>',\n                                    }\n                                )\n                            )\n\n                            grid_list_domain_admin_targets_data.append(\n                                list_domain_admin_targets_tmp_data_copy\n                            )\n\n                    nb_domain_distinct_ends = len(domain_distinct_ends)\n                sortClass = str(len(list(data_domain_admins[key].keys()))).zfill(6)\n                tmp_data[\"crossDomainAdminAsGraph\"] = grid_data_stringify(\n                    {\n                        \"value\": f\"{len(list(data_domain_admins[key].keys()))} domains impacted\",\n                        \"link\": \"%s_paths_cross_domain_domain_admin.html\" % user,\n                        \"before_link\": f'<i class=\"bi bi-shuffle {sortClass}\"></i>',\n                    }\n                )\n                createGraphPage(\n                    self.arguments.cache_prefix,\n                    user + \"_paths_cross_domain_domain_admin\",\n                    \"Paths from \"\n                    + user\n                    + \" to privileged groups from other domains making him/her domain admin\",\n                    self.get_dico_description(),\n                    domain_targets,\n                    self.requests_results,\n                )\n\n                page_list_domain_admin_targets = Page(\n                    self.arguments.cache_prefix,\n                    \"cross_domain_domain_admins_targets_from_\" + user,\n                    \"List of other domains where \"\n                    + user\n                    + \" happens to be a domain admin\",\n                    self.get_dico_description(),\n                )\n                # create the headers (domains)\n                domain_admins_list_page_headers = [\"domain\", \"target\"]\n                grid_list_domain_admin_targets.setheaders(\n                    domain_admins_list_page_headers\n                )\n                grid_list_domain_admin_targets.setData(\n                    grid_list_domain_admin_targets_data\n                )\n                page_list_domain_admin_targets.addComponent(\n                    grid_list_domain_admin_targets\n                )\n                page_list_domain_admin_targets.render()\n                tmp_data[\"crossDomainAdminAsList\"] = grid_data_stringify(\n                    {\n                        \"value\": \"<i class='bi bi-list-columns-reverse'></i></span>\",\n                        \"link\": \"cross_domain_domain_admins_targets_from_%s.html\"\n                        % user,\n                    }\n                )\n\n            else:\n                tmp_data[\"crossDomainAdminAsGraph\"] = \"-\"\n                tmp_data[\"crossDomainAdminAsList\"] = \"-\"\n            grid_data.append(tmp_data)\n\n        grid.setheaders(headers)\n        grid.setData(grid_data)\n        page.addComponent(grid)\n        page.render()\n\n        self.data = self.cross_domain_total_admin_accounts\n        self.name_description = (\n            f\"{self.data} accounts have cross-domain admin privileges\"\n        )\n\n    def get_rating(self) -> int:\n        if self.cross_domain_domain_admin_accounts > 0:\n            return 1\n        elif self.cross_domain_local_admin_accounts > 0:\n            return 2\n        else:\n            return 5\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "ad_miner/sources/modules/utils.py": {
        "imported_elements": [
          "grid_data_stringify"
        ],
        "code_map": {
          "grid_data_stringify": "def grid_data_stringify(raw_data: dict) -> str:\n    \"\"\"\n    Transform a dict to a string for the grid formating. This is a dumb fix for the sorting with hyperlink.\n    dict format :\n    {\n        \"link\",\n        \"value\",\n        \"before_link\"\n    }\n    \"\"\"\n    link = raw_data['link'].replace(sep, '_').replace('/', '_')\n    try:\n        return f\"{raw_data['before_link']} <a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\"\n    except KeyError:\n        return f\"<a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\""
        }
      },
      "ad_miner/sources/modules/common_analysis.py": {
        "imported_elements": [
          "createGraphPage"
        ],
        "code_map": {
          "createGraphPage": "def createGraphPage(\n    render_prefix, page_name, page_title, page_description, graph_data, requests_results\n):\n    page = Page(render_prefix, page_name, page_title, page_description)\n    graph = Graph()\n    graph.setPaths(graph_data)\n\n    graph.addGhostComputers(requests_results[\"dico_ghost_computer\"])\n    graph.addGhostUsers(requests_results[\"dico_ghost_user\"])\n    graph.addDCComputers(requests_results[\"dico_dc_computer\"])\n    graph.addUserDA(requests_results[\"dico_user_da\"])\n    graph.addGroupDA(requests_results[\"dico_da_group\"])\n    graph.addKerberoastableUsers(requests_results[\"dico_is_kerberoastable\"])\n\n    page.addComponent(graph)\n    page.render()"
        }
      }
    },
    "requests_keys": [
      "dico_ghost_computer",
      "cross_domain_domain_admins",
      "cross_domain_local_admins",
      "dico_da_group",
      "dico_dc_computer",
      "dico_is_kerberoastable",
      "dico_ghost_user",
      "dico_user_da"
    ]
  },
  {
    "title": "Paths to Domain Admins",
    "file_name": "graph_path_objects_to_da.py",
    "control_category": "Permissions",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\n\nfrom ad_miner.sources.modules import logger\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\nfrom ad_miner.sources.modules.utils import grid_data_stringify\nfrom ad_miner.sources.modules.common_analysis import presence_of, createGraphPage\n\nfrom urllib.parse import quote\n\n\n@register_control\nclass graph_path_objects_to_da(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"permissions\"\n        self.control_key = \"graph_path_objects_to_da\"\n\n        self.title = \"Paths to Domain Admins\"\n        self.description = \"Compromission paths from some Active Directory object to domain admin privileges.\"\n        self.risk = \"Compromission paths to domain admin represent the exposed attack surface that the AD environment presents to the attacker in order to gain privileges in the domain(s). If an attacker exploits one of these paths, they will be able to gain privileges in the domain(s) and cause some serious damage.\"\n        self.poa = \"Review the paths, make sure they are not exploitable. If they are, cut the link between the Active Directory objects in order to reduce the attack surface.\"\n\n        self.objects_to_domain_admin = requests_results[\"objects_to_domain_admin\"]\n\n        self.objects_to_domain = self.requests_results[\"objects_to_domain_admin\"]\n        self.users_to_domain = self.requests_results[\"users_to_domain_admin\"]\n        self.groups_to_domain = self.requests_results[\"groups_to_domain_admin\"]\n        self.computers_to_domain = self.requests_results[\"computers_to_domain_admin\"]\n        self.domains_to_domain = self.requests_results[\"domains_to_domain_admin\"]\n\n        self.users_to_domain_admin = self.users_to_domain\n        self.computers_to_domain_admin = self.computers_to_domain\n        self.groups_to_domain_admin = self.groups_to_domain\n\n        self.domains = requests_results[\"domains\"]\n        self.collected_domains = requests_results[\"nb_domain_collected\"]\n\n        self.dico_description_paths_to_domain_admin = {\n            \"description\": \"Paths leading to domain admin\",\n            \"risk\": \"Compromission paths to domain admin represent the exposed attack surface that the AD environment presents to the attacker in order to gain privileges in the domain(s). If an attacker exploits one of these paths, they will be able to gain privileges in the domain(s) and cause some serious damage.\",\n            \"poa\": \"Review the paths, make sure they are not exploitable. If they are, cut the link between the Active Directory objects in order to reduce the attack surface.\",\n        }\n\n    def run(self):\n\n        self.generatePathToDa()\n\n        self.data = (\n            len(\n                list(\n                    set(\n                        p.nodes[0]\n                        for p in [\n                            item\n                            for sublist in self.users_to_domain_admin.values()\n                            for item in sublist\n                        ]\n                    )\n                )\n            )\n            if self.users_to_domain_admin\n            else 0\n        )\n        self.name_description = f\"{len(list(set(p.nodes[0] for p in [item for sublist in self.users_to_domain_admin.values() for item in sublist]))) if self.users_to_domain_admin else 0} users have a path to DA\"\n\n    def get_rating(self) -> int:\n        if (\n            self.users_to_domain_admin is None\n            or self.computers_to_domain_admin is None\n            or self.groups_to_domain_admin is None\n        ):\n            return -1\n\n        for domain in self.users_to_domain_admin:\n            if len(self.users_to_domain_admin[domain]) > 0:\n                return 1\n        for domain in self.computers_to_domain_admin:\n            if len(self.computers_to_domain_admin[domain]) > 0:\n                return 1\n        for domain in self.groups_to_domain_admin:\n            if len(self.groups_to_domain_admin[domain]) > 0:\n                return 1\n        return 5\n\n    def generatePathToDa(\n        self, file_variable=\"da\", file_variable2=\"admin\"\n    ):  # file_variable if we want to generate path to something other than domain admin groups\n        if file_variable == \"da\":\n            if self.objects_to_domain_admin is None:\n                return\n\n        for domain in self.domains:\n            domain = domain[0]\n            if len(self.users_to_domain[domain]):\n                createGraphPage(\n                    self.arguments.cache_prefix,\n                    domain + f\"_users_to_{file_variable}\",\n                    f\"Paths to domain {file_variable2}\",\n                    self.dico_description_paths_to_domain_admin,\n                    self.users_to_domain[domain],\n                    self.requests_results,\n                )\n            if len(self.computers_to_domain[domain]):\n                createGraphPage(\n                    self.arguments.cache_prefix,\n                    domain + f\"_computers_to_{file_variable}\",\n                    f\"Paths to domain {file_variable2}\",\n                    self.dico_description_paths_to_domain_admin,\n                    self.computers_to_domain[domain],\n                    self.requests_results,\n                )\n            if len(self.groups_to_domain[domain]):\n                createGraphPage(\n                    self.arguments.cache_prefix,\n                    domain + f\"_groups_to_{file_variable}\",\n                    f\"Paths to domain {file_variable2}\",\n                    self.dico_description_paths_to_domain_admin,\n                    self.groups_to_domain[domain],\n                    self.requests_results,\n                )\n\n        if len(self.domains_to_domain):\n            createGraphPage(\n                self.arguments.cache_prefix,\n                f\"domains_to_{file_variable}\",\n                f\"Paths to domain {file_variable2}\",\n                self.dico_description_paths_to_domain_admin,\n                self.domains_to_domain_admin,\n                self.requests_results,\n            )\n\n        def count_object_from_path(list_of_paths):\n            \"\"\"\n            Count the numbers of object leading to DA instead of counting number of path.\n            \"\"\"\n            entries = []\n            for path in list_of_paths:\n                start = path.nodes[0].name\n                if start not in entries:\n                    entries.append(start)\n            return len(entries)\n\n        # generating graph object to da grid\n        page = Page(\n            self.arguments.cache_prefix,\n            f\"graph_path_objects_to_{file_variable}\",\n            \"Paths to Domain Admins\",\n            self.get_dico_description(),\n        )\n        grid = Grid(\"Numbers of path to domain admin per domain and objects\")\n        grid_data = []\n        headers = [\n            \"Domain\",\n            \"Users (Paths)\",\n            \"Computers (Paths)\",\n            \"Groups (Paths)\",\n        ]\n        self.total_object = 0\n\n        for domain in self.collected_domains:\n            domain = domain[0]\n            tmp_data = {}\n\n            tmp_data[headers[0]] = '<i class=\"bi bi-globe2\"></i> ' + domain\n\n            count = count_object_from_path(self.users_to_domain[domain])\n            sortClass = str(count).zfill(\n                6\n            )  # used to make the sorting feature work with icons\n            if count != 0:\n                tmp_data[headers[1]] = grid_data_stringify(\n                    {\n                        \"value\": f\"{count} (<i class='bi bi-shuffle' aria-hidden='true'></i> {len(self.users_to_domain_admin[domain])})\",\n                        \"link\": \"%s_users_to_da.html\" % quote(str(domain)),\n                        \"before_link\": f\"<i class='bi bi-person-fill {sortClass}' aria-hidden='true'></i> \",\n                    }\n                )\n            else:\n                tmp_data[headers[1]] = (\n                    \"<i class='bi bi-person-fill %s' aria-hidden='true'></i> %s (<i class='bi bi-shuffle' aria-hidden='true'></i> %s)\"\n                    % (sortClass, count, len(self.users_to_domain_admin[domain]))\n                )\n            self.total_object += count\n\n            count = count_object_from_path(self.computers_to_domain[domain])\n            sortClass = str(count).zfill(\n                6\n            )  # used to make the sorting feature work with icons\n            if count != 0:\n                tmp_data[headers[2]] = grid_data_stringify(\n                    {\n                        \"value\": f\"{count} (<i class='bi bi-shuffle' aria-hidden='true'></i> {len(self.computers_to_domain_admin[domain])})\",\n                        \"link\": \"%s_computers_to_da.html\" % quote(str(domain)),\n                        \"before_link\": f\"<i class='bi bi-pc-display-horizontal {sortClass}' aria-hidden='true'></i>\",\n                    }\n                )\n            else:\n                tmp_data[headers[2]] = (\n                    \"<i class='bi bi-pc-display-horizontal %s' aria-hidden='true'></i> %s (<i class='bi bi-shuffle' aria-hidden='true'></i> %s)\"\n                    % (sortClass, count, len(self.computers_to_domain_admin[domain]))\n                )\n            self.total_object += count\n\n            count = count_object_from_path(self.groups_to_domain[domain])\n            sortClass = str(count).zfill(\n                6\n            )  # used to make the sorting feature work with icons\n            if count != 0:\n                tmp_data[headers[3]] = grid_data_stringify(\n                    {\n                        \"value\": f\"{count} (<i class='bi bi-shuffle' aria-hidden='true'></i> {len(self.groups_to_domain_admin[domain])})\",\n                        \"link\": \"%s_groups_to_da.html\" % quote(str(domain)),\n                        \"before_link\": f\"<i class='bi bi-people-fill {sortClass}' aria-hidden='true'></i>\",\n                    }\n                )\n            else:\n                tmp_data[headers[3]] = (\n                    \"<i class='bi bi-people-fill %s' aria-hidden='true'></i> %s (<i class='bi bi-shuffle' aria-hidden='true'></i> %s)\"\n                    % (sortClass, count, len(self.groups_to_domain_admin[domain]))\n                )\n            self.total_object += count\n\n            grid_data.append(tmp_data)\n        grid.setheaders(headers)\n        grid.setData(grid_data)\n        page.addComponent(grid)\n        page.render()\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/__init__.py": {
        "imported_elements": [
          "logger"
        ],
        "code_map": {}
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "ad_miner/sources/modules/utils.py": {
        "imported_elements": [
          "grid_data_stringify"
        ],
        "code_map": {
          "grid_data_stringify": "def grid_data_stringify(raw_data: dict) -> str:\n    \"\"\"\n    Transform a dict to a string for the grid formating. This is a dumb fix for the sorting with hyperlink.\n    dict format :\n    {\n        \"link\",\n        \"value\",\n        \"before_link\"\n    }\n    \"\"\"\n    link = raw_data['link'].replace(sep, '_').replace('/', '_')\n    try:\n        return f\"{raw_data['before_link']} <a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\"\n    except KeyError:\n        return f\"<a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\""
        }
      },
      "ad_miner/sources/modules/common_analysis.py": {
        "imported_elements": [
          "presence_of",
          ""
        ],
        "code_map": {
          "presence_of": "def presence_of(req, criticity=1, threshold=0):\n    if req is None:\n        return -1\n    if len(req) > threshold:\n        return criticity\n    return 5"
        }
      },
      "/Users/steverassinot/Repos/AD_Miner/urllib/parse/__init__.py": {
        "imported_elements": [
          "quote"
        ],
        "code_map": {}
      }
    },
    "requests_keys": [
      "domains_to_domain_admin",
      "computers_to_domain_admin",
      "groups_to_domain_admin",
      "nb_domain_collected",
      "domains",
      "objects_to_domain_admin",
      "users_to_domain_admin"
    ]
  },
  {
    "title": "RDP access (computers)",
    "file_name": "computers_list_of_rdp_users.py",
    "control_category": "Permissions",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\n\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\nfrom ad_miner.sources.modules.utils import grid_data_stringify\nfrom ad_miner.sources.modules.common_analysis import percentage_superior\n\nfrom urllib.parse import quote\n\n\n@register_control\nclass computers_list_of_rdp_users(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"permissions\"\n        self.control_key = \"computers_list_of_rdp_users\"\n\n        self.title = \"RDP access (computers)\"\n        self.description = (\n            \"Computers which can be accessed with Remote Desktop Protocol (RDP).\"\n        )\n        self.risk = \"For each computer, the lower the number, the better. Overall, the total number of computers with RDP access should be as low as possible. RDP access allows attackers to pivot in the network.\"\n        self.poa = (\n            \"Review this list to ensure RDP access is legitimate on these machines.\"\n        )\n\n        self.users_rdp_access = requests_results[\"rdp_access\"]\n        self.users_rdp_access_2 = (\n            dict(\n                sorted(\n                    self.parseRDPdataByHosts(self.users_rdp_access).items(),\n                    key=lambda x: len(x[1]),\n                    reverse=True,\n                )\n            )\n            if self.users_rdp_access is not None\n            else None\n        )\n        self.users = requests_results[\"nb_enabled_accounts\"]\n\n    def run(self):\n        if self.users_rdp_access_2 is None:\n            return\n        # headers = [\"Computers\", \"Number of users\", \"Users\"]\n        # formated_data = generic_formating.formatGridValues3Columns(\n        #    generic_formating.formatFor3Col(self.users_rdp_access_2, headers),\n        #    headers,\n        #    \"computers_list_of_rdp_users\",\n        # )\n        headers = [\"Computers\", \"Users\"]\n        formated_data = []\n        for key in self.users_rdp_access_2:\n            sortClass = str(len(self.users_rdp_access_2[key])).zfill(6)\n            d = {\n                \"Computers\": '<i class=\"bi bi-pc-display\"></i> ' + key,\n                \"Users\": grid_data_stringify(\n                    {\n                        \"value\": f\"{len(self.users_rdp_access_2[key])} Users <p style='visibility:hidden;'>{self.users_rdp_access_2[key]}</p>\",\n                        \"link\": f\"computers_list_of_rdp_users.html?parameter={quote(str(key))}\",\n                        \"before_link\": f'<i class=\"bi bi-person-fill {sortClass}\"></i>',\n                    }\n                ),\n            }\n            formated_data.append(d)\n        page = Page(\n            self.arguments.cache_prefix,\n            \"computers_list_of_rdp_users\",\n            \"Computers that can be accessed through RDP\",\n            self.get_dico_description(),\n        )\n        grid = Grid(\"Computers' lists of RDP users\")\n        grid.setheaders(headers)\n        grid.setData(formated_data)\n        page.addComponent(grid)\n        page.render()\n\n        self.data = len(self.users_rdp_access_2) if self.users_rdp_access_2 else 0\n        self.name_description = f\"{self.data} computers with RDP access\"\n\n    def get_rating(self) -> int:\n        return percentage_superior(\n            self.users_rdp_access_2, self.users, criticity=3, percentage=0.5\n        )\n\n    def parseRDPdataByHosts(self, list_of_dict):\n        final_dict = {}\n        for dict in list_of_dict:\n            if dict[\"computer\"] in final_dict.keys():\n                final_dict[dict[\"computer\"]] += [dict[\"user\"]]\n            else:\n                final_dict[dict[\"computer\"]] = [dict[\"user\"]]\n        return final_dict\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "ad_miner/sources/modules/utils.py": {
        "imported_elements": [
          "grid_data_stringify"
        ],
        "code_map": {
          "grid_data_stringify": "def grid_data_stringify(raw_data: dict) -> str:\n    \"\"\"\n    Transform a dict to a string for the grid formating. This is a dumb fix for the sorting with hyperlink.\n    dict format :\n    {\n        \"link\",\n        \"value\",\n        \"before_link\"\n    }\n    \"\"\"\n    link = raw_data['link'].replace(sep, '_').replace('/', '_')\n    try:\n        return f\"{raw_data['before_link']} <a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\"\n    except KeyError:\n        return f\"<a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\""
        }
      },
      "ad_miner/sources/modules/common_analysis.py": {
        "imported_elements": [
          "percentage_superior"
        ],
        "code_map": {
          "percentage_superior": "def percentage_superior(req, base, criticity=1, percentage=0, presence=False):\n    if req is None:\n        return -1\n    if base is None:\n        return -1\n    if len(base) == 0:\n        return -1\n\n    if len(base) and len(req) / len(base) > percentage:\n        return criticity\n\n    if presence:\n        if len(req) > 0:\n            return criticity + 1\n    return 5"
        }
      },
      "/Users/steverassinot/Repos/AD_Miner/urllib/parse/__init__.py": {
        "imported_elements": [
          "quote"
        ],
        "code_map": {}
      }
    },
    "requests_keys": [
      "rdp_access",
      "nb_enabled_accounts"
    ]
  },
  {
    "title": "Password requirement bypass",
    "file_name": "users_password_not_required.py",
    "control_category": "Passwords",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\n\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\n\nfrom ad_miner.sources.modules.utils import days_format\nfrom ad_miner.sources.modules.common_analysis import presence_of\n\n\n@register_control\nclass users_password_not_required(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"passwords\"\n        self.control_key = \"users_password_not_required\"\n\n        self.title = \"Password requirement bypass\"\n        self.description = \"Those users have the attribute 'Password not required'. This attribute technically allows the account to accept blank password to be set and even override the password policy of the company.\"\n        self.risk = \"Such misconfiguration could lead to some account having non compliant password such as a blank or weak password and might be easier to compromise.\"\n        self.poa = \"Ensure that this list is empty by setting the ms-DS-User-Password-Not-Required attribute to false for every user.\"\n\n        self.users_password_not_required = requests_results[\n            \"get_users_password_not_required\"\n        ]\n\n    def run(self):\n        if self.users_password_not_required is None:\n            self.users_password_not_required = []\n            return\n        page = Page(\n            self.arguments.cache_prefix,\n            \"users_password_not_required\",\n            \"Users that can bypass your password policy\",\n            self.get_dico_description(),\n        )\n        grid_data = []\n        for dic in self.users_password_not_required:\n            tmp_data = {}\n            tmp_data[\"Domain\"] = '<i class=\"bi bi-globe2\"></i> ' + dic[\"domain\"]\n            tmp_data[\"User\"] = '<i class=\"bi bi-person-fill\"></i> ' + dic[\"user\"]\n            tmp_data[\"Password last change\"] = days_format(dic[\"pwdlastset\"])\n            tmp_data[\"Last logon\"] = days_format(dic[\"lastlogon\"])\n            grid_data.append(tmp_data)\n        grid = Grid(\"Users that can bypass your password policy\")\n        grid.setheaders([\"Domain\", \"User\", \"Password last change\", \"Last logon\"])\n        grid.setData(grid_data)\n        page.addComponent(grid)\n        page.render()\n\n        self.data = len(self.users_password_not_required)\n\n        self.name_description = f\"{self.data} users without password requirement\"\n\n    def get_rating(self) -> int:\n        return presence_of(self.users_password_not_required, 3)\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "ad_miner/sources/modules/utils.py": {
        "imported_elements": [
          "days_format"
        ],
        "code_map": {
          "days_format": "def days_format(nb_days: int, critical_time=90) -> str:\n    \"\"\"\n    Returns the date in a nice format\n    \"\"\"\n\n    critical_time = int(critical_time)\n\n    sortClass = str(nb_days).zfill(6)\n    if nb_days is None:\n        return f\"<i class='{sortClass} bi bi-x-circle' style='color: rgb(255, 89, 94);'></i> Unknown\"\n    if nb_days > 19000:\n        return f\"<i class='{sortClass} bi bi-x-circle' style='color: rgb(255, 89, 94);'></i> Never\"\n    y = nb_days // 365\n    m = (nb_days % 365) // 30\n    d = (nb_days % 365) % 30\n\n    color = \"#b00404\" if nb_days > 2 * critical_time else \"#e36402\" if nb_days > critical_time else \"#0a6e01\"\n\n    if y > 0:\n        return f\"<i class='{sortClass} bi bi-calendar3' style='color: {color};'></i> {y} year{'s' if y > 1 else ''}, {m} month{'s' if m > 1 else ''} and {d} day{'s' if d > 1 else ''}\"\n    elif m > 0:\n        return f\"<i class='{sortClass} bi bi-calendar3' style='color: {color};'></i> {m} month{'s' if m > 1 else ''} and {d} day{'s' if d > 1 else ''}\"\n    else:\n        return f\"<i class='{sortClass} bi bi-calendar3' style='color: {color};'></i> {d} day{'s' if d > 1 else ''}\""
        }
      },
      "ad_miner/sources/modules/common_analysis.py": {
        "imported_elements": [
          "presence_of"
        ],
        "code_map": {
          "presence_of": "def presence_of(req, criticity=1, threshold=0):\n    if req is None:\n        return -1\n    if len(req) > threshold:\n        return criticity\n    return 5"
        }
      }
    },
    "requests_keys": [
      "get_users_password_not_required"
    ]
  },
  {
    "title": "Kerberos constrained delegation",
    "file_name": "users_constrained_delegations.py",
    "control_category": "Kerberos",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\n\nfrom ad_miner.sources.modules import generic_formating\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\nfrom ad_miner.sources.modules.common_analysis import parseConstrainedData\n\nimport json\n\n\n@register_control\nclass users_constrained_delegations(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"kerberos\"\n        self.control_key = \"users_constrained_delegations\"\n\n        self.title = \"Kerberos constrained delegation\"\n        self.description = \"These accounts have constrained delegations privileges.\"\n        self.risk = \"Accounts that have constrained delegation rights can impersonate any user against a determined service. This means that this service will trust the accounts with whatever identity is presented. Compromission of an account with constrained delegation would allow the attacker to progress deeper in the information system and further compromise the domain.\"\n        self.poa = \"Set the accounts that should not be impersonated as 'Protected users' so the service cannot be abused to use their identity. Set the MachineAccountQuota to 0 if possible, so that attackers cannot create eligible accounts for constrained delegations.\"\n\n        self.users_constrained_delegations = requests_results[\n            \"users_constrained_delegations\"\n        ]\n\n        if self.users_constrained_delegations is not None:\n            self.users_constrained_delegations = dict(\n                sorted(\n                    parseConstrainedData(self.users_constrained_delegations).items(),\n                    key=lambda x: len(x[1]),\n                    reverse=True,\n                )\n            )\n\n    def run(self):\n        if self.users_constrained_delegations is None:\n            return\n        headers = [\"Users\", \"Number of computers\", \"Computers\"]\n        formated_data = generic_formating.formatGridValues3Columns(\n            generic_formating.formatFor3Col(\n                self.users_constrained_delegations, headers\n            ),\n            headers,\n            \"users_constrained_delegations\",\n        )\n        page = Page(\n            self.arguments.cache_prefix,\n            \"users_constrained_delegations\",\n            \"Users with constrained delegations\",\n            self.get_dico_description(),\n        )\n        grid = Grid(\"Users with constrained delegations\")\n        grid.setheaders(headers)\n        grid.setData(json.dumps(formated_data))\n        page.addComponent(grid)\n        page.render()\n\n        self.data = (\n            len(self.users_constrained_delegations)\n            if self.users_constrained_delegations\n            else 0\n        )\n\n        self.name_description = (\n            f\"{self.data} users with Kerberos constrained delegations\"\n        )\n\n    def get_rating(self) -> int:\n        req = self.users_constrained_delegations\n        if req is None:\n            return -1\n        for object in req:\n            if type(object) == str:\n                return -1\n            if object[\"to_DC\"] == True:\n                return 2\n\n        if len(req) > 0:\n            return 3\n\n        return 5\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/__init__.py": {
        "imported_elements": [
          "generic_formating"
        ],
        "code_map": {}
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "ad_miner/sources/modules/common_analysis.py": {
        "imported_elements": [
          "parseConstrainedData"
        ],
        "code_map": {
          "parseConstrainedData": "def parseConstrainedData(list_of_dict):\n    final_dict = {}\n    for dict in list_of_dict:\n        if dict[\"name\"] in final_dict.keys():\n            final_dict[dict[\"name\"]] += [dict[\"computer\"]]\n        else:\n            final_dict[dict[\"name\"]] = [dict[\"computer\"]]\n    return final_dict"
        }
      }
    },
    "requests_keys": [
      "users_constrained_delegations"
    ]
  },
  {
    "title": "Inadequate access to DCSync privileges",
    "file_name": "can_dcsync.py",
    "control_category": "Permissions",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\n\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\nfrom ad_miner.sources.modules.graph_class import Graph\nfrom ad_miner.sources.modules.utils import grid_data_stringify\nfrom ad_miner.sources.modules.common_analysis import presence_of\n\nfrom urllib.parse import quote\n\n\n@register_control\nclass can_dcsync(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"permissions\"\n        self.control_key = \"can_dcsync\"\n\n        self.title = \"Inadequate access to DCSync privileges\"\n        self.description = \"All these domain objects are granted DCSync privileges and can, as such, dump all data from Active Directory\"\n        self.risk = \"Only servers that require DCSync should have this privilege. A misconfiguration of DCSync privilege could result in the dump of all data in the AD (including, users and password hashes).\"\n        self.poa = \"Review this list and check for any anomaly.\"\n\n        self.dico_name_description_can_dcsync_graph = {\n            \"description\": \"List of paths to a dcsync account.\",\n            \"risk\": \"These paths lead to accounts that have DCSync privileges. If one of these paths is exploited, the attacker will be able to dump all data from Active Directory (including users and machines password hashes). \",\n            \"poa\": \"Review the paths, make sure they are not exploitable. If they are, cut the link between the Active Directory objects in order to reduce the attack surface.\",\n        }\n\n        self.objects_to_dcsync = requests_results[\"objects_to_dcsync\"]\n        self.dcsync_list = requests_results[\"dcsync_list\"]\n        self.users_nb_domain_admins = requests_results[\"nb_domain_admins\"]\n\n        self.dcsync_paths = (\n            requests_results[\"set_dcsync1\"] + requests_results[\"set_dcsync2\"]\n        )\n        end_nodes = []\n\n        # Check if dcsync path is activated or not\n        if self.objects_to_dcsync == None:\n            # Placeholder to fill the list for the rating\n            self.can_dcsync_nodes = [\"1\"] * len(self.dcsync_list)\n        else:\n            for p in self.objects_to_dcsync:\n                end_nodes.append(p.nodes[-1])  # Get last node of the path\n            end_nodes = list(set(end_nodes))\n\n            self.can_dcsync_nodes = end_nodes\n\n    def run(self):\n        if self.objects_to_dcsync == None:\n            self.genNodesDCsyncLightPage()\n        else:\n            self.genFullDCSync()\n\n        self.data = len(self.can_dcsync_nodes) if self.can_dcsync_nodes else 0\n\n        self.name_description = f\"{self.data} non DA/DC objects have DCSync privileges\"\n\n    def genFullDCSync(self):\n\n        data = []\n        for n in self.can_dcsync_nodes:\n            # Graph path to DCSync\n            page = Page(\n                self.arguments.cache_prefix,\n                f\"path_to_{n.name}_with_dcsync\",\n                f\"DCsync path for {n.name}\",\n                self.dico_name_description_can_dcsync_graph,\n            )\n            graph = Graph()\n\n            paths_left = []\n            for path in self.objects_to_dcsync:\n                if path.nodes[-1].name == n.name:\n                    paths_left.append(path)\n\n            graph.setPaths(paths_left)\n            page.addComponent(graph)\n            page.render()\n\n            # Graph DCSync detail\n            page = Page(\n                self.arguments.cache_prefix,\n                f\"dcsync_from_{n.name}\",\n                f\"DCSync detail for {n.name}\",\n                self.dico_name_description_can_dcsync_graph,\n            )\n            graph = Graph()\n\n            paths_right = []\n            for path in self.dcsync_paths:\n                if path.nodes[0].name == n.name:\n                    paths_right.append(path)\n\n            graph.setPaths(paths_right)\n            page.addComponent(graph)\n            page.render()\n\n            if n.labels.lower() == \"user\":\n                type_icon = '<i class=\"bi bi-person-fill\"></i>'\n            elif n.labels.lower() == \"group\":\n                type_icon = '<i class=\"bi bi-people-fill\"></i>'\n            else:\n                type_icon = '<i class=\"bi bi-question-circle-fill\"></i>'\n\n            if n.name in self.users_nb_domain_admins:\n                name_icon = '<i class=\"bi bi-gem stats-icon\"></i>'\n            else:\n                name_icon = type_icon\n\n            sortClass = str(len(paths_left)).zfill(6)\n            data.append(\n                {\n                    \"domain\": '<i class=\"bi bi-globe2\"></i> ' + n.domain,\n                    \"type\": type_icon + \" \" + n.labels,\n                    \"name\": name_icon + \" \" + n.name,\n                    \"path to account\": grid_data_stringify(\n                        {\n                            \"link\": \"path_to_%s_with_dcsync.html\" % quote(str(n.name)),\n                            \"value\": f\"{len(paths_left)} paths\",\n                            \"before_link\": f\"<i class='bi bi-shuffle {sortClass}' aria-hidden='true'></i>\",\n                        }\n                    ),\n                    \"path to dcsync\": grid_data_stringify(\n                        {\n                            \"link\": \"dcsync_from_%s.html\" % quote(str(n.name)),\n                            \"value\": f\"DCSync path\",\n                            \"before_link\": f\"<i class='bi bi-shuffle {sortClass}' aria-hidden='true'></i>\",\n                        }\n                    ),\n                }\n            )\n\n        page = Page(\n            self.arguments.cache_prefix,\n            \"can_dcsync\",\n            \"Inadequate access to DCSync privileges\",\n            self.get_dico_description(),\n        )\n        grid = Grid(\"DCsync objects\")\n        headers = [\"domain\", \"type\", \"name\", \"path to account\", \"path to dcsync\"]\n        grid.setheaders(headers)\n        grid.setData(data)\n        page.addComponent(grid)\n        page.render()\n\n    def genNodesDCsyncLightPage(self, neo4j):\n        page = Page(\n            self.arguments.cache_prefix,\n            \"can_dcsync\",\n            \"Inadequate access to DCSync privileges\",\n            self.get_dico_description(),\n        )\n        paths = (\n            neo4j.all_requests[\"set_dcsync1\"][\"result\"]\n            + neo4j.all_requests[\"set_dcsync2\"][\"result\"]\n        )\n        raw_data = {}\n        for e in self.dcsync_list:\n            raw_data[e[\"name\"]] = {\n                \"domain\": e[\"domain\"],\n                \"name\": e[\"name\"],\n                \"target graph\": {},\n                \"paths\": [],\n            }\n        for path in paths:\n            try:\n                raw_data[path.nodes[0].name][\"paths\"].append(path)\n            except KeyError:\n                continue\n        data = []\n        # print(raw_data)\n        for k in raw_data.keys():\n            graph_page = Page(\n                self.arguments.cache_prefix,\n                f\"can_dcsync_from_{raw_data[k]['name']}\",\n                f\"DCSync from {raw_data[k]['name']}\",\n                self.get_dico_description(),\n            )\n            graph = Graph()\n            graph.setPaths(raw_data[k][\"paths\"])\n            graph_page.addComponent(graph)\n            graph_page.render()\n            sortClass = str(len(raw_data[k][\"paths\"])).zfill(6)\n            raw_data[k][\"target graph\"][\n                \"link\"\n            ] = f\"can_dcsync_from_{quote(str(raw_data[k]['name']))}.html\"\n            raw_data[k][\"target graph\"][\n                \"value\"\n            ] = f\"<i class='bi bi-shuffle {sortClass}' aria-hidden='true'></i> View paths ({len(raw_data[k]['paths'])})\"\n            data.append(\n                {\n                    \"domain\": raw_data[k][\"domain\"],\n                    \"name\": raw_data[k][\"name\"],\n                    \"target graph\": raw_data[k][\"target graph\"],\n                }\n            )\n        grid = Grid(\"DCsync objects\")\n        headers = [\"domain\", \"name\", \"target graph\"]\n        grid.setheaders(headers)\n        grid.setData(data)\n        page.addComponent(grid)\n        page.render()\n\n    def get_rating(self) -> int:\n        return presence_of(self.can_dcsync_nodes)\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "ad_miner/sources/modules/graph_class.py": {
        "imported_elements": [
          "Graph"
        ],
        "code_map": {
          "Graph": "class Graph:\n    def __init__(self, template=\"graph\", path_limit=80000):\n        self.template_base_path = HTML_DIRECTORY / \"components/graph/\"\n        self.template = template\n        self.paths = []\n        self.nodes = {}\n        self.relations = []\n        self.relations_hashes = {}\n        self.path_limit = path_limit\n        self.ghost_computer = {}\n        self.ghost_user = {}\n        self.dc_computer = {}\n        self.user_da = {}\n        self.group_da = {}\n        self.enabled_users = {}\n        self.kerberoastable_users = {}\n        self.disabled_users_dict = {}\n\n    def addPath(self, path):\n        self.paths.append(path)\n\n    def setPaths(self, paths):\n        self.paths = paths\n\n    def addGhostComputers(self, ghost_computer):\n        self.ghost_computer = ghost_computer\n\n    def addGhostUsers(self, ghost_user):\n        self.ghost_user = ghost_user\n\n    def addDCComputers(self, dc_computer):\n        self.dc_computer = dc_computer\n\n    def addUserDA(self, user_da):\n        self.user_da = user_da\n\n    def addGroupDA(self, group_da):\n        self.group_da = group_da\n\n    def addDisabledUsers(self, disabled_users):\n        self.disabled_users_dict = {}\n        for d in disabled_users:\n            self.disabled_users_dict[d[\"name\"]] = True\n\n    def addKerberoastableUsers(self, kerberoastable_users):\n        self.kerberoastable_users = kerberoastable_users\n\n    def render(self, page_f):\n\n        # Write header\n        with open(\n            self.template_base_path / (self.template + \"_header.html\"), \"r\"\n        ) as header_f:\n            html_header = header_f.read()\n            page_f.write(html_header)\n\n        for index, path in enumerate(self.paths):\n            for i in range(len(path.nodes)):\n\n                node = path.nodes[i]\n\n                # Compute node style\n                if i == 0:\n                    node_position = \"start\"\n                elif i == len(path.nodes) - 1:\n                    node_position = \"end\"\n                else:\n                    node_position = \"intermediate\"\n\n                # Add new labels here. A corresponding svg icon should be defined\n                # dico_icon in the icon.js file.\n                list_labels = [\n                    \"User\",\n                    \"Foreignsecurityprincipal\",\n                    \"GPO\",\n                    \"Computer\",\n                    \"OU\",\n                    \"Group\",\n                    \"Domain\",\n                    \"ADLocalGroup\",\n                    \"Container\",\n                    \"Unknown\",\n                    \"Group_cluster\",\n                    \"Device\",\n                    \"AZTenant\",\n                    \"AZRole\",\n                ]\n\n                if node.labels in list_labels:\n                    label_instance = node.labels\n                elif path.nodes[i].labels[2:] in list_labels:\n                    label_instance = node.labels[2:]\n                else:\n                    label_instance = \"Unknown\"\n\n                node_attributes = []\n\n                # Add DA icon if node is DC, DA or Domain\n                if (\n                    (\n                        label_instance == \"Computer\"\n                        and self.dc_computer.get(node.name, False)\n                    )\n                    or (label_instance == \"User\" and self.user_da.get(node.name, False))\n                    or (\n                        label_instance == \"Group\"\n                        and self.group_da.get(node.name, False)\n                    )\n                    or label_instance == \"Domain\"\n                ):\n                    node_attributes.append(\"da\")\n\n                # Add ghost icon if ghost\n                if (\n                    label_instance == \"User\" and self.ghost_user.get(node.name, False)\n                ) or (\n                    label_instance == \"Computer\"\n                    and self.ghost_computer.get(node.name, False)\n                ):\n                    node_attributes.append(\"ghost\")\n\n                if label_instance == \"User\" and self.disabled_users_dict.get(\n                    node.name, False\n                ):\n                    node_attributes.append(\"disabled\")\n\n                if label_instance == \"User\" and self.kerberoastable_users.get(\n                    node.name, False\n                ):\n                    node_attributes.append(\"kerberoastable\")\n\n                # New nodes attributes that should be added to the node icon\n                # should be added here to the node_attributes list.\n                # A corresponding svg icon should the be added to the\n                # dico_icon in icon.js\n\n                if not self.nodes.get(path.nodes[i].id):\n\n                    final_graph_node = {\n                        \"id\": path.nodes[i].id,\n                        \"label\": path.nodes[i].name,\n                        \"domain\": path.nodes[i].domain,\n                        \"shape\": \"image\",\n                        \"instance\": label_instance,\n                        \"position\": node_position,\n                        \"attributes\": node_attributes,\n                    }\n                    self.nodes[path.nodes[i].id] = final_graph_node\n\n                if i != 0:\n                    relation = {\n                        \"from\": path.nodes[i - 1].id,\n                        \"to\": path.nodes[i].id,\n                        \"label\": path.nodes[i - 1].relation_type,\n                    }\n\n                    # Avoid relation duplicated to keep graph clean\n                    # Use hashes list for better performance\n                    hash_rel = hash(\n                        str(relation[\"from\"])\n                        + str(relation[\"to\"])\n                        + str(relation[\"label\"])\n                    )\n                    if not self.relations_hashes.get(hash_rel):\n                        self.relations.append(relation)\n                        self.relations_hashes[hash_rel] = True\n\n        nodes = list(self.nodes.values())\n        for n in nodes:  # Sanitize None values (otherwise it creates a bug in JS)\n            if n[\"label\"] == None:\n                n[\"label\"] = \"???\"\n        page_f.write(f'<script type=\"text/javascript\">window.data_nodes = {nodes};\\n')\n        page_f.write(f\"window.data_edges = {self.relations};</script>\\n\")"
        }
      },
      "ad_miner/sources/modules/utils.py": {
        "imported_elements": [
          "grid_data_stringify"
        ],
        "code_map": {
          "grid_data_stringify": "def grid_data_stringify(raw_data: dict) -> str:\n    \"\"\"\n    Transform a dict to a string for the grid formating. This is a dumb fix for the sorting with hyperlink.\n    dict format :\n    {\n        \"link\",\n        \"value\",\n        \"before_link\"\n    }\n    \"\"\"\n    link = raw_data['link'].replace(sep, '_').replace('/', '_')\n    try:\n        return f\"{raw_data['before_link']} <a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\"\n    except KeyError:\n        return f\"<a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\""
        }
      },
      "ad_miner/sources/modules/common_analysis.py": {
        "imported_elements": [
          "presence_of"
        ],
        "code_map": {
          "presence_of": "def presence_of(req, criticity=1, threshold=0):\n    if req is None:\n        return -1\n    if len(req) > threshold:\n        return criticity\n    return 5"
        }
      },
      "/Users/steverassinot/Repos/AD_Miner/urllib/parse/__init__.py": {
        "imported_elements": [
          "quote"
        ],
        "code_map": {}
      }
    },
    "requests_keys": [
      "set_dcsync1",
      "objects_to_dcsync",
      "dcsync_list",
      "nb_domain_admins",
      "set_dcsync2"
    ]
  },
  {
    "title": "Computers without LAPS",
    "file_name": "computers_without_laps.py",
    "control_category": "Passwords",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\n\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\n\nfrom ad_miner.sources.modules.utils import days_format\n\n\n@register_control\nclass computers_without_laps(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"passwords\"\n        self.control_key = \"computers_without_laps\"\n\n        self.title = \"Computers without LAPS\"\n        self.description = \"Microsoft Local Administrator Password Solution (LAPS) allows local admnistrators to manage different passwords on local administrator accounts.\"\n        self.risk = \"The more computers are configured with LAPS, the better, especially on critical servers/machines. Without LAPS, it becomes tedious to have different passwords on local administrator for different computers, resulting in reuse of passwords and a risk of lateral movement.\"\n        self.poa = \"LAPS is a good tool to use, consider installing it or expanding its usage to more computers.\"\n\n        self.computers_nb_has_laps = requests_results[\"nb_computers_laps\"]\n        self.list_total_computers = requests_results[\"nb_computers\"]\n\n    def run(self):\n        if self.computers_nb_has_laps is None:\n            return\n\n        if len(self.list_total_computers) != 0:\n            stat_LAPS = round(\n                100\n                * len(\n                    [\n                        computer_has_laps\n                        for computer_has_laps in self.computers_nb_has_laps\n                        if \"ENABLED\" in computer_has_laps[\"LAPS\"].upper()\n                        or \"TRUE\" in computer_has_laps[\"LAPS\"].upper()\n                    ]\n                )\n                / (len(self.computers_nb_has_laps) + 0.001)\n            )\n\n        else:\n            stat_LAPS = 0\n        self.stat_laps = 100 - stat_LAPS\n\n        page = Page(\n            self.arguments.cache_prefix,\n            \"computers_without_laps\",\n            \"Computers' LAPS status\",\n            self.get_dico_description(),\n        )\n        grid = Grid(\"Computers with LAPS\")\n        grid.setheaders([\"domain\", \"name\", \"LAPS\", \"Last logon\"])\n\n        cleaned_data = []\n        for computer in self.computers_nb_has_laps:\n            tmp_dict = {}\n            # If value is None\n            if not computer.get(\"lastLogon\"):\n                continue\n            # Exclude ghost computers (last logon > 90 days)\n            if computer[\"lastLogon\"] < 90:\n                tmp_dict[\"domain\"] = (\n                    '<i class=\"bi bi-globe2\"></i> ' + computer[\"domain\"]\n                )\n                tmp_dict[\"Last logon\"] = days_format(computer[\"lastLogon\"])\n                tmp_dict[\"name\"] = (\n                    '<i class=\"bi bi-pc-display\"></i> ' + computer[\"name\"]\n                )\n                if computer[\"LAPS\"] == \"false\":\n                    tmp_dict[\"LAPS\"] = (\n                        '<i class=\"bi bi-unlock-fill text-danger\"></i> Disabled'\n                    )\n                else:\n                    tmp_dict[\"LAPS\"] = (\n                        '<i class=\"bi bi-lock-fill text-success\"></i> Enabled'\n                    )\n                cleaned_data.append(tmp_dict)\n        self.computers_nb_has_laps = cleaned_data\n        grid.setData(cleaned_data)\n        page.addComponent(grid)\n        page.render()\n\n        self.data = self.stat_laps if self.stat_laps else 0\n\n        self.name_description = f\"{self.data} % computers without LAPS\"\n\n    def get_rating(self) -> int:\n        return 4 if self.stat_laps < 20 else 3\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "ad_miner/sources/modules/utils.py": {
        "imported_elements": [
          "days_format"
        ],
        "code_map": {
          "days_format": "def days_format(nb_days: int, critical_time=90) -> str:\n    \"\"\"\n    Returns the date in a nice format\n    \"\"\"\n\n    critical_time = int(critical_time)\n\n    sortClass = str(nb_days).zfill(6)\n    if nb_days is None:\n        return f\"<i class='{sortClass} bi bi-x-circle' style='color: rgb(255, 89, 94);'></i> Unknown\"\n    if nb_days > 19000:\n        return f\"<i class='{sortClass} bi bi-x-circle' style='color: rgb(255, 89, 94);'></i> Never\"\n    y = nb_days // 365\n    m = (nb_days % 365) // 30\n    d = (nb_days % 365) % 30\n\n    color = \"#b00404\" if nb_days > 2 * critical_time else \"#e36402\" if nb_days > critical_time else \"#0a6e01\"\n\n    if y > 0:\n        return f\"<i class='{sortClass} bi bi-calendar3' style='color: {color};'></i> {y} year{'s' if y > 1 else ''}, {m} month{'s' if m > 1 else ''} and {d} day{'s' if d > 1 else ''}\"\n    elif m > 0:\n        return f\"<i class='{sortClass} bi bi-calendar3' style='color: {color};'></i> {m} month{'s' if m > 1 else ''} and {d} day{'s' if d > 1 else ''}\"\n    else:\n        return f\"<i class='{sortClass} bi bi-calendar3' style='color: {color};'></i> {d} day{'s' if d > 1 else ''}\""
        }
      }
    },
    "requests_keys": [
      "nb_computers",
      "nb_computers_laps"
    ]
  },
  {
    "title": "Groups without any member",
    "file_name": "empty_groups.py",
    "control_category": "Misc",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\n\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\n\n\n@register_control\nclass empty_groups(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"misc\"\n        self.control_key = \"empty_groups\"\n\n        self.title = \"Groups without any member\"\n        self.description = \"These groups do not contain any user, computer or any other group, which probably means they are not used anymore.\"\n        self.risk = \"As unused groups still retain their privilege but are less monitored, an attacker could exploit one of these to gain further access to the information system.\"\n        self.poa = \"Review these groups and check wether they should have lesser privilege or be deleted.\"\n\n        self.empty_groups = requests_results[\"get_empty_groups\"]\n        self.groups = requests_results[\"nb_groups\"]\n\n    def run(self):\n        page = Page(\n            self.arguments.cache_prefix,\n            \"empty_groups\",\n            \"Groups with no object\",\n            self.get_dico_description(),\n        )\n        grid = Grid(\"Groups without any object in it\")\n        headers = [\"Empty group\", \"Full Reference\"]\n\n        for d in self.empty_groups:\n            d[\"Empty group\"] = '<i class=\"bi bi-people-fill\"></i> ' + d[\"Empty group\"]\n\n        grid.setheaders(headers)\n        grid.setData(self.empty_groups)\n\n        page.addComponent(grid)\n        page.render()\n\n        self.data = len(self.empty_groups)\n        self.name_description = f\"{self.data} groups without any member\"\n\n    def get_rating(self) -> int:\n        if len(self.groups) > 0:\n            return (\n                2\n                if len(self.empty_groups) / len(self.groups) > 0.40\n                else 3 if len(self.empty_groups) / len(self.groups) > 0.20 else 5\n            )\n        return -1\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      }
    },
    "requests_keys": [
      "nb_groups",
      "get_empty_groups"
    ]
  },
  {
    "title": "Users with old passwords",
    "file_name": "users_pwd_not_changed_since.py",
    "control_category": "Passwords",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\n\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\n\nfrom ad_miner.sources.modules.utils import days_format\nfrom ad_miner.sources.modules.common_analysis import percentage_superior\n\n\n@register_control\nclass users_pwd_not_changed_since(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"passwords\"\n\n        self.control_key = \"users_pwd_not_changed_since\"\n\n        self.title = \"Users with old passwords\"\n        self.description = (\n            \"These accounts have not changed their password for a long period of time.\"\n        )\n        self.risk = \"Users should regularily change their passwords. This list should be as reduced as possible. Users not changing their password could be a securtiy flaw if these passwords happend to leak.\"\n        self.poa = (\n            \"Make sure your GPO asks for password renewal and that it is enforced.\"\n        )\n\n        self.users_pwd_not_changed_since = requests_results[\"password_last_change\"]\n\n        self.users_pwd_not_changed_since_3months = (\n            [\n                user\n                for user in self.users_pwd_not_changed_since\n                if user[\"days\"] > int(self.arguments.renewal_password)\n            ]\n            if self.users_pwd_not_changed_since is not None\n            else None\n        )\n\n        self.users_nb_domain_admins = requests_results[\"nb_domain_admins\"]\n\n        self.users = requests_results[\"nb_enabled_accounts\"]\n        self.admin_list = []\n        for admin in self.users_nb_domain_admins:\n            self.admin_list.append(admin[\"name\"])\n\n    def run(self):\n        if self.users_pwd_not_changed_since_3months is None:\n            return\n        page = Page(\n            self.arguments.cache_prefix,\n            \"users_pwd_not_changed_since\",\n            f\"Number of users with password not changed for at least {self.arguments.renewal_password} days\",\n            self.get_dico_description(),\n        )\n        grid = Grid(\"Users with password not changed > 3 months\")\n        # grid.setheaders([\"user\", \"days\"])\n        # grid.setData(self.users_pwd_not_changed_since_3months)\n\n        # Human readable display\n        grid.setheaders([\"user\", \"Last password change\", \"Account Creation Date\"])\n        data = []\n        for dict in self.users_pwd_not_changed_since_3months:\n            tmp_data = {\"user\": dict[\"user\"]}\n            if dict[\"user\"] in self.admin_list:\n                tmp_data[\"user\"] = (\n                    '<i class=\"bi bi-gem\" title=\"This user is domain admin\"></i> '\n                    + tmp_data[\"user\"]\n                )\n            else:\n                tmp_data[\"user\"] = (\n                    '<i class=\"bi bi-person-fill\"></i> ' + tmp_data[\"user\"]\n                )\n            tmp_data[\"Last password change\"] = days_format(dict[\"days\"])\n            tmp_data[\"Account Creation Date\"] = days_format(dict[\"accountCreationDate\"])\n\n            data.append(tmp_data)\n        grid.setData(data)\n        page.addComponent(grid)\n        page.render()\n\n        # TODO define the metric of your control\n        # it will be stored in the data json\n        self.data = (\n            len(self.users_pwd_not_changed_since_3months)\n            if self.users_pwd_not_changed_since_3months\n            else 0\n        )\n\n        self.name_description = f\"{self.data} unchanged passwords > {int(int(self.arguments.renewal_password)/30)} months\"\n\n    def get_rating(self) -> int:\n        return percentage_superior(\n            self.users_pwd_not_changed_since_3months,\n            self.users,\n            criticity=3,\n            percentage=0.1,\n            presence=True,\n        )\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "ad_miner/sources/modules/utils.py": {
        "imported_elements": [
          "days_format"
        ],
        "code_map": {
          "days_format": "def days_format(nb_days: int, critical_time=90) -> str:\n    \"\"\"\n    Returns the date in a nice format\n    \"\"\"\n\n    critical_time = int(critical_time)\n\n    sortClass = str(nb_days).zfill(6)\n    if nb_days is None:\n        return f\"<i class='{sortClass} bi bi-x-circle' style='color: rgb(255, 89, 94);'></i> Unknown\"\n    if nb_days > 19000:\n        return f\"<i class='{sortClass} bi bi-x-circle' style='color: rgb(255, 89, 94);'></i> Never\"\n    y = nb_days // 365\n    m = (nb_days % 365) // 30\n    d = (nb_days % 365) % 30\n\n    color = \"#b00404\" if nb_days > 2 * critical_time else \"#e36402\" if nb_days > critical_time else \"#0a6e01\"\n\n    if y > 0:\n        return f\"<i class='{sortClass} bi bi-calendar3' style='color: {color};'></i> {y} year{'s' if y > 1 else ''}, {m} month{'s' if m > 1 else ''} and {d} day{'s' if d > 1 else ''}\"\n    elif m > 0:\n        return f\"<i class='{sortClass} bi bi-calendar3' style='color: {color};'></i> {m} month{'s' if m > 1 else ''} and {d} day{'s' if d > 1 else ''}\"\n    else:\n        return f\"<i class='{sortClass} bi bi-calendar3' style='color: {color};'></i> {d} day{'s' if d > 1 else ''}\""
        }
      },
      "ad_miner/sources/modules/common_analysis.py": {
        "imported_elements": [
          "percentage_superior"
        ],
        "code_map": {
          "percentage_superior": "def percentage_superior(req, base, criticity=1, percentage=0, presence=False):\n    if req is None:\n        return -1\n    if base is None:\n        return -1\n    if len(base) == 0:\n        return -1\n\n    if len(base) and len(req) / len(base) > percentage:\n        return criticity\n\n    if presence:\n        if len(req) > 0:\n            return criticity + 1\n    return 5"
        }
      }
    },
    "requests_keys": [
      "nb_domain_admins",
      "nb_enabled_accounts",
      "password_last_change"
    ]
  },
  {
    "title": "Paths to DNS Admins",
    "file_name": "unpriv_to_dnsadmins.py",
    "control_category": "Permissions",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\n\nfrom ad_miner.sources.modules.common_analysis import presence_of, createGraphPage\n\n\n@register_control\nclass unpriv_to_dnsadmins(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"permissions\"\n        self.control_key = \"unpriv_to_dnsadmins\"\n\n        self.title = \"Paths to DNS Admins\"\n        self.description = (\n            \"Users can take over DNS Admins group, leading to domain compromission.\"\n        )\n\n        self.unpriv_to_dnsadmins = requests_results[\"unpriv_to_dnsadmins\"]\n\n    def run(self):\n        createGraphPage(\n            self.arguments.cache_prefix,\n            \"unpriv_to_dnsadmins\",\n            \"Unprivileged users with path to DNSAdmins\",\n            self.get_dico_description(),\n            self.unpriv_to_dnsadmins,\n            self.requests_results,\n        )\n\n        self.data = len(self.unpriv_to_dnsadmins) if self.unpriv_to_dnsadmins else 0\n        self.name_description = f\"{self.data} paths to DNSAdmins group\"\n\n    def get_rating(self) -> int:\n        return presence_of(self.unpriv_to_dnsadmins, criticity=2)\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/common_analysis.py": {
        "imported_elements": [
          "presence_of",
          ""
        ],
        "code_map": {
          "presence_of": "def presence_of(req, criticity=1, threshold=0):\n    if req is None:\n        return -1\n    if len(req) > threshold:\n        return criticity\n    return 5"
        }
      }
    },
    "requests_keys": [
      "unpriv_to_dnsadmins"
    ]
  },
  {
    "title": "Inadequate AdminCount settings",
    "file_name": "up_to_date_admincount.py",
    "control_category": "Permissions",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\n\n\n@register_control\nclass up_to_date_admincount(Control):\n    \"Docstring of my control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"permissions\"\n        self.control_key = \"up_to_date_admincount\"\n\n        self.title = \"Inadequate AdminCount settings\"\n        self.description = \"Discrepancies in 'adminCount' attribute for accounts\"\n        self.risk = \"Potential security oversight leading to unauthorized access, privilege misrepresentation, or unintended privilege escalation.\"\n        self.poa = \"Consistently audit and rectify any discrepancies in the `adminCount` attribute settings for all accounts, ensuring it aligns with actual privilege levels.\"\n\n        self.users_nb_domain_admins = requests_results[\"nb_domain_admins\"]\n        self.unpriviledged_users_with_admincount = requests_results[\n            \"unpriviledged_users_with_admincount\"\n        ]\n\n    def run(self):\n        if self.users_nb_domain_admins is None:\n            self.users_nb_domain_admins = []\n        if self.unpriviledged_users_with_admincount is None:\n            self.unpriviledged_users_with_admincount = []\n        page = Page(\n            self.arguments.cache_prefix,\n            \"up_to_date_admincount\",\n            \"Inadequate AdminCount settings\",\n            self.get_dico_description(),\n        )\n        grid = Grid(\"Inadequate AdminCount settings\")\n        grid.setheaders(\n            [\n                \"domain\",\n                \"name\",\n                \"domain admin\",\n                \"schema admin\",\n                \"enterprise admin\",\n                \"key admin\",\n                \"enterprise key admin\",\n                \"builtin admin\",\n                \"admincount\",\n            ]\n        )\n\n        data = []\n\n        for dic in self.users_nb_domain_admins:\n            if dic[\"admincount\"]:\n                continue\n            tmp_data = {\"domain\": '<i class=\"bi bi-globe2\"></i> ' + dic[\"domain\"]}\n            tmp_data[\"name\"] = '<i class=\"bi bi-gem\"></i> ' + dic[\"name\"]\n            tmp_data[\"domain admin\"] = (\n                '<i class=\"bi bi-check-square-fill\"></i><span style=\"display:none\">True</span>'\n                if \"Domain Admin\" in dic[\"admin type\"]\n                else '<i class=\"bi bi-square\"></i>'\n            )\n            tmp_data[\"schema admin\"] = (\n                '<i class=\"bi bi-check-square-fill\"></i><span style=\"display:none\">True</span>'\n                if \"Schema Admin\" in dic[\"admin type\"]\n                else '<i class=\"bi bi-square\"></i>'\n            )\n            tmp_data[\"enterprise admin\"] = (\n                '<i class=\"bi bi-check-square-fill\"></i><span style=\"display:none\">True</span>'\n                if \"Enterprise Admin\" in dic[\"admin type\"]\n                else '<i class=\"bi bi-square\"></i>'\n            )\n            tmp_data[\"key admin\"] = (\n                '<i class=\"bi bi-check-square-fill\"></i><span style=\"display:none\">True</span>'\n                if \"_ Key Admin\" in dic[\"admin type\"]\n                else '<i class=\"bi bi-square\"></i>'\n            )\n            tmp_data[\"enterprise key admin\"] = (\n                '<i class=\"bi bi-check-square-fill\"></i><span style=\"display:none\">True</span>'\n                if \"Enterprise Key Admin\" in dic[\"admin type\"]\n                else '<i class=\"bi bi-square\"></i>'\n            )\n            tmp_data[\"builtin admin\"] = (\n                '<i class=\"bi bi-check-square-fill\"></i><span style=\"display:none\">True</span>'\n                if \"Builtin Administrator\" in dic[\"admin type\"]\n                else '<i class=\"bi bi-square\"></i>'\n            )\n            tmp_data[\"admincount\"] = (\n                '<i class=\"bi bi-square\" style=\"color: red;\"></i> Missing admincount'\n            )\n            data.append(tmp_data)\n\n        for name, domain, da_type in self.unpriviledged_users_with_admincount:\n            tmp_data = {\"domain\": '<i class=\"bi bi-globe2\"></i> ' + domain}\n            tmp_data[\"name\"] = '<i class=\"bi bi-person-fill\"></i> ' + name\n            tmp_data[\"domain admin\"] = '<i class=\"bi bi-square\"></i>'\n            tmp_data[\"schema admin\"] = '<i class=\"bi bi-square\"></i>'\n            tmp_data[\"enterprise admin\"] = '<i class=\"bi bi-square\"></i>'\n            tmp_data[\"key admin\"] = '<i class=\"bi bi-square\"></i>'\n            tmp_data[\"enterprise key admin\"] = '<i class=\"bi bi-square\"></i>'\n            tmp_data[\"builtin admin\"] = '<i class=\"bi bi-square\"></i>'\n            tmp_data[\"admincount\"] = (\n                '<i class=\"bi bi-check-square-fill\" style=\"color: red;\"></i> Misleading admincount<span style=\"display:none\">True</span>'\n            )\n            data.append(tmp_data)\n\n        grid.setData(data)\n        page.addComponent(grid)\n        page.render()\n\n        self.priviledge_users_without_admincount = len(\n            [dic for dic in self.users_nb_domain_admins if not dic[\"admincount\"]]\n        )\n\n        self.data = len(self.unpriviledged_users_with_admincount) + len(\n            [dic for dic in self.users_nb_domain_admins if not dic[\"admincount\"]]\n        )\n        self.name_description = f\"{self.priviledge_users_without_admincount} priviledged accounts without admincount and {len(self.unpriviledged_users_with_admincount)} unpriviledged accounts with admincount\"\n\n    def get_rating(self) -> int:\n        if (\n            self.unpriviledged_users_with_admincount is None\n            or self.users_nb_domain_admins is None\n        ):\n            return -1\n        for da_dic in self.users_nb_domain_admins:\n            if not da_dic[\"admincount\"]:\n                return 1\n        if len(self.unpriviledged_users_with_admincount) > 0:\n            return 3\n        return 5\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      }
    },
    "requests_keys": [
      "nb_domain_admins",
      "unpriviledged_users_with_admincount"
    ]
  },
  {
    "title": "RDP access (users)",
    "file_name": "users_rdp_access.py",
    "control_category": "Permissions",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\n\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\nfrom ad_miner.sources.modules.utils import grid_data_stringify\nfrom ad_miner.sources.modules.common_analysis import percentage_superior\n\nfrom urllib.parse import quote\n\n\n@register_control\nclass users_rdp_access(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"permissions\"\n        self.control_key = \"users_rdp_access\"\n\n        self.title = \"RDP access (users)\"\n        self.description = \"Users who are allowed to access computers through Remote Desktop Protocol (RDP).\"\n        self.risk = \"With this privilege, a user can remotely spawn an graphical interactive session on a machine. RDP access allows attackers to pivot in the network.\"\n        self.poa = \"Review this list to ensure RDP access is legitimate.\"\n\n        self.users_rdp_access = requests_results[\"rdp_access\"]\n        self.users_rdp_access_1 = (\n            dict(\n                sorted(\n                    self.parseRDPData(self.users_rdp_access).items(),\n                    key=lambda x: len(x[1]),\n                    reverse=True,\n                )\n            )\n            if self.users_rdp_access is not None\n            else None\n        )\n\n        self.users = requests_results[\"nb_enabled_accounts\"]\n\n    def run(self):\n        if self.users_rdp_access_1 is None:\n            return\n        headers = [\"Users\", \"Computers\"]\n        formated_data = []\n        for key in self.users_rdp_access_1:\n            sortClass = str(len(self.users_rdp_access_1[key])).zfill(6)\n            d = {\n                \"Users\": '<i class=\"bi bi-person-fill\"></i> ' + key,\n                \"Computers\": grid_data_stringify(\n                    {\n                        \"value\": f\"{len(self.users_rdp_access_1[key])} Computers <p style='visibility:hidden;'>{self.users_rdp_access_1[key]}</p>\",\n                        \"link\": f\"users_rdp_access.html?parameter={quote(str(key))}\",\n                        \"before_link\": f'<i class=\"bi bi-pc-display {sortClass}\"></i>',\n                    }\n                ),\n            }\n            formated_data.append(d)\n        page = Page(\n            self.arguments.cache_prefix,\n            \"users_rdp_access\",\n            \"Users with RDP access\",\n            self.get_dico_description(),\n        )\n        grid = Grid(\"Users with RDP access\")\n        grid.setheaders(headers)\n        grid.setData(formated_data)\n        page.addComponent(grid)\n        page.render()\n\n        # TODO define the metric of your control\n        # it will be stored in the data json\n        self.data = len(self.users_rdp_access_1) if self.users_rdp_access_1 else 0\n\n        # TODO define the sentence that will be displayed in the 'smolcard' view and in the center of the mainpage\n        self.name_description = f\"{self.data} users with RDP access\"\n\n    def get_rating(self) -> int:\n        # TODO define the rating function.\n        # You can use common rating functions define in ad_miner.sources.modules.common_analysis like presenceof, percentage_superior, etc.\n        # -1 = grey, 1 = red, 2 = orange, 3 = yellow, 4 =green, 5 = green,\n        return percentage_superior(\n            self.users_rdp_access_1, self.users, criticity=3, percentage=0.5\n        )\n\n    def parseRDPData(self, list_of_dict):\n        final_dict = {}\n        for dict in list_of_dict:\n            if dict[\"user\"] in final_dict.keys():\n                final_dict[dict[\"user\"]] += [dict[\"computer\"]]\n            else:\n                final_dict[dict[\"user\"]] = [dict[\"computer\"]]\n        return final_dict\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "ad_miner/sources/modules/utils.py": {
        "imported_elements": [
          "grid_data_stringify"
        ],
        "code_map": {
          "grid_data_stringify": "def grid_data_stringify(raw_data: dict) -> str:\n    \"\"\"\n    Transform a dict to a string for the grid formating. This is a dumb fix for the sorting with hyperlink.\n    dict format :\n    {\n        \"link\",\n        \"value\",\n        \"before_link\"\n    }\n    \"\"\"\n    link = raw_data['link'].replace(sep, '_').replace('/', '_')\n    try:\n        return f\"{raw_data['before_link']} <a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\"\n    except KeyError:\n        return f\"<a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\""
        }
      },
      "ad_miner/sources/modules/common_analysis.py": {
        "imported_elements": [
          "percentage_superior"
        ],
        "code_map": {
          "percentage_superior": "def percentage_superior(req, base, criticity=1, percentage=0, presence=False):\n    if req is None:\n        return -1\n    if base is None:\n        return -1\n    if len(base) == 0:\n        return -1\n\n    if len(base) and len(req) / len(base) > percentage:\n        return criticity\n\n    if presence:\n        if len(req) > 0:\n            return criticity + 1\n    return 5"
        }
      },
      "/Users/steverassinot/Repos/AD_Miner/urllib/parse/__init__.py": {
        "imported_elements": [
          "quote"
        ],
        "code_map": {}
      }
    },
    "requests_keys": [
      "rdp_access",
      "nb_enabled_accounts"
    ]
  },
  {
    "title": "Users without password expiration",
    "file_name": "never_expires.py",
    "control_category": "Passwords",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\n\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\n\nfrom ad_miner.sources.modules.utils import days_format\nfrom ad_miner.sources.modules.common_analysis import percentage_superior\n\n\n@register_control\nclass never_expires(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"passwords\"\n\n        self.control_key = \"never_expires\"\n\n        self.title = \"Users without password expiration\"\n        self.description = \"These accounts have their passwords set to never expire.\"\n        self.risk = \"Ideally, this list should be empty. Non-expiring passwords are easier to exploit for an attacker.\"\n        self.poa = \"Check that all of these users have a reason to be on this list.\"\n\n        self.users_password_never_expires = requests_results[\n            \"user_password_never_expires\"\n        ]\n        self.users = requests_results[\"nb_enabled_accounts\"]\n        self.users_nb_domain_admins = requests_results[\"nb_domain_admins\"]\n        self.admin_list = []\n        for admin in self.users_nb_domain_admins:\n            self.admin_list.append(admin[\"name\"])\n\n    def run(self):\n        if self.users_password_never_expires is None:\n            return\n        for user in self.users_password_never_expires:\n            # Add admin icon\n            if user[\"name\"] in self.admin_list:\n                user[\"name\"] = (\n                    '<i class=\"bi bi-gem\" title=\"This user is domain admin\"></i> '\n                    + user[\"name\"]\n                )\n            else:\n                user[\"name\"] = '<i class=\"bi bi-person-fill\"></i> ' + user[\"name\"]\n        page = Page(\n            self.arguments.cache_prefix,\n            \"never_expires\",\n            \"List of all users without password expiration\",\n            self.get_dico_description(),\n        )\n        grid = Grid(\"Users without password expiration\")\n        grid.setheaders(\n            [\n                \"domain\",\n                \"name\",\n                \"Last login\",\n                \"Last password change\",\n                \"Account Creation Date\",\n            ]\n        )\n\n        data = []\n        for dict in self.users_password_never_expires:\n            tmp_data = {\n                \"domain\": '<i class=\"bi bi-globe2\"></i> ' + dict[\"domain\"],\n                \"name\": dict[\"name\"],\n            }\n            tmp_data[\"Last login\"] = days_format(dict[\"LastLogin\"])\n            tmp_data[\"Last password change\"] = days_format(dict[\"LastPasswChange\"])\n            tmp_data[\"Account Creation Date\"] = days_format(dict[\"accountCreationDate\"])\n\n            data.append(tmp_data)\n        grid.setData(data)\n        page.addComponent(grid)\n        page.render()\n\n        # TODO define the metric of your control\n        # it will be stored in the data json\n        self.data = (\n            len(self.users_password_never_expires)\n            if self.users_password_never_expires\n            else 0\n        )\n\n        # TODO define the sentence that will be displayed in the 'smolcard' view and in the center of the mainpage\n        self.name_description = f\"{self.data} users without password expiration\"\n\n    def get_rating(self) -> int:\n        # TODO define the rating function.\n        # You can use common rating functions define in ad_miner.sources.modules.common_analysis like presenceof, percentage_superior, etc.\n        # -1 = grey, 1 = red, 2 = orange, 3 = yellow, 4 =green, 5 = green,\n        return percentage_superior(\n            self.users_password_never_expires,\n            self.users,\n            criticity=2,\n            percentage=0.8,\n            presence=True,\n        )\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "ad_miner/sources/modules/utils.py": {
        "imported_elements": [
          "days_format"
        ],
        "code_map": {
          "days_format": "def days_format(nb_days: int, critical_time=90) -> str:\n    \"\"\"\n    Returns the date in a nice format\n    \"\"\"\n\n    critical_time = int(critical_time)\n\n    sortClass = str(nb_days).zfill(6)\n    if nb_days is None:\n        return f\"<i class='{sortClass} bi bi-x-circle' style='color: rgb(255, 89, 94);'></i> Unknown\"\n    if nb_days > 19000:\n        return f\"<i class='{sortClass} bi bi-x-circle' style='color: rgb(255, 89, 94);'></i> Never\"\n    y = nb_days // 365\n    m = (nb_days % 365) // 30\n    d = (nb_days % 365) % 30\n\n    color = \"#b00404\" if nb_days > 2 * critical_time else \"#e36402\" if nb_days > critical_time else \"#0a6e01\"\n\n    if y > 0:\n        return f\"<i class='{sortClass} bi bi-calendar3' style='color: {color};'></i> {y} year{'s' if y > 1 else ''}, {m} month{'s' if m > 1 else ''} and {d} day{'s' if d > 1 else ''}\"\n    elif m > 0:\n        return f\"<i class='{sortClass} bi bi-calendar3' style='color: {color};'></i> {m} month{'s' if m > 1 else ''} and {d} day{'s' if d > 1 else ''}\"\n    else:\n        return f\"<i class='{sortClass} bi bi-calendar3' style='color: {color};'></i> {d} day{'s' if d > 1 else ''}\""
        }
      },
      "ad_miner/sources/modules/common_analysis.py": {
        "imported_elements": [
          "percentage_superior"
        ],
        "code_map": {
          "percentage_superior": "def percentage_superior(req, base, criticity=1, percentage=0, presence=False):\n    if req is None:\n        return -1\n    if base is None:\n        return -1\n    if len(base) == 0:\n        return -1\n\n    if len(base) and len(req) / len(base) > percentage:\n        return criticity\n\n    if presence:\n        if len(req) > 0:\n            return criticity + 1\n    return 5"
        }
      }
    },
    "requests_keys": [
      "user_password_never_expires",
      "nb_domain_admins",
      "nb_enabled_accounts"
    ]
  },
  {
    "title": "Computers with obsolete OS",
    "file_name": "computers_os_obsolete.py",
    "control_category": "Misc",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\n\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\nfrom ad_miner.sources.modules.utils import days_format\nfrom ad_miner.sources.modules.common_analysis import manageComputersOs, presence_of\n\n\n@register_control\nclass computers_os_obsolete(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"misc\"\n        self.control_key = \"computers_os_obsolete\"\n\n        self.title = \"Computers with obsolete OS\"\n        self.description = \"List of computers with obsolete OS\"\n        self.risk = \"The bigger this list, the more exposed to critical exploits your infrastructure is. Obsolete OS are not maintained anymore by their manufacturers and are often vulnerable to public exploits\"\n        self.poa = \"Switch to a more up-to-date OS on these computers\"\n\n        self.list_computers_os_obsolete, all_os = manageComputersOs(\n            requests_results[\"os\"]\n        )\n\n    def run(self):\n        if self.list_computers_os_obsolete is None:\n            return\n        page = Page(\n            self.arguments.cache_prefix,\n            \"computers_os_obsolete\",\n            \"Obsolete operating systems\",\n            self.get_dico_description(),\n        )\n        grid = Grid(\"Computers obsolete operating systems\")\n        cleaned_data = []\n        for computer in self.list_computers_os_obsolete:\n            if computer[\"Last logon in days\"] < 90:  # remove ghost computers\n                computer[\"Domain\"] = (\n                    '<i class=\"bi bi-globe2\"></i> ' + computer[\"Domain\"]\n                )\n                computer[\"Last logon\"] = days_format(computer[\"Last logon in days\"])\n                if (\n                    \"2008\" in computer[\"Operating system\"]\n                    or \"2003\" in computer[\"Operating system\"]\n                    or \"2012\" in computer[\"Operating system\"]\n                ):  # Add icons whether it's a computer or a server\n                    computer[\"Operating system\"] = (\n                        '<i class=\"bi bi-server\"></i> ' + computer[\"Operating system\"]\n                    )\n                    computer[\"name\"] = (\n                        '<i class=\"bi bi-server\"></i> ' + computer[\"name\"]\n                    )\n                if (\n                    \"2000\" in computer[\"Operating system\"]\n                    or \"XP\" in computer[\"Operating system\"]\n                    or \"Windows 7\" in computer[\"Operating system\"]\n                ):\n                    computer[\"Operating system\"] = (\n                        '<i class=\"bi bi-pc-display\"></i> '\n                        + computer[\"Operating system\"]\n                    )\n                    computer[\"name\"] = (\n                        '<i class=\"bi bi-pc-display\"></i> ' + computer[\"name\"]\n                    )\n\n                cleaned_data.append(computer)\n        grid.setheaders([\"Domain\", \"name\", \"Operating system\", \"Last logon\"])\n        grid.setData(cleaned_data)\n        page.addComponent(grid)\n        page.render()\n        self.list_computers_os_obsolete = cleaned_data\n\n        # TODO define the metric of your control\n        # it will be stored in the data json\n        self.data = (\n            len(self.list_computers_os_obsolete)\n            if self.list_computers_os_obsolete\n            else 0\n        )\n\n        # TODO define the sentence that will be displayed in the 'smolcard' view and in the center of the mainpage\n        self.name_description = f\"{self.data} computers with obsolete OS\"\n\n    def get_rating(self) -> int:\n        return presence_of(self.list_computers_os_obsolete, criticity=2)\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "ad_miner/sources/modules/utils.py": {
        "imported_elements": [
          "days_format"
        ],
        "code_map": {
          "days_format": "def days_format(nb_days: int, critical_time=90) -> str:\n    \"\"\"\n    Returns the date in a nice format\n    \"\"\"\n\n    critical_time = int(critical_time)\n\n    sortClass = str(nb_days).zfill(6)\n    if nb_days is None:\n        return f\"<i class='{sortClass} bi bi-x-circle' style='color: rgb(255, 89, 94);'></i> Unknown\"\n    if nb_days > 19000:\n        return f\"<i class='{sortClass} bi bi-x-circle' style='color: rgb(255, 89, 94);'></i> Never\"\n    y = nb_days // 365\n    m = (nb_days % 365) // 30\n    d = (nb_days % 365) % 30\n\n    color = \"#b00404\" if nb_days > 2 * critical_time else \"#e36402\" if nb_days > critical_time else \"#0a6e01\"\n\n    if y > 0:\n        return f\"<i class='{sortClass} bi bi-calendar3' style='color: {color};'></i> {y} year{'s' if y > 1 else ''}, {m} month{'s' if m > 1 else ''} and {d} day{'s' if d > 1 else ''}\"\n    elif m > 0:\n        return f\"<i class='{sortClass} bi bi-calendar3' style='color: {color};'></i> {m} month{'s' if m > 1 else ''} and {d} day{'s' if d > 1 else ''}\"\n    else:\n        return f\"<i class='{sortClass} bi bi-calendar3' style='color: {color};'></i> {d} day{'s' if d > 1 else ''}\""
        }
      },
      "ad_miner/sources/modules/common_analysis.py": {
        "imported_elements": [
          "manageComputersOs",
          ""
        ],
        "code_map": {
          "manageComputersOs": "def manageComputersOs(computer_list):\n    if computer_list is None:\n        return None\n    all_os = {}\n    computers_os_obsolete = []\n\n    for line in computer_list:\n        os = line[\"os\"]\n        if \"windows\" in os.lower():\n            os = os.lower()\n            os = os.replace(\"\\xa0\", \" \")\n            os = os.replace(\"®\", \"\")\n            os = os.replace(\" server\", \"\")\n            os = os.replace(\" storage\", \"\")\n            os = os.replace(\" 2008 r2\", \" 2008R2\")\n            os = os.replace(\" 2012 r2\", \" 2012R2\")\n            ver = re.match(r\"^windows ([.a-zA-Z0-9]+)\\s\", os, re.M | re.I)\n            if ver:\n                os = \"Windows \" + ver.group(1).upper()\n            else:\n                os = os.replace(\"windows\", \"Windows\")\n        else:\n            os = os\n\n        # Cleaner way to do a try/except for dictionaries is to use get() :\n        lastLogon = line.get(\"lastLogon\", \"Not specified\")\n        final_line = {\n            \"Domain\": line[\"domain\"],\n            \"name\": line[\"name\"],\n            \"Operating system\": os,\n            \"Last logon in days\": lastLogon,\n        }\n\n        # Stats for OS repartition\n        def addToOS(key):\n            if all_os.get(key):\n                all_os[key] += 1\n            else:\n                all_os[key] = 1\n\n        if \"windows\" in os.lower():\n            addToOS(os)\n        elif \"linux\" in os.lower() or \"ubuntu\" in os.lower():\n            addToOS(\"Linux\")\n        elif \"mac\" in os.lower():\n            addToOS(\"MacOS\")\n        elif \"android\" in os.lower():\n            addToOS(\"Android\")\n        elif \"ios\" in os.lower():\n            addToOS(\"iOS\")\n        else:\n            addToOS(\"Other\")\n\n        if os in obsolete_os_list:\n            computers_os_obsolete.append(final_line)\n    return computers_os_obsolete, all_os"
        }
      }
    },
    "requests_keys": [
      "os"
    ]
  },
  {
    "title": "Inadequate GPO modifications privileges",
    "file_name": "users_GPO_access.py",
    "control_category": "Permissions",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\nfrom ad_miner.sources.modules import logger\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\nfrom ad_miner.sources.modules.graph_class import Graph\nfrom ad_miner.sources.modules import generic_computing\nfrom ad_miner.sources.modules.common_analysis import (\n    presence_of,\n)\nfrom os.path import sep\nfrom tqdm import tqdm\nfrom urllib.parse import quote\nimport json\n\n\n@register_control\nclass users_GPO_access(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"permissions\"\n        self.control_key = \"users_GPO_access\"\n\n        self.title = \"Inadequate GPO modifications privileges\"\n        self.description = \"GPOs that can be edited by unprivileged users.\"\n        self.risk = \"If an AD object has rights over a GPO, it can potentially cause damage over all the objects affected by the GPO. GPOs can also be leveraged to gain privileges in the domain(s). If an attacker exploits one of these paths, they will be able to gain privileges in the domain(s) and cause some serious damage.<br/><br/><i class='bi bi-star-fill' style='color: red'></i><i class='bi bi-star-fill' style='color: red'></i><i class='bi bi-star-fill' style='color: red'></i> : Full domain or at least one domain admin as target.<br /><i class='bi bi-star-fill' style='color: orange'></i><i class='bi bi-star-fill' style='color: orange'></i><i class='bi bi-star' style='color: orange'></i> : At least one object admin of a computer.<br/><i class='bi bi-star-fill' style='color: green'></i><i class='bi bi-star' style='color: green'></i><i class='bi bi-star' style='color: green'></i> : At least one object as target.<br/><i class='bi bi-star' style='color: green'></i><i class='bi bi-star' style='color: green'></i><i class='bi bi-star' style='color: green'></i> : No direct target.\"\n        self.poa = \"Review the paths, make sure they are not exploitable. If they are, cut the link between the Active Directory objects in order to reduce the attack surface.\"\n\n        self.description_grid_GPO_access = {\n            \"description\": \"Grid of paths for GPO exploit\",\n            \"interpretation\": \"\",\n            \"risk\": \"If an AD object has rights over a GPO, it can potentially cause damage over all the objects affected by the GPO. GPOs can also be leveraged to gain privileges in the domain(s). If an attacker exploits one of these paths, they will be able to gain privileges in the domain(s) and cause some serious damage.\",\n            \"poa\": \"Review the objects in this list by making sure they are not wrongfully allowed to edit this GPO.\",\n        }\n\n        self.description_graph_GPO_access = {\n            \"description\": \"Graph of paths for GPO exploit\",\n            \"interpretation\": \"\",\n            \"risk\": \"If an AD object has rights over a GPO, it can potentially cause damage over all the objects affected by the GPO. GPOs can also be leveraged to gain privileges in the domain(s). If an attacker exploits one of these paths, they will be able to gain privileges in the domain(s) and cause some serious damage.\",\n            \"poa\": \"Review the paths, make sure they are not exploitable. If they are, cut the link between the Active Directory objects in order to reduce the attack surface.\",\n        }\n\n        self.users_admin_computer = requests_results[\"users_admin_on_computers\"]\n        self.users_admin_computer_list = generic_computing.getListAdminTo(\n            self.users_admin_computer, \"user\", \"computer\"\n        )\n\n        self.admin_list = requests_results[\"admin_list\"]\n\n        self.number_of_gpo = 0\n\n        if not arguments.gpo_low:\n            self.unpriv_users_to_GPO_init = self.requests_results[\n                \"unpriv_users_to_GPO_init\"\n            ]\n            self.unpriv_users_to_GPO_user_enforced = self.requests_results[\n                \"unpriv_users_to_GPO_user_enforced\"\n            ]\n            self.unpriv_users_to_GPO_computer_enforced = self.requests_results[\n                \"unpriv_users_to_GPO_computer_not_enforced\"\n            ]\n            self.unpriv_users_to_GPO_user_not_enforced = self.requests_results[\n                \"unpriv_users_to_GPO_user_not_enforced\"\n            ]\n            self.unpriv_users_to_GPO_computer_not_enforced = self.requests_results[\n                \"unpriv_users_to_GPO_computer_not_enforced\"\n            ]\n\n        else:\n            self.unpriv_users_to_GPO = self.requests_results[\"unpriv_users_to_GPO\"]\n\n    def run(self):\n        if self.arguments.gpo_low and self.unpriv_users_to_GPO is None:\n            self.data = -1\n            self.name_description = \"\"\n\n        if not self.arguments.gpo_low:\n            fail = []\n            if self.unpriv_users_to_GPO_init is None:\n                fail.append(\"unpriv_users_to_GPO_init\")\n            elif self.unpriv_users_to_GPO_user_enforced is None:\n                fail.append(\"unpriv_users_to_GPO_user_enforced\")\n            elif self.unpriv_users_to_GPO_user_not_enforced is None:\n                fail.append(\"unpriv_users_to_GPO_user_not_enforced\")\n            elif self.unpriv_users_to_GPO_computer_enforced is None:\n                fail.append(\"unpriv_users_to_GPO_computer_enforced\")\n            elif self.unpriv_users_to_GPO_computer_not_enforced is None:\n                fail.append(\"unpriv_users_to_GPO_computer_not_enforced\")\n\n            if 0 < len(fail) < 5:  # if only some of them are disabled\n                logger.print_error(\n                    f\" In order to use 'normal GPO mode', please activate the following in config.json : {', '.join(fail)}\"\n                )\n\n            if len(fail) > 0:\n                self.data = -1\n                self.name_description = \"\"\n                return\n\n        def parseGPOData(listOfPaths, headers):\n            \"\"\"\n            Initial parsing of data from neo4j requests for GPO\n            \"\"\"\n            dictOfGPO = {}\n            for path in listOfPaths:\n                start = path.nodes[0]\n                end = path.nodes[-1]\n                if \"GPO\" in start.labels:\n                    nameOfGPO = start.name\n                    idOfGPO = start.id\n                    sens = \"right\"\n                elif \"GPO\" in end.labels:\n                    nameOfGPO = end.name\n                    idOfGPO = end.id\n                    sens = \"left\"\n                else:\n                    continue\n                try:\n                    if sens == \"right\":\n                        dictOfGPO[nameOfGPO][headers[4]] += 1\n                        dictOfGPO[nameOfGPO][\"right_path\"].append(path)\n                        dictOfGPO[nameOfGPO][\"end_list\"].append((end.name, end.labels))\n                    elif sens == \"left\":\n                        dictOfGPO[nameOfGPO][headers[1]] += 1\n                        dictOfGPO[nameOfGPO][\"left_path\"].append(path)\n                        dictOfGPO[nameOfGPO][\"entry_list\"].append(\n                            (start.name, start.labels)\n                        )\n                    else:\n                        continue\n                except KeyError:\n                    if sens == \"right\":\n                        dictOfGPO[nameOfGPO] = {\n                            headers[0]: nameOfGPO,\n                            headers[1]: 0,\n                            headers[4]: 1,\n                            \"left_path\": [],\n                            \"right_path\": [path],\n                            \"id\": idOfGPO,\n                            \"entry_list\": [],\n                            \"end_list\": [(end.name, end.labels)],\n                        }\n                    elif sens == \"left\":\n                        dictOfGPO[nameOfGPO] = {\n                            headers[0]: nameOfGPO,\n                            headers[1]: 1,\n                            headers[4]: 0,\n                            \"left_path\": [path],\n                            \"right_path\": [],\n                            \"id\": idOfGPO,\n                            \"entry_list\": [(start.name, start.labels)],\n                            \"end_list\": [],\n                        }\n                    else:\n                        continue\n            return dictOfGPO\n\n        def formatGPOGrid(dictOfGPO, headers):\n            output = []\n\n            # Extract all computers admin of computers\n            self.computers_with_admin_rights = list(\n                self.users_admin_computer_list.keys()\n            )\n            # self.computers_with_admin_rights = [\n            #     d[\"Computer Admin\"].split(\"</i> \")[-1]\n            #     for d in self.computers_admin_data_grid\n            # ]\n            # Extract all users admin of computers\n            self.users_with_admin_rights = [\n                d[\"user\"] for d in self.users_admin_computer\n            ]\n\n            for _, dict in tqdm(dictOfGPO.items()):\n                self.number_of_gpo += 1\n                # Rate the interest of the GPO\n                # 0 star  : no object impacted\n                # 1 star  : at least one object impacted\n                # 2 stars : at least one admin account impacted\n                # 3 stars : full domain or at least one domain admin impacted\n                paths = dict[\"right_path\"]\n\n                if len(paths) == 0:\n                    interest = 0\n                else:\n                    interest = 1\n\n                for path in paths:\n                    for i in range(len(path.nodes)):\n                        if path.nodes[i].labels == \"Domain\":\n                            interest = 3\n                            break\n                        if path.nodes[i].name in self.admin_list:\n                            interest = 3\n                            break\n                        if (\n                            path.nodes[i].name in self.users_with_admin_rights\n                            or path.nodes[i].name in self.computers_with_admin_rights\n                        ):\n                            interest = max(2, interest)\n\n                # Color for stars\n                if interest == 3:\n                    color = \"red\"\n                elif interest == 2:\n                    color = \"orange\"\n                else:\n                    color = \"green\"\n\n                icon = (\n                    f\"<span class='{interest}'></span><i class='bi bi-star-fill' style='color: {color}'></i>\"\n                    * interest\n                    + f\"<i class='bi bi-star' style='color: {color}'></i>\"\n                    * (3 - interest)\n                )\n\n                output.append(\n                    {\n                        headers[0]: '<i class=\"bi bi-journal-text\"></i> '\n                        + dict[headers[0]],\n                        headers[\n                            1\n                        ]: f'<i class=\"bi bi-shuffle {str(dict[headers[1]]).zfill(6)}\"></i> '\n                        + str(dict[headers[1]]),\n                        headers[2]: {\n                            \"link\": \"users_GPO_access-%s-left-graph.html\"\n                            % (quote(str(dict[headers[0]]).replace(sep, \"_\"))),\n                            \"value\": \"<i class='bi bi-diagram-3-fill' aria-hidden='true'></i>\",\n                        },\n                        headers[3]: {\n                            \"link\": \"users_GPO_access-%s-left-grid.html\"\n                            % (quote(str(dict[headers[0]]).replace(sep, \"_\"))),\n                            \"value\": \"<i class='bi bi-list-columns-reverse' aria-hidden='true'></i>\",\n                        },\n                        headers[\n                            4\n                        ]: f'<i class=\"bi bi-bullseye {str(len(list(set(dict[\"end_list\"])))).zfill(6)}\"></i> '\n                        + str(len(list(set(dict[\"end_list\"])))),\n                        headers[5]: icon,\n                        headers[6]: {\n                            \"link\": \"users_GPO_access-%s-right-graph.html\"\n                            % (quote(str(dict[headers[0]]).replace(sep, \"_\"))),\n                            \"value\": \"<i class='bi bi-diagram-3-fill' aria-hidden='true'></i>\",\n                        },\n                        headers[7]: {\n                            \"link\": \"users_GPO_access-%s-right-grid.html\"\n                            % (quote(str(dict[headers[0]]).replace(sep, \"_\"))),\n                            \"value\": \"<i class='bi bi-list-columns-reverse' aria-hidden='true'></i>\",\n                        },\n                    }\n                )\n            return output\n\n        def formatSmallGrid(list, gpo_name):\n            output = []\n            for n in list:\n                if n[1] == \"Computer\":\n                    icon = '<i class=\"bi bi-pc-display\"></i> '\n                elif n[1] == \"User\":\n                    icon = '<i class=\"bi bi-person-fill\"></i> '\n                elif n[1] == \"Domain\":\n                    icon = '<i class=\"bi bi-house-fill\"></i> '\n                else:\n                    icon = '<i class=\"bi bi-question-circle-fill\"></i> '\n\n                if (\n                    n[0] in self.computers_with_admin_rights\n                    or n[0] in self.users_with_admin_rights\n                ):\n                    icon = (\n                        icon\n                        + '<i class=\"bi bi-gem\" title=\"This object has administration rights\" style=\"color:grey;\"></i> '\n                    )\n                if n[0] in self.admin_list:\n                    icon = '<i class=\"bi bi-gem\" title=\"This user is domain admin\" style=\"color:deepskyblue;\"></i> '\n\n                output.append({gpo_name: icon + n[0]})\n            return output\n\n        headers = [\n            \"GPO name\",\n            \"Paths to GPO\",\n            \"Inbound graph\",\n            \"Inbound list\",\n            \"Objects impacted\",\n            \"Targets interest\",\n            \"Outbound graph\",\n            \"Outbound list\",\n        ]\n        if not self.arguments.gpo_low:\n            data = (\n                self.unpriv_users_to_GPO_init\n                + self.unpriv_users_to_GPO_user_enforced\n                + self.unpriv_users_to_GPO_computer_enforced\n                + self.unpriv_users_to_GPO_user_not_enforced\n                + self.unpriv_users_to_GPO_computer_not_enforced\n            )\n            self.unpriv_users_to_GPO_parsed = parseGPOData(data, headers)\n            grid = Grid(\"Users with GPO access\")\n        else:\n            self.domain.unpriv_users_to_GPO_parsed = parseGPOData(\n                self.domain.unpriv_users_to_GPO, headers\n            )\n            grid = Grid(\"Users with GPO access\")\n\n        formated_data = sorted(\n            formatGPOGrid(self.unpriv_users_to_GPO_parsed, headers),\n            key=lambda x: x[headers[1]],\n            reverse=True,\n        )\n        page = Page(\n            self.arguments.cache_prefix,\n            \"users_GPO_access\",\n            \"Exploitation through GPO\",\n            self.get_dico_description(),\n        )\n\n        grid.setheaders(headers)\n        grid.setData(json.dumps(formated_data))\n        page.addComponent(grid)\n        page.render()\n\n        for _, GPO in self.unpriv_users_to_GPO_parsed.items():\n            url_left_graph = \"users_GPO_access-%s-left-graph\" % GPO[headers[0]]\n            url_right_graph = \"users_GPO_access-%s-right-graph\" % GPO[headers[0]]\n            page_left_graph = Page(\n                self.arguments.cache_prefix,\n                url_left_graph,\n                \"Users with write access on GPO\",\n                self.description_graph_GPO_access,\n            )\n            page_right_graph = Page(\n                self.arguments.cache_prefix,\n                url_right_graph,\n                \"Objects impacted by GPO\",\n                self.description_graph_GPO_access,\n            )\n\n            url_left_grid = \"users_GPO_access-%s-left-grid\" % GPO[headers[0]]\n            url_right_grid = \"users_GPO_access-%s-right-grid\" % GPO[headers[0]]\n            page_left_grid = Page(\n                self.arguments.cache_prefix,\n                url_left_grid,\n                \"List of users able to compromise %s\" % GPO[headers[0]],\n                self.description_grid_GPO_access,\n            )\n            page_right_grid = Page(\n                self.arguments.cache_prefix,\n                url_right_grid,\n                \"List of users impacted by %s\" % GPO[headers[0]],\n                self.description_grid_GPO_access,\n            )\n\n            # if GPO[headers[4]] > 0:\n            graph_left = Graph()\n            graph_left.setPaths(GPO[\"left_path\"])\n            page_left_graph.addComponent(graph_left)\n\n            graph_right = Graph()\n            graph_right.setPaths(GPO[\"right_path\"])\n            page_right_graph.addComponent(graph_right)\n\n            if not self.arguments.gpo_low:\n                entry_grid = Grid(\n                    \"List of users able to compromise %s\" % GPO[headers[0]]\n                )\n            else:\n                entry_grid = Grid(\n                    \"List of users able to compromise %s\" % GPO[headers[0]]\n                )\n            entry_grid.setheaders([GPO[headers[0]]])\n            entry_grid.setData(\n                json.dumps(\n                    formatSmallGrid(list(set(GPO[\"entry_list\"])), GPO[headers[0]])\n                )\n            )\n            page_left_grid.addComponent(entry_grid)\n\n            end_grid = Grid(\"List of users impacted by %s\" % GPO[headers[0]])\n            end_grid.setheaders([GPO[headers[0]]])\n            end_grid.setData(\n                json.dumps(formatSmallGrid(list(set(GPO[\"end_list\"])), GPO[headers[0]]))\n            )\n            page_right_grid.addComponent(end_grid)\n\n            page_left_graph.render()\n            page_right_graph.render()\n            page_left_grid.render()\n            page_right_grid.render()\n\n        self.data = self.number_of_gpo if self.number_of_gpo else 0\n\n        self.name_description = (\n            f\"{self.data} GPO with inadequate modification privileges\"\n        )\n\n    def get_rating(self) -> int:\n        return presence_of(self.unpriv_users_to_GPO_parsed.items())\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/__init__.py": {
        "imported_elements": [
          "logger",
          "generic_computing"
        ],
        "code_map": {}
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "ad_miner/sources/modules/graph_class.py": {
        "imported_elements": [
          "Graph"
        ],
        "code_map": {
          "Graph": "class Graph:\n    def __init__(self, template=\"graph\", path_limit=80000):\n        self.template_base_path = HTML_DIRECTORY / \"components/graph/\"\n        self.template = template\n        self.paths = []\n        self.nodes = {}\n        self.relations = []\n        self.relations_hashes = {}\n        self.path_limit = path_limit\n        self.ghost_computer = {}\n        self.ghost_user = {}\n        self.dc_computer = {}\n        self.user_da = {}\n        self.group_da = {}\n        self.enabled_users = {}\n        self.kerberoastable_users = {}\n        self.disabled_users_dict = {}\n\n    def addPath(self, path):\n        self.paths.append(path)\n\n    def setPaths(self, paths):\n        self.paths = paths\n\n    def addGhostComputers(self, ghost_computer):\n        self.ghost_computer = ghost_computer\n\n    def addGhostUsers(self, ghost_user):\n        self.ghost_user = ghost_user\n\n    def addDCComputers(self, dc_computer):\n        self.dc_computer = dc_computer\n\n    def addUserDA(self, user_da):\n        self.user_da = user_da\n\n    def addGroupDA(self, group_da):\n        self.group_da = group_da\n\n    def addDisabledUsers(self, disabled_users):\n        self.disabled_users_dict = {}\n        for d in disabled_users:\n            self.disabled_users_dict[d[\"name\"]] = True\n\n    def addKerberoastableUsers(self, kerberoastable_users):\n        self.kerberoastable_users = kerberoastable_users\n\n    def render(self, page_f):\n\n        # Write header\n        with open(\n            self.template_base_path / (self.template + \"_header.html\"), \"r\"\n        ) as header_f:\n            html_header = header_f.read()\n            page_f.write(html_header)\n\n        for index, path in enumerate(self.paths):\n            for i in range(len(path.nodes)):\n\n                node = path.nodes[i]\n\n                # Compute node style\n                if i == 0:\n                    node_position = \"start\"\n                elif i == len(path.nodes) - 1:\n                    node_position = \"end\"\n                else:\n                    node_position = \"intermediate\"\n\n                # Add new labels here. A corresponding svg icon should be defined\n                # dico_icon in the icon.js file.\n                list_labels = [\n                    \"User\",\n                    \"Foreignsecurityprincipal\",\n                    \"GPO\",\n                    \"Computer\",\n                    \"OU\",\n                    \"Group\",\n                    \"Domain\",\n                    \"ADLocalGroup\",\n                    \"Container\",\n                    \"Unknown\",\n                    \"Group_cluster\",\n                    \"Device\",\n                    \"AZTenant\",\n                    \"AZRole\",\n                ]\n\n                if node.labels in list_labels:\n                    label_instance = node.labels\n                elif path.nodes[i].labels[2:] in list_labels:\n                    label_instance = node.labels[2:]\n                else:\n                    label_instance = \"Unknown\"\n\n                node_attributes = []\n\n                # Add DA icon if node is DC, DA or Domain\n                if (\n                    (\n                        label_instance == \"Computer\"\n                        and self.dc_computer.get(node.name, False)\n                    )\n                    or (label_instance == \"User\" and self.user_da.get(node.name, False))\n                    or (\n                        label_instance == \"Group\"\n                        and self.group_da.get(node.name, False)\n                    )\n                    or label_instance == \"Domain\"\n                ):\n                    node_attributes.append(\"da\")\n\n                # Add ghost icon if ghost\n                if (\n                    label_instance == \"User\" and self.ghost_user.get(node.name, False)\n                ) or (\n                    label_instance == \"Computer\"\n                    and self.ghost_computer.get(node.name, False)\n                ):\n                    node_attributes.append(\"ghost\")\n\n                if label_instance == \"User\" and self.disabled_users_dict.get(\n                    node.name, False\n                ):\n                    node_attributes.append(\"disabled\")\n\n                if label_instance == \"User\" and self.kerberoastable_users.get(\n                    node.name, False\n                ):\n                    node_attributes.append(\"kerberoastable\")\n\n                # New nodes attributes that should be added to the node icon\n                # should be added here to the node_attributes list.\n                # A corresponding svg icon should the be added to the\n                # dico_icon in icon.js\n\n                if not self.nodes.get(path.nodes[i].id):\n\n                    final_graph_node = {\n                        \"id\": path.nodes[i].id,\n                        \"label\": path.nodes[i].name,\n                        \"domain\": path.nodes[i].domain,\n                        \"shape\": \"image\",\n                        \"instance\": label_instance,\n                        \"position\": node_position,\n                        \"attributes\": node_attributes,\n                    }\n                    self.nodes[path.nodes[i].id] = final_graph_node\n\n                if i != 0:\n                    relation = {\n                        \"from\": path.nodes[i - 1].id,\n                        \"to\": path.nodes[i].id,\n                        \"label\": path.nodes[i - 1].relation_type,\n                    }\n\n                    # Avoid relation duplicated to keep graph clean\n                    # Use hashes list for better performance\n                    hash_rel = hash(\n                        str(relation[\"from\"])\n                        + str(relation[\"to\"])\n                        + str(relation[\"label\"])\n                    )\n                    if not self.relations_hashes.get(hash_rel):\n                        self.relations.append(relation)\n                        self.relations_hashes[hash_rel] = True\n\n        nodes = list(self.nodes.values())\n        for n in nodes:  # Sanitize None values (otherwise it creates a bug in JS)\n            if n[\"label\"] == None:\n                n[\"label\"] = \"???\"\n        page_f.write(f'<script type=\"text/javascript\">window.data_nodes = {nodes};\\n')\n        page_f.write(f\"window.data_edges = {self.relations};</script>\\n\")"
        }
      },
      "ad_miner/sources/modules/common_analysis.py": {
        "imported_elements": [
          "("
        ],
        "code_map": {}
      },
      "/Users/steverassinot/Repos/AD_Miner/os/path/__init__.py": {
        "imported_elements": [
          "sep"
        ],
        "code_map": {}
      },
      "/Users/steverassinot/Repos/AD_Miner/tqdm/__init__.py": {
        "imported_elements": [
          "tqdm"
        ],
        "code_map": {}
      },
      "/Users/steverassinot/Repos/AD_Miner/urllib/parse/__init__.py": {
        "imported_elements": [
          "quote"
        ],
        "code_map": {}
      }
    },
    "requests_keys": [
      "unpriv_users_to_GPO_computer_not_enforced",
      "unpriv_users_to_GPO_user_enforced",
      "unpriv_users_to_GPO_init",
      "admin_list",
      "unpriv_users_to_GPO_user_not_enforced",
      "unpriv_users_to_GPO",
      "users_admin_on_computers"
    ]
  },
  {
    "title": "Paths to Organizational Units (OU)",
    "file_name": "graph_path_objects_to_ou_handlers.py",
    "control_category": "Permissions",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\n\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.path_neo4j import Path\nfrom ad_miner.sources.modules.grid_class import Grid\nfrom ad_miner.sources.modules.utils import grid_data_stringify\nfrom ad_miner.sources.modules.common_analysis import (\n    presence_of,\n    createGraphPage,\n    get_interest,\n)\n\nfrom urllib.parse import quote\nfrom tqdm import tqdm\n\n\n@register_control\nclass graph_path_objects_to_ou_handlers(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"permissions\"\n        self.control_key = \"graph_path_objects_to_ou_handlers\"\n\n        self.title = \"Paths to Organizational Units (OU)\"\n        self.description = \"Objects that have paths to compromise OU handlers.\"\n        self.risk = \"OUs that can be used to leverage access to privileged accounts or objects are particularly sensitive.\"\n        self.poa = (\n            \"Review the exploitation paths for these OUs and remove dangerous links.\"\n        )\n\n        self.subpage_dico_description_paths_to_ou_handlers = {\n            \"description\": \"Graph of paths leading to OU handlers\",\n            \"risk\": \"Compromission paths to OU handlers represent the exposed attack surface that the AD environment presents to the attacker in order to gain corresponding privileges.\",\n            \"poa\": \"Review the paths, make sure they are not exploitable. If they are, cut the link between the Active Directory objects in order to reduce the attack surface.\",\n        }\n\n        self.compromise_paths_of_OUs = requests_results[\"compromise_paths_of_OUs\"]\n        self.vulnerable_OU_impact = requests_results[\"vulnerable_OU_impact\"]\n        self.contains_da = requests_results[\"set_containsda\"]\n        self.contains_dc = requests_results[\"set_containsdc\"]\n\n    def run(self):\n        if self.compromise_paths_of_OUs is None:\n            return\n        OU_to_targets_dico = {}\n        all_compromise_paths = []\n\n        for p in self.contains_da:\n            if p.nodes[0].id not in OU_to_targets_dico:\n                OU_to_targets_dico[p.nodes[0].id] = [p]\n            else:\n                OU_to_targets_dico[p.nodes[0].id].append(p)\n        for p in self.contains_dc:\n            if p.nodes[0].id not in OU_to_targets_dico:\n                OU_to_targets_dico[p.nodes[0].id] = [p]\n            else:\n                OU_to_targets_dico[p.nodes[0].id].append(p)\n        for p in self.vulnerable_OU_impact:\n            if p.nodes[0].id not in OU_to_targets_dico:\n                OU_to_targets_dico[p.nodes[0].id] = [p]\n            else:\n                OU_to_targets_dico[p.nodes[0].id].append(p)\n\n        for p1 in self.compromise_paths_of_OUs:\n            if p1.nodes[-1].id not in OU_to_targets_dico:\n                continue\n            for p2 in OU_to_targets_dico[p1.nodes[-1].id]:\n                assert p1.nodes[-1].id == p2.nodes[0].id\n                p = Path(p1.nodes[:-1] + p2.nodes)\n                all_compromise_paths.append(p)\n\n        # Compute users and computers admin of computers to compute targets interest\n        # should be moved to a common cache (with GPO control, ACL anomaly, etc)\n\n        page = Page(\n            self.arguments.cache_prefix,\n            \"graph_path_objects_to_ou_handlers\",\n            \"Paths to Organizational Units (OU)\",\n            self.get_dico_description(),\n        )\n\n        analysis_dict = {}\n\n        for p in tqdm(all_compromise_paths):\n            for i in range(len(p.nodes)):\n                if p.nodes[i].labels == \"OU\":\n                    OU_node = p.nodes[i]\n                    inbound_path = Path(p.nodes[: i + 1])\n                    outbount_path = Path(p.nodes[i:])\n                    break\n            if OU_node not in analysis_dict:\n                analysis_dict[OU_node] = {\"inbound_paths\": [], \"outbound_paths\": []}\n\n            # if inbound_path not in analysis_dict[OU_node][\"inbound_paths\"]:\n            analysis_dict[OU_node][\"inbound_paths\"].append(inbound_path.nodes)\n            # if outbount_path not in analysis_dict[OU_node][\"outbound_paths\"]:\n            analysis_dict[OU_node][\"outbound_paths\"].append(outbount_path.nodes)\n\n        for OU_node in analysis_dict:\n            analysis_dict[OU_node][\"inbound_paths\"] = [\n                Path(list(x))\n                for x in {(tuple(e)) for e in analysis_dict[OU_node][\"inbound_paths\"]}\n            ]\n            analysis_dict[OU_node][\"outbound_paths\"] = [\n                Path(list(x))\n                for x in {(tuple(e)) for e in analysis_dict[OU_node][\"outbound_paths\"]}\n            ]\n\n        grid = Grid(\"TODO\")\n        headers = [\n            \"OU name\",\n            \"Inbound graph\",\n            \"Inbound list\",\n            \"Targets interest\",\n            \"Outbound list\",\n            \"Outbound graph\",\n        ]\n        grid.setheaders(headers)\n        grid_data = []\n\n        for OU_node in analysis_dict:\n\n            inbound_list = [\n                p.nodes[0].name for p in analysis_dict[OU_node][\"inbound_paths\"]\n            ]\n            inbound_list = list(dict.fromkeys(inbound_list))\n\n            outbound_list = [\n                p.nodes[-1].name for p in analysis_dict[OU_node][\"outbound_paths\"]\n            ]\n            outbound_list = list(dict.fromkeys(outbound_list))\n\n            # Generate page with inbound list\n            inbound_list_page = Page(\n                self.arguments.cache_prefix,\n                \"path_objects_to_ou_handlers_inbound_list_\" + OU_node.name,\n                \"Objects that can get control over \" + OU_node.name,\n                self.get_dico_description(),\n            )\n            inbound_grid = Grid(\"Objects that can get control over \" + OU_node.name)\n            inbound_grid.setheaders(\n                [\"Objects that can get control over \" + OU_node.name]\n            )\n            inbound_grid_data = []\n\n            for name in inbound_list:\n                inbound_grid_data.append(\n                    {\"Objects that can get control over \" + OU_node.name: name}\n                )\n            inbound_grid.setData(inbound_grid_data)\n            inbound_list_page.addComponent(inbound_grid)\n            inbound_list_page.render()\n\n            # Generate page with outbound list\n            outbound_list_page = Page(\n                self.arguments.cache_prefix,\n                \"path_objects_to_ou_handlers_outbound_list_\" + OU_node.name,\n                \"Objects that can get control over \" + OU_node.name,\n                self.get_dico_description(),\n            )\n            outbound_grid = Grid(\"Objects controlled by \" + OU_node.name)\n            outbound_grid.setheaders([\"Objects controlled by \" + OU_node.name])\n            outbound_grid_data = []\n\n            for name in outbound_list:\n                outbound_grid_data.append(\n                    {\"Objects controlled by \" + OU_node.name: name}\n                )\n            outbound_grid.setData(outbound_grid_data)\n            outbound_list_page.addComponent(outbound_grid)\n            outbound_list_page.render()\n\n            # Generate inbound graph page\n            createGraphPage(\n                self.arguments.cache_prefix,\n                \"paths_to_OU_\" + OU_node.name,\n                \"Paths to OU handlers\",\n                self.get_dico_description(),\n                analysis_dict[OU_node][\"inbound_paths\"],\n                self.requests_results,\n            )\n\n            # Generate outbound graph page\n            createGraphPage(\n                self.arguments.cache_prefix,\n                \"paths_from_OU_\" + OU_node.name,\n                \"Paths from OU handlers\",\n                self.get_dico_description(),\n                analysis_dict[OU_node][\"outbound_paths\"],\n                self.requests_results,\n            )\n\n            tmp_data = {}\n            tmp_data[\"OU name\"] = OU_node.name\n\n            inbound_objects_count = len(inbound_list)\n            tmp_data[\"Inbound list\"] = grid_data_stringify(\n                {\n                    \"value\": f\"{inbound_objects_count} object{'s' if inbound_objects_count > 1 else ''}\",\n                    \"link\": \"path_objects_to_ou_handlers_inbound_list_\"\n                    + str(quote(OU_node.name))\n                    + \".html\",\n                    \"before_link\": '<i class=\"bi bi-list-columns-reverse\" aria-hidden=\"true\"></i>',\n                }\n            )\n            outbound_objects_count = len(outbound_list)\n            tmp_data[\"Outbound list\"] = grid_data_stringify(\n                {\n                    \"value\": f\"{outbound_objects_count} object{'s' if outbound_objects_count > 1 else ''}\",\n                    \"link\": \"path_objects_to_ou_handlers_outbound_list_\"\n                    + str(quote(OU_node.name))\n                    + \".html\",\n                    \"before_link\": '<i class=\"bi bi-list-columns-reverse\" aria-hidden=\"true\"></i>',\n                }\n            )\n            inbound_paths_count = len(analysis_dict[OU_node][\"inbound_paths\"])\n            tmp_data[\"Inbound graph\"] = grid_data_stringify(\n                {\n                    \"value\": f\"{inbound_paths_count} path{'s' if inbound_paths_count > 1 else ''}\",\n                    \"link\": \"paths_to_OU_\" + str(quote(OU_node.name)) + \".html\",\n                    \"before_link\": '<i class=\"bi bi-diagram-3-fill\" aria-hidden=\"true\"></i>',\n                }\n            )\n            outbound_paths_count = len(analysis_dict[OU_node][\"outbound_paths\"])\n            tmp_data[\"Outbound graph\"] = grid_data_stringify(\n                {\n                    \"value\": f\"{outbound_paths_count} path{'s' if outbound_paths_count > 1 else ''}\",\n                    \"link\": \"paths_from_OU_\" + str(quote(OU_node.name)) + \".html\",\n                    \"before_link\": '<i class=\"bi bi-diagram-3-fill\" aria-hidden=\"true\"></i>',\n                }\n            )\n\n            # Rate the interest of the OU\n\n            # 0 star  : no object impacted or other objects\n            # 1 star  : at least one object is admin of computer\n            # 2 stars : at least one object has path to DA\n            # 3 stars : full domain or at least one domain admin impacted\n            paths = analysis_dict[OU_node][\"outbound_paths\"]\n\n            if len(paths) == 0:\n                interest = 0\n            else:\n                interest = 0\n                for path in paths:\n                    for node in path.nodes:\n                        interest = max(\n                            get_interest(\n                                self.requests_results,\n                                node.labels,\n                                node.name,\n                            ),\n                            interest,\n                        )\n\n            # Color for stars\n            if interest == 3:\n                color = \"red\"\n            elif interest == 2:\n                color = \"orange\"\n            else:\n                color = \"green\"\n\n            icon = (\n                f\"<span class='{interest}'></span><i class='bi bi-star-fill' style='color: {color}'></i>\"\n                * interest\n                + f\"<i class='bi bi-star' style='color: {color}'></i>\" * (3 - interest)\n            )\n\n            tmp_data[\"Targets interest\"] = icon\n\n            grid_data.append(tmp_data)\n\n        grid.setData(grid_data)\n        page.addComponent(grid)\n        page.render()\n\n        self.data = len(self.compromise_paths_of_OUs) if self.compromise_paths_of_OUs else 0\n\n        self.name_description = f\"{len(self.compromise_paths_of_OUs or [])} dangerous control paths over OUs\"\n\n    def get_rating(self) -> int:\n        return presence_of(self.compromise_paths_of_OUs)\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/path_neo4j.py": {
        "imported_elements": [
          "Path"
        ],
        "code_map": {
          "Path": "class Path:\n    def __init__(self, nodes):\n        self.nodes = nodes\n\n    def __eq__(self, other):\n        if not isinstance(other, Path):\n            return NotImplemented\n        if len(self.nodes) != len(other.nodes):\n            return False\n\n        ret = True\n        for i in range(len(self.nodes)):\n            ret = ret and (self.nodes[i] == other.nodes[i])\n        return ret\n\n    def reverse(self):\n        self.nodes.reverse()\n        for i in range(len(self.nodes) - 1):\n            self.nodes[i].relation_type = self.nodes[i + 1].relation_type\n        self.nodes[-1].relation_type = \"\""
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "ad_miner/sources/modules/utils.py": {
        "imported_elements": [
          "grid_data_stringify"
        ],
        "code_map": {
          "grid_data_stringify": "def grid_data_stringify(raw_data: dict) -> str:\n    \"\"\"\n    Transform a dict to a string for the grid formating. This is a dumb fix for the sorting with hyperlink.\n    dict format :\n    {\n        \"link\",\n        \"value\",\n        \"before_link\"\n    }\n    \"\"\"\n    link = raw_data['link'].replace(sep, '_').replace('/', '_')\n    try:\n        return f\"{raw_data['before_link']} <a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\"\n    except KeyError:\n        return f\"<a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\""
        }
      },
      "ad_miner/sources/modules/common_analysis.py": {
        "imported_elements": [
          "("
        ],
        "code_map": {}
      },
      "/Users/steverassinot/Repos/AD_Miner/urllib/parse/__init__.py": {
        "imported_elements": [
          "quote"
        ],
        "code_map": {}
      },
      "/Users/steverassinot/Repos/AD_Miner/tqdm/__init__.py": {
        "imported_elements": [
          "tqdm"
        ],
        "code_map": {}
      }
    },
    "requests_keys": [
      "set_containsdc",
      "vulnerable_OU_impact",
      "compromise_paths_of_OUs",
      "set_containsda"
    ]
  },
  {
    "title": "Unexpected PrimaryGroupID",
    "file_name": "primaryGroupID_lower_than_1000.py",
    "control_category": "Misc",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\n\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\nfrom ad_miner.sources.modules.utils import MODULES_DIRECTORY\n\nimport json\n\n\n@register_control\nclass primaryGroupID_lower_than_1000(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"misc\"\n        self.control_key = \"rid_singularities\"\n\n        self.title = \"Unexpected PrimaryGroupID\"\n        self.description = (\n            \"Accounts with either an unknown RID, or RID-name missmatches.\"\n        )\n        self.risk = \"In Active Directory, the primaryGroupId attribute of a user or machine account implicitly assigns this account to a group, even if this group is not listed in the user's memberOf attribute. Membership of a group via this attribute does not appear in the list of group members in certain interfaces. This attribute can be used to hide an account's membership of a group.\"\n        self.poa = \"We recommend that you reset the primaryGroupId attributes of the users or computers concerned to their default values.\"\n\n        self.primaryGroupID_lower_than_1000 = requests_results[\n            \"primaryGroupID_lower_than_1000\"\n        ]\n\n    def run(self):\n        if self.primaryGroupID_lower_than_1000 is None:\n            self.primaryGroupID_lower_than_1000 = []\n\n        known_RIDs = json.loads(\n            (MODULES_DIRECTORY / \"known_RIDs.json\").read_text(encoding=\"utf-8\")\n        )\n\n        page = Page(\n            self.arguments.cache_prefix,\n            \"rid_singularities\",\n            \"Unexpected accounts with lower than 1000 RIDs\",\n            self.get_dico_description(),\n        )\n        grid = Grid(\"Unexpected accounts with lower than 1000 RIDs\")\n        grid.setheaders([\"domain\", \"name\", \"RID\", \"reason\"])\n\n        data = []\n\n        for rid, name, domain, is_da in self.primaryGroupID_lower_than_1000:\n            name_without_domain = name.replace(\"@\", \"\").replace(domain, \"\")\n\n            tmp_data = {}\n            if str(rid) not in known_RIDs:\n                tmp_data[\"domain\"] = '<i class=\"bi bi-globe2\"></i> ' + domain\n                tmp_data[\"RID\"] = str(rid)\n                tmp_data[\"name\"] = (\n                    '<i class=\"bi bi-gem\"></i> ' + name if is_da else name\n                )\n                tmp_data[\"reason\"] = \"Unknown RID\"\n                data.append(tmp_data)\n            elif name_without_domain not in known_RIDs[str(rid)]:\n                tmp_data[\"domain\"] = '<i class=\"bi bi-globe2\"></i> ' + domain\n                tmp_data[\"RID\"] = str(rid)\n                tmp_data[\"name\"] = (\n                    '<i class=\"bi bi-gem\"></i> ' + name if is_da else name\n                )\n                tmp_data[\"reason\"] = (\n                    \"Unexpected name, expected : \" + known_RIDs[str(rid)][0]\n                )\n                data.append(tmp_data)\n\n        data = sorted(data, key=lambda x: x[\"RID\"])\n\n        sorted_data = [\n            tmp_data for tmp_data in data if tmp_data[\"reason\"].startswith(\"Unknown\")\n        ]\n        sorted_data += [\n            tmp_data for tmp_data in data if tmp_data[\"reason\"].startswith(\"Unexpected\")\n        ]\n\n        self.rid_singularities = len(sorted_data)\n\n        grid.setData(sorted_data)\n        page.addComponent(grid)\n        page.render()\n\n        # TODO define the metric of your control\n        # it will be stored in the data json\n        self.data = self.rid_singularities\n\n        # TODO define the sentence that will be displayed in the 'smolcard' view and in the center of the mainpage\n        self.name_description = (\n            f\"{self.data} accounts with unknown RIDs or unexpected names\"\n        )\n\n    def get_rating(self) -> int:\n        return 2 if self.rid_singularities > 0 else 5\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "ad_miner/sources/modules/utils.py": {
        "imported_elements": [
          "MODULES_DIRECTORY"
        ],
        "code_map": {
          "MODULES_DIRECTORY": "MODULES_DIRECTORY = Path(__file__).parent"
        }
      }
    },
    "requests_keys": [
      "primaryGroupID_lower_than_1000"
    ]
  },
  {
    "title": "Users with local admin privileges",
    "file_name": "users_admin_of_computers.py",
    "control_category": "Permissions",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\nfrom ad_miner.sources.modules import logger\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\nfrom ad_miner.sources.modules.graph_class import Graph\nfrom ad_miner.sources.modules.node_neo4j import Node\nfrom ad_miner.sources.modules.path_neo4j import Path\nfrom ad_miner.sources.modules import generic_computing\n\nfrom ad_miner.sources.modules.utils import grid_data_stringify\nfrom ad_miner.sources.modules.common_analysis import (\n    findAndCreatePathToDaFromUsersList,\n    hasPathToDA,\n    percentage_superior,\n    days_format,\n)\n\nimport json\nfrom urllib.parse import quote\nfrom tqdm import tqdm\n\n\n@register_control\nclass users_admin_of_computers(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"permissions\"\n        self.control_key = \"users_admin_of_computers\"\n\n        self.title = \"Users with local admin privileges\"\n        self.description = \"Users have administration rights over machines, creating potential compromission paths.\"\n        self.risk = \"You should watch out for accounts who are admin of too many computers or users who should not be admin at all. Wrongfully configured administration privileges are a big vector of vertical and lateral movement.\"\n        self.poa = \"Review this list to ensure admin privilege are effectively provided on a need to know basis.\"\n\n        self.description_users_to_computer = {\n            \"description\": \"Path of users who have direct or indirect administration privilege on computers\",\n            \"interpretation\": \"\",\n            \"risk\": \"Inadequate administration rights on computers can lead to easy privilege escalation for an attacker. With a privileged account, it is possible to perform local memory looting to find credentials for example.\",\n            \"poa\": \"Only a handful of accounts should have administrator privilege on computers to perform some maintenance actions. No normal user should be admin of any computer, not even its own.\",\n        }\n\n        self.users_admin_computer = requests_results[\"users_admin_on_computers\"]\n        self.users_kerberoastable_users = requests_results[\"nb_kerberoastable_accounts\"]\n        self.users_pwd_not_changed_since = requests_results[\"password_last_change\"]\n        self.get_users_linked_admin_group = requests_results[\n            \"get_users_linked_admin_group\"\n        ]\n        self.get_groups_linked_admin_group = requests_results[\n            \"get_groups_linked_admin_group\"\n        ]\n        self.get_computers_linked_admin_group = requests_results[\n            \"get_computers_linked_admin_group\"\n        ]\n        self.get_users_direct_admin = requests_results[\"get_users_direct_admin\"]\n        self.admin_list = requests_results[\"admin_list\"]\n        self.users = requests_results[\"nb_enabled_accounts\"]\n        self.users_to_computer_admin = {}\n\n        self.users_admin_computer_count = generic_computing.getCountValueFromKey(\n            self.users_admin_computer, \"user\"\n        )\n        self.users_admin_computer_list = generic_computing.getListAdminTo(\n            self.users_admin_computer, \"user\", \"computer\"\n        )\n\n    def run(self):\n\n        # Several requests are needed for this function, therefore we fail if there is one missing, and we print the issue\n        fail = []\n        if self.users_admin_computer_list is None:\n            fail.append(\"users_admin_computer_list\")\n\n        if self.users_kerberoastable_users is None:\n            fail.append(\"users_kerberoastable_users\")\n\n        if self.users_pwd_not_changed_since is None:\n            fail.append(\"users_pwd_not_changed_since\")\n\n        if 0 < len(fail) < 3:  # if only some of them are activated\n            logger.print_error(\n                f\" In order to render 'List of users admin of computers' page, you need to activate the following in config.json : {', '.join(fail)}\"\n            )\n            return\n\n        if len(fail) > 0:\n            return\n\n        headers = [\n            \"User\",\n            \"Kerberoastable\",\n            \"Last password change\",\n            \"List of computers\",\n            \"Path to computers\",\n            \"Path to DA\",\n        ]\n        headers_details = [\"User\", \"Computers\"]\n\n        def generateGraphPathToAdmin(self):\n            data = []\n            for couple in self.get_users_linked_admin_group:\n                u = couple[\"u\"]\n                g = couple[\"gg\"]\n\n                start = Node(\n                    couple[\"idu\"], \"User\", u[\"name\"], u[\"domain\"], None, \"MemberOf\"\n                )\n                end = Node(couple[\"idg\"], \"Group\", g[\"name\"], g[\"domain\"], None, \"\")\n\n                # rel = Relation(\n                #     int(str(start.id) + \"00\" + str(end.id)), [start, end], \"MemberOf\"\n                # )\n\n                path = Path([start, end])\n                data.append(path)\n                self.users_to_computer_admin[u[\"name\"]] = couple[\"idu\"]\n\n            for couple in self.get_groups_linked_admin_group:\n                g = couple[\"g\"]\n                gg = couple[\"gg\"]\n\n                start = Node(\n                    couple[\"idg\"], \"Group\", g[\"name\"], g[\"domain\"], None, \"MemberOf\"\n                )\n                end = Node(couple[\"idgg\"], \"Group\", gg[\"name\"], gg[\"domain\"], None, \"\")\n\n                # rel = Relation(\n                #     int(str(start.id) + \"00\" + str(end.id)), [start, end], \"MemberOf\"\n                # )\n\n                path = Path([start, end])\n                data.append(path)\n\n            for couple in self.get_computers_linked_admin_group:\n                g = couple[\"g\"]\n                c = couple[\"c\"]\n\n                start = Node(\n                    couple[\"idg\"], \"Group\", g[\"name\"], g[\"domain\"], None, \"AdminTo\"\n                )\n                end = Node(couple[\"idc\"], \"Computer\", c[\"name\"], c[\"domain\"], None, \"\")\n\n                # rel = Relation(\n                #     int(str(start.id) + \"00\" + str(end.id)), [start, end], \"AdminTo\"\n                # )\n\n                path = Path([start, end])\n                data.append(path)\n\n            for couple in self.get_users_direct_admin:\n                g = couple[\"g\"]\n                c = couple[\"c\"]\n\n                start = Node(\n                    couple[\"idg\"], \"User\", g[\"name\"], g[\"domain\"], None, \"AdminTo\"\n                )\n                end = Node(couple[\"idc\"], \"Computer\", c[\"name\"], c[\"domain\"], None, \"\")\n\n                # rel = Relation(\n                #     int(str(start.id) + \"00\" + str(end.id)), [start, end], \"AdminTo\"\n                # )\n\n                path = Path([start, end])\n                data.append(path)\n                self.users_to_computer_admin[g[\"name\"]] = couple[\"idg\"]\n\n            page = Page(\n                self.arguments.cache_prefix,\n                \"users_to_computers\",\n                \"Paths from users to computers\",\n                self.description_users_to_computer,\n            )\n            graph = Graph()\n            graph.setPaths(data)\n\n            graph.addGhostComputers(self.requests_results[\"dico_ghost_computer\"])\n            graph.addGhostUsers(self.requests_results[\"dico_ghost_user\"])\n            graph.addDCComputers(self.requests_results[\"dico_dc_computer\"])\n            graph.addUserDA(self.requests_results[\"dico_user_da\"])\n            graph.addGroupDA(self.requests_results[\"dico_da_group\"])\n\n            page.addComponent(graph)\n            page.render()\n\n        def check_kerberoastable(account):\n            for elem in self.users_kerberoastable_users:\n                if elem[\"name\"] == account:\n                    return \"<i class='bi bi-ticket-perforated-fill' style='color: #b00404;' title='This account is vulnerable to Kerberoasting'></i> YES\"\n            return \"-\"\n\n        def get_last_pass_change(account):\n            for elem in self.users_pwd_not_changed_since:\n                if elem[\"user\"] == account:\n                    return days_format(elem[\"days\"])\n            return \"<i class='bi bi-calendar3'></i> Unknown\"\n\n        generateGraphPathToAdmin(self)\n\n        tmp_rslt = []\n        for key in tqdm(self.users_admin_computer_list.keys()):\n            partDict = {}\n            partDict[headers[0]] = key\n\n            partDict[headers[1]] = check_kerberoastable(key)\n            partDict[headers[2]] = get_last_pass_change(key)\n\n            partDict[headers[3]] = self.users_admin_computer_list[key]\n            try:  # Case when node is not present in graph\n                partDict[headers[4]] = grid_data_stringify(\n                    {\n                        \"link\": f\"users_to_computers.html?node={quote(str(self.users_to_computer_admin[key]))}\",\n                        \"value\": \"Path to computers\",\n                        \"before_link\": f\"<i class='bi bi-sign-turn-right' aria-hidden='true'></i>\",\n                    }\n                )\n            except KeyError:\n                partDict[headers[4]] = \"No path to show\"\n\n            nb_path_to_da, nb_domain = findAndCreatePathToDaFromUsersList(\n                self.requests_results, self.arguments, key, partDict[headers[3]]\n            )\n\n            if nb_path_to_da > 0:\n                sortClass = str(nb_path_to_da).zfill(6)\n                partDict[headers[5]] = grid_data_stringify(\n                    {\n                        \"link\": \"users_path_to_da_from_%s.html\" % quote(str(key)),\n                        \"value\": f\" {nb_path_to_da} path{'s' if nb_path_to_da > 1 else ''} to DA ({nb_domain} domain{'s' if nb_domain > 1 else ''})\",\n                        \"before_link\": f\"<i class='bi bi-sign-turn-right-fill {sortClass}' style='color:#b00404;' aria-hidden='true'></i>\",\n                    }\n                )\n            else:\n                partDict[headers[5]] = \"-\"\n            tmp_rslt.append(partDict)\n\n        # This loop should return nothing, just in case\n        for key in self.users_to_computer_admin.keys():\n            if key not in self.users_admin_computer_list.keys():\n                partDict = {}\n                partDict[headers[0]] = key\n\n                partDict[headers[1]] = check_kerberoastable(key)\n                partDict[headers[2]] = get_last_pass_change(key)\n\n                partDict[headers[3]] = \"No data to show\"\n                try:  # Case when node is not present in graph\n                    partDict[headers[4]] = grid_data_stringify(\n                        {\n                            \"link\": f\"users_to_computers.html?node={quote(str(self.users_to_computer_admin[key]))}\",\n                            \"value\": \"Path to computers\",\n                            \"before_link\": f\"<i class='bi bi-sign-turn-right' aria-hidden='true'></i>\",\n                        }\n                    )\n                except KeyError:\n                    partDict[headers[4]] = \"No path to show\"\n                (\n                    nb_path_to_da,\n                    nb_domain,\n                ) = self.domain.findAndCreatePathToDaFromUsersList(\n                    key, partDict[headers[3]]\n                )\n                if nb_path_to_da > 0:\n                    sortClass = str(nb_path_to_da).zfill(6)\n                    partDict[headers[5]] = grid_data_stringify(\n                        {\n                            \"link\": \"users_path_to_da_from_%s.html\" % quote(str(key)),\n                            \"value\": f\" {nb_path_to_da} path{'s' if nb_path_to_da > 1 else ''} to DA ({nb_domain} domain{'s' if nb_domain > 1 else ''})\",\n                            \"before_link\": f\"<i class='bi bi-sign-turn-right-fill {sortClass}' style='color:#b00404;' aria-hidden='true'></i>\",\n                        }\n                    )\n                else:\n                    partDict[headers[5]] = \"-\"\n                tmp_rslt.append(partDict)\n\n        formated_data = []\n        formated_data_details = []\n        for dict in tmp_rslt:\n            if dict[headers[3]] != \"No data to show\":\n                sortClass = str(len(dict[headers[3]])).zfill(\n                    6\n                )  # used to make the sorting feature work with icons\n                data_header_computer = grid_data_stringify(\n                    {\n                        \"link\": \"%s.html?parameter=%s\"\n                        % (\n                            \"users_admin_of_computers_details\",\n                            quote(str(dict[headers[0]])),\n                        ),\n                        \"value\": f\" {len(dict[headers[3]])} Computer{'s' if len(dict[headers[3]]) > 1 else ''}\",\n                        \"before_link\": f\"<i class='bi bi-hdd-network {sortClass}'></i>\",\n                    }\n                )\n                formated_data_details.append(\n                    {\n                        headers_details[0]: dict[headers[0]],\n                        headers_details[1]: dict[headers[3]],\n                    }\n                )\n            if dict[headers[0]] in self.admin_list:\n                formated_data.append(\n                    {\n                        headers[\n                            0\n                        ]: '<i class=\"bi bi-gem\" title=\"This user is domain admin\"></i> '\n                        + dict[headers[0]],\n                        headers[1]: dict[headers[1]],\n                        headers[2]: dict[headers[2]],\n                        headers[3]: data_header_computer,\n                        headers[4]: dict[headers[4]],\n                        headers[5]: dict[headers[5]],\n                    }\n                )\n            else:\n                formated_data.append(\n                    {\n                        headers[0]: '<i class=\"bi bi-person-fill\"></i> '\n                        + dict[headers[0]],\n                        headers[1]: dict[headers[1]],\n                        headers[2]: dict[headers[2]],\n                        headers[3]: data_header_computer,\n                        headers[4]: dict[headers[4]],\n                        headers[5]: dict[headers[5]],\n                    }\n                )\n        page = Page(\n            self.arguments.cache_prefix,\n            \"users_admin_of_computers\",\n            \"Users with local admin privileges\",\n            self.get_dico_description(),\n        )\n        grid = Grid(\"Users admins of\")\n        if len(self.users_admin_computer_count) > 0:\n            if formated_data != [] and formated_data is not None:\n                grid.setheaders(headers)\n                grid.setData(json.dumps(formated_data))\n        page.addComponent(grid)\n        page.render()\n        self.users_admin_of_computers = formated_data\n\n        page = Page(\n            self.arguments.cache_prefix,\n            \"users_admin_of_computers_details\",\n            \"Users with local admin privileges\",\n            self.get_dico_description(),\n        )\n        grid = Grid(\"Users admins of\")\n        if len(self.users_admin_computer_count) > 0:\n            if formated_data_details != [] and formated_data_details is not None:\n                grid.setheaders(headers)\n                grid.setData(json.dumps(formated_data_details))\n        page.addComponent(grid)\n        page.render()\n\n        self.data = (\n            len(self.users_admin_computer_count)\n            if self.users_admin_computer_count\n            else 0\n        )\n\n        self.name_description = f\"{self.data} users with local admin privileges\"\n\n    def get_rating(self) -> int:\n        return min(\n            hasPathToDA(self.users_admin_computer),\n            percentage_superior(\n                self.users_admin_computer, self.users, criticity=2, percentage=0.5\n            ),\n        )\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/__init__.py": {
        "imported_elements": [
          "logger",
          "generic_computing"
        ],
        "code_map": {}
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "ad_miner/sources/modules/graph_class.py": {
        "imported_elements": [
          "Graph"
        ],
        "code_map": {
          "Graph": "class Graph:\n    def __init__(self, template=\"graph\", path_limit=80000):\n        self.template_base_path = HTML_DIRECTORY / \"components/graph/\"\n        self.template = template\n        self.paths = []\n        self.nodes = {}\n        self.relations = []\n        self.relations_hashes = {}\n        self.path_limit = path_limit\n        self.ghost_computer = {}\n        self.ghost_user = {}\n        self.dc_computer = {}\n        self.user_da = {}\n        self.group_da = {}\n        self.enabled_users = {}\n        self.kerberoastable_users = {}\n        self.disabled_users_dict = {}\n\n    def addPath(self, path):\n        self.paths.append(path)\n\n    def setPaths(self, paths):\n        self.paths = paths\n\n    def addGhostComputers(self, ghost_computer):\n        self.ghost_computer = ghost_computer\n\n    def addGhostUsers(self, ghost_user):\n        self.ghost_user = ghost_user\n\n    def addDCComputers(self, dc_computer):\n        self.dc_computer = dc_computer\n\n    def addUserDA(self, user_da):\n        self.user_da = user_da\n\n    def addGroupDA(self, group_da):\n        self.group_da = group_da\n\n    def addDisabledUsers(self, disabled_users):\n        self.disabled_users_dict = {}\n        for d in disabled_users:\n            self.disabled_users_dict[d[\"name\"]] = True\n\n    def addKerberoastableUsers(self, kerberoastable_users):\n        self.kerberoastable_users = kerberoastable_users\n\n    def render(self, page_f):\n\n        # Write header\n        with open(\n            self.template_base_path / (self.template + \"_header.html\"), \"r\"\n        ) as header_f:\n            html_header = header_f.read()\n            page_f.write(html_header)\n\n        for index, path in enumerate(self.paths):\n            for i in range(len(path.nodes)):\n\n                node = path.nodes[i]\n\n                # Compute node style\n                if i == 0:\n                    node_position = \"start\"\n                elif i == len(path.nodes) - 1:\n                    node_position = \"end\"\n                else:\n                    node_position = \"intermediate\"\n\n                # Add new labels here. A corresponding svg icon should be defined\n                # dico_icon in the icon.js file.\n                list_labels = [\n                    \"User\",\n                    \"Foreignsecurityprincipal\",\n                    \"GPO\",\n                    \"Computer\",\n                    \"OU\",\n                    \"Group\",\n                    \"Domain\",\n                    \"ADLocalGroup\",\n                    \"Container\",\n                    \"Unknown\",\n                    \"Group_cluster\",\n                    \"Device\",\n                    \"AZTenant\",\n                    \"AZRole\",\n                ]\n\n                if node.labels in list_labels:\n                    label_instance = node.labels\n                elif path.nodes[i].labels[2:] in list_labels:\n                    label_instance = node.labels[2:]\n                else:\n                    label_instance = \"Unknown\"\n\n                node_attributes = []\n\n                # Add DA icon if node is DC, DA or Domain\n                if (\n                    (\n                        label_instance == \"Computer\"\n                        and self.dc_computer.get(node.name, False)\n                    )\n                    or (label_instance == \"User\" and self.user_da.get(node.name, False))\n                    or (\n                        label_instance == \"Group\"\n                        and self.group_da.get(node.name, False)\n                    )\n                    or label_instance == \"Domain\"\n                ):\n                    node_attributes.append(\"da\")\n\n                # Add ghost icon if ghost\n                if (\n                    label_instance == \"User\" and self.ghost_user.get(node.name, False)\n                ) or (\n                    label_instance == \"Computer\"\n                    and self.ghost_computer.get(node.name, False)\n                ):\n                    node_attributes.append(\"ghost\")\n\n                if label_instance == \"User\" and self.disabled_users_dict.get(\n                    node.name, False\n                ):\n                    node_attributes.append(\"disabled\")\n\n                if label_instance == \"User\" and self.kerberoastable_users.get(\n                    node.name, False\n                ):\n                    node_attributes.append(\"kerberoastable\")\n\n                # New nodes attributes that should be added to the node icon\n                # should be added here to the node_attributes list.\n                # A corresponding svg icon should the be added to the\n                # dico_icon in icon.js\n\n                if not self.nodes.get(path.nodes[i].id):\n\n                    final_graph_node = {\n                        \"id\": path.nodes[i].id,\n                        \"label\": path.nodes[i].name,\n                        \"domain\": path.nodes[i].domain,\n                        \"shape\": \"image\",\n                        \"instance\": label_instance,\n                        \"position\": node_position,\n                        \"attributes\": node_attributes,\n                    }\n                    self.nodes[path.nodes[i].id] = final_graph_node\n\n                if i != 0:\n                    relation = {\n                        \"from\": path.nodes[i - 1].id,\n                        \"to\": path.nodes[i].id,\n                        \"label\": path.nodes[i - 1].relation_type,\n                    }\n\n                    # Avoid relation duplicated to keep graph clean\n                    # Use hashes list for better performance\n                    hash_rel = hash(\n                        str(relation[\"from\"])\n                        + str(relation[\"to\"])\n                        + str(relation[\"label\"])\n                    )\n                    if not self.relations_hashes.get(hash_rel):\n                        self.relations.append(relation)\n                        self.relations_hashes[hash_rel] = True\n\n        nodes = list(self.nodes.values())\n        for n in nodes:  # Sanitize None values (otherwise it creates a bug in JS)\n            if n[\"label\"] == None:\n                n[\"label\"] = \"???\"\n        page_f.write(f'<script type=\"text/javascript\">window.data_nodes = {nodes};\\n')\n        page_f.write(f\"window.data_edges = {self.relations};</script>\\n\")"
        }
      },
      "ad_miner/sources/modules/node_neo4j.py": {
        "imported_elements": [
          "Node"
        ],
        "code_map": {
          "Node": "class Node:\n\n    # TODO PARSE LABELS HERE\n    def __init__(self, id, labels, name, domain, tenant_id, relation_type):\n        self.id = id\n        self.labels = labels\n        self.name = name\n        self.domain = str(domain)\n        self.tenant_id = tenant_id\n        self.relation_type = relation_type\n\n    # Needed to use set() on a list of nodes (to remove duplicates from lists)\n    def __hash__(self):\n        return hash(self.id)\n\n    def __eq__(self, other):\n        if not isinstance(other, Node):\n            return NotImplemented\n        ret = (\n            (self.id == other.id)\n            and (self.labels == other.labels)\n            and (self.name == other.name)\n            and (self.domain == other.domain)\n            and (self.tenant_id == other.tenant_id)\n            and (self.relation_type == other.relation_type)\n        )\n        return ret"
        }
      },
      "ad_miner/sources/modules/path_neo4j.py": {
        "imported_elements": [
          "Path"
        ],
        "code_map": {
          "Path": "class Path:\n    def __init__(self, nodes):\n        self.nodes = nodes\n\n    def __eq__(self, other):\n        if not isinstance(other, Path):\n            return NotImplemented\n        if len(self.nodes) != len(other.nodes):\n            return False\n\n        ret = True\n        for i in range(len(self.nodes)):\n            ret = ret and (self.nodes[i] == other.nodes[i])\n        return ret\n\n    def reverse(self):\n        self.nodes.reverse()\n        for i in range(len(self.nodes) - 1):\n            self.nodes[i].relation_type = self.nodes[i + 1].relation_type\n        self.nodes[-1].relation_type = \"\""
        }
      },
      "ad_miner/sources/modules/utils.py": {
        "imported_elements": [
          "grid_data_stringify"
        ],
        "code_map": {
          "grid_data_stringify": "def grid_data_stringify(raw_data: dict) -> str:\n    \"\"\"\n    Transform a dict to a string for the grid formating. This is a dumb fix for the sorting with hyperlink.\n    dict format :\n    {\n        \"link\",\n        \"value\",\n        \"before_link\"\n    }\n    \"\"\"\n    link = raw_data['link'].replace(sep, '_').replace('/', '_')\n    try:\n        return f\"{raw_data['before_link']} <a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\"\n    except KeyError:\n        return f\"<a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\""
        }
      },
      "ad_miner/sources/modules/common_analysis.py": {
        "imported_elements": [
          "("
        ],
        "code_map": {}
      },
      "/Users/steverassinot/Repos/AD_Miner/urllib/parse/__init__.py": {
        "imported_elements": [
          "quote"
        ],
        "code_map": {}
      },
      "/Users/steverassinot/Repos/AD_Miner/tqdm/__init__.py": {
        "imported_elements": [
          "tqdm"
        ],
        "code_map": {}
      }
    },
    "requests_keys": [
      "dico_ghost_computer",
      "nb_enabled_accounts",
      "dico_da_group",
      "password_last_change",
      "admin_list",
      "dico_user_da",
      "get_users_direct_admin",
      "get_groups_linked_admin_group",
      "nb_kerberoastable_accounts",
      "get_computers_linked_admin_group",
      "dico_dc_computer",
      "dico_ghost_user",
      "get_users_linked_admin_group",
      "users_admin_on_computers"
    ]
  },
  {
    "title": "Shadow Credentials on regular accounts",
    "file_name": "users_shadow_credentials_to_non_admins.py",
    "control_category": "Kerberos",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\n\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.graph_class import Graph\nfrom ad_miner.sources.modules.grid_class import Grid\nfrom ad_miner.sources.modules.utils import grid_data_stringify\n\nfrom ad_miner.sources.modules.common_analysis import presence_of\n\nfrom urllib.parse import quote\n\n\n@register_control\nclass TestControle1(Control):\n    \"This is my control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n        self.azure_or_onprem = \"on_premise\"\n        self.control_key = \"users_shadow_credentials_to_non_admins\"\n        self.category = \"kerberos\"\n\n        self.title = \"Shadow Credentials on regular accounts\"\n        self.description = \"Users that can perform a shadow credentials attack and impersonate unprivileged accounts. It allows user to use a key for authentication.\"\n        self.interpretation = \"\"\n        self.risk = \"This feature can be used by malicious actors to stealthily setup a persistant access.\"\n        self.poa = \"Review these privileges and it is advised to check if no malicious actors have used this feature for a previous attack.\"\n\n        self.users_shadow_credentials_to_non_admins = requests_results[\n            \"users_shadow_credentials_to_non_admins\"\n        ]\n\n    def run(self):\n        if self.users_shadow_credentials_to_non_admins is None:\n            return\n\n        data = {}\n        for path in self.users_shadow_credentials_to_non_admins:\n            try:\n                data[path.nodes[-1]][\"paths\"].append(path)\n            except KeyError:\n                data[path.nodes[-1]] = {\n                    \"domain\": path.nodes[-1].domain,\n                    \"target\": path.nodes[-1].name,\n                    \"paths\": [path],\n                }\n        grid_data = []\n        max_paths = 0\n        for target in data.keys():\n            nb_paths = len(data[target][\"paths\"])\n            max_paths = max(max_paths, nb_paths)\n            sortClass = str(nb_paths).zfill(6)\n            grid_data.append(\n                {\n                    \"domain\": '<i class=\"bi bi-globe2\"></i> ' + data[target][\"domain\"],\n                    \"target\": '<i class=\"bi bi-bullseye\"></i> '\n                    + data[target][\"target\"],\n                    \"paths\": grid_data_stringify(\n                        {\n                            \"value\": f\"{nb_paths} paths to target\",\n                            \"link\": f\"users_shadow_credentials_to_non_admins_to_{quote(str(data[target]['target']))}.html\",\n                            \"before_link\": f\"<i class='bi bi-shuffle {sortClass}' aria-hidden='true'></i>\",\n                        }\n                    ),\n                }\n            )\n            graph_page = Page(\n                self.arguments.cache_prefix,\n                f\"users_shadow_credentials_to_non_admins_to_{data[target]['target']}\",\n                \"List of targets that can be compromised through shadow credentials\",\n                self.get_dico_description(),\n            )\n            graph = Graph()\n            graph.setPaths(data[target][\"paths\"])\n            graph_page.addComponent(graph)\n            graph_page.render()\n\n        if self.users_shadow_credentials_to_non_admins != None:\n            self.max_number_users_shadow_credentials_to_non_admins = max_paths\n        else:\n            self.max_number_users_shadow_credentials_to_non_admins = 0\n\n        page = Page(\n            self.arguments.cache_prefix,\n            \"users_shadow_credentials_to_non_admins\",\n            \"List of targets that can be compromised through shadow credentials\",\n            self.get_dico_description(),\n        )\n        grid = Grid(\"Users\")\n        grid.setheaders([\"domain\", \"target\", \"paths\"])\n        grid.setData(grid_data)\n        page.addComponent(grid)\n        page.render()\n\n        self.data = (\n            self.max_number_users_shadow_credentials_to_non_admins\n            if self.max_number_users_shadow_credentials_to_non_admins\n            else 0\n        )\n        self.name_description = f\"{self.data} users can impersonate other accounts\"\n\n    def get_rating(self) -> int:\n        return presence_of(self.users_shadow_credentials_to_non_admins, criticity=2)\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/graph_class.py": {
        "imported_elements": [
          "Graph"
        ],
        "code_map": {
          "Graph": "class Graph:\n    def __init__(self, template=\"graph\", path_limit=80000):\n        self.template_base_path = HTML_DIRECTORY / \"components/graph/\"\n        self.template = template\n        self.paths = []\n        self.nodes = {}\n        self.relations = []\n        self.relations_hashes = {}\n        self.path_limit = path_limit\n        self.ghost_computer = {}\n        self.ghost_user = {}\n        self.dc_computer = {}\n        self.user_da = {}\n        self.group_da = {}\n        self.enabled_users = {}\n        self.kerberoastable_users = {}\n        self.disabled_users_dict = {}\n\n    def addPath(self, path):\n        self.paths.append(path)\n\n    def setPaths(self, paths):\n        self.paths = paths\n\n    def addGhostComputers(self, ghost_computer):\n        self.ghost_computer = ghost_computer\n\n    def addGhostUsers(self, ghost_user):\n        self.ghost_user = ghost_user\n\n    def addDCComputers(self, dc_computer):\n        self.dc_computer = dc_computer\n\n    def addUserDA(self, user_da):\n        self.user_da = user_da\n\n    def addGroupDA(self, group_da):\n        self.group_da = group_da\n\n    def addDisabledUsers(self, disabled_users):\n        self.disabled_users_dict = {}\n        for d in disabled_users:\n            self.disabled_users_dict[d[\"name\"]] = True\n\n    def addKerberoastableUsers(self, kerberoastable_users):\n        self.kerberoastable_users = kerberoastable_users\n\n    def render(self, page_f):\n\n        # Write header\n        with open(\n            self.template_base_path / (self.template + \"_header.html\"), \"r\"\n        ) as header_f:\n            html_header = header_f.read()\n            page_f.write(html_header)\n\n        for index, path in enumerate(self.paths):\n            for i in range(len(path.nodes)):\n\n                node = path.nodes[i]\n\n                # Compute node style\n                if i == 0:\n                    node_position = \"start\"\n                elif i == len(path.nodes) - 1:\n                    node_position = \"end\"\n                else:\n                    node_position = \"intermediate\"\n\n                # Add new labels here. A corresponding svg icon should be defined\n                # dico_icon in the icon.js file.\n                list_labels = [\n                    \"User\",\n                    \"Foreignsecurityprincipal\",\n                    \"GPO\",\n                    \"Computer\",\n                    \"OU\",\n                    \"Group\",\n                    \"Domain\",\n                    \"ADLocalGroup\",\n                    \"Container\",\n                    \"Unknown\",\n                    \"Group_cluster\",\n                    \"Device\",\n                    \"AZTenant\",\n                    \"AZRole\",\n                ]\n\n                if node.labels in list_labels:\n                    label_instance = node.labels\n                elif path.nodes[i].labels[2:] in list_labels:\n                    label_instance = node.labels[2:]\n                else:\n                    label_instance = \"Unknown\"\n\n                node_attributes = []\n\n                # Add DA icon if node is DC, DA or Domain\n                if (\n                    (\n                        label_instance == \"Computer\"\n                        and self.dc_computer.get(node.name, False)\n                    )\n                    or (label_instance == \"User\" and self.user_da.get(node.name, False))\n                    or (\n                        label_instance == \"Group\"\n                        and self.group_da.get(node.name, False)\n                    )\n                    or label_instance == \"Domain\"\n                ):\n                    node_attributes.append(\"da\")\n\n                # Add ghost icon if ghost\n                if (\n                    label_instance == \"User\" and self.ghost_user.get(node.name, False)\n                ) or (\n                    label_instance == \"Computer\"\n                    and self.ghost_computer.get(node.name, False)\n                ):\n                    node_attributes.append(\"ghost\")\n\n                if label_instance == \"User\" and self.disabled_users_dict.get(\n                    node.name, False\n                ):\n                    node_attributes.append(\"disabled\")\n\n                if label_instance == \"User\" and self.kerberoastable_users.get(\n                    node.name, False\n                ):\n                    node_attributes.append(\"kerberoastable\")\n\n                # New nodes attributes that should be added to the node icon\n                # should be added here to the node_attributes list.\n                # A corresponding svg icon should the be added to the\n                # dico_icon in icon.js\n\n                if not self.nodes.get(path.nodes[i].id):\n\n                    final_graph_node = {\n                        \"id\": path.nodes[i].id,\n                        \"label\": path.nodes[i].name,\n                        \"domain\": path.nodes[i].domain,\n                        \"shape\": \"image\",\n                        \"instance\": label_instance,\n                        \"position\": node_position,\n                        \"attributes\": node_attributes,\n                    }\n                    self.nodes[path.nodes[i].id] = final_graph_node\n\n                if i != 0:\n                    relation = {\n                        \"from\": path.nodes[i - 1].id,\n                        \"to\": path.nodes[i].id,\n                        \"label\": path.nodes[i - 1].relation_type,\n                    }\n\n                    # Avoid relation duplicated to keep graph clean\n                    # Use hashes list for better performance\n                    hash_rel = hash(\n                        str(relation[\"from\"])\n                        + str(relation[\"to\"])\n                        + str(relation[\"label\"])\n                    )\n                    if not self.relations_hashes.get(hash_rel):\n                        self.relations.append(relation)\n                        self.relations_hashes[hash_rel] = True\n\n        nodes = list(self.nodes.values())\n        for n in nodes:  # Sanitize None values (otherwise it creates a bug in JS)\n            if n[\"label\"] == None:\n                n[\"label\"] = \"???\"\n        page_f.write(f'<script type=\"text/javascript\">window.data_nodes = {nodes};\\n')\n        page_f.write(f\"window.data_edges = {self.relations};</script>\\n\")"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "ad_miner/sources/modules/utils.py": {
        "imported_elements": [
          "grid_data_stringify"
        ],
        "code_map": {
          "grid_data_stringify": "def grid_data_stringify(raw_data: dict) -> str:\n    \"\"\"\n    Transform a dict to a string for the grid formating. This is a dumb fix for the sorting with hyperlink.\n    dict format :\n    {\n        \"link\",\n        \"value\",\n        \"before_link\"\n    }\n    \"\"\"\n    link = raw_data['link'].replace(sep, '_').replace('/', '_')\n    try:\n        return f\"{raw_data['before_link']} <a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\"\n    except KeyError:\n        return f\"<a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\""
        }
      },
      "ad_miner/sources/modules/common_analysis.py": {
        "imported_elements": [
          "presence_of"
        ],
        "code_map": {
          "presence_of": "def presence_of(req, criticity=1, threshold=0):\n    if req is None:\n        return -1\n    if len(req) > threshold:\n        return criticity\n    return 5"
        }
      },
      "/Users/steverassinot/Repos/AD_Miner/urllib/parse/__init__.py": {
        "imported_elements": [
          "quote"
        ],
        "code_map": {}
      }
    },
    "requests_keys": [
      "users_shadow_credentials_to_non_admins"
    ]
  },
  {
    "title": "Paths to servers",
    "file_name": "server_users_could_be_admin.py",
    "control_category": "Permissions",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\n\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\nfrom ad_miner.sources.modules import generic_formating\nfrom ad_miner.sources.modules.common_analysis import hasPathToDA\n\nimport json\n\n\n@register_control\nclass server_users_could_be_admin(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"permissions\"\n        self.control_key = \"server_users_could_be_admin\"\n\n        self.title = \"Paths to servers\"\n        self.description = (\n            \"Users could gain administration privileges on some servers.\"\n        )\n        self.interpretation = \"\"\n        self.risk = \"Inadequate administration rights on computers can lead to easy privilege escalation for an attacker. With a privileged account, it is possible to perform local memory looting to find credentials for example.\"\n        self.poa = \"Only a handful of accounts should have administrator privilege on computers to perform some maintenance actions. No normal user should be admin of any computer, not even its own.\"\n\n        self.users_admin_on_servers = requests_results[\"users_admin_on_servers\"]\n        self.users_admin_on_servers_list = requests_results[\n            \"users_admin_on_servers_list\"\n        ]\n        self.servers_with_most_paths = requests_results[\"servers_with_most_paths\"]\n        self.users_admin_on_servers_all_data = requests_results[\n            \"users_admin_on_servers_all_data\"\n        ]\n\n    def run(self):\n        if self.users_admin_on_servers is None:\n            return\n        icon = '<i class=\"bi bi-people-fill\"></i>'\n        formated_data = generic_formating.formatGridValues2Columns(\n            self.users_admin_on_servers,\n            [\"Computers\", \"Users who have a server compromise path\"],\n            \"server_compromisable\",\n            icon=icon,\n            icon2='<i class=\"bi bi-pc-display\"></i> ',\n        )\n\n        page = Page(\n            self.arguments.cache_prefix,\n            \"server_users_could_be_admin\",\n            \"Paths to servers\",\n            self.get_dico_description(),\n        )\n        grid = Grid(\"Servers with the most user compromise paths\")\n        grid.setheaders([\"Computers\", \"Users who have a server compromise path\"])\n        grid.setData(json.dumps(formated_data))\n        page.addComponent(grid)\n        page.render()\n\n        if self.users_admin_on_servers_list is None:\n            return\n        allValues = []\n        for computer, values in self.users_admin_on_servers_list.items():\n            for v in values:\n                allValues.append(\n                    \"<span class='compromisable-by-%s'> %s </span>\" % (computer, v)\n                )\n        page = Page(\n            self.arguments.cache_prefix,\n            \"server_compromisable\",\n            \"Compromisable computers\",\n            self.get_dico_description(),\n        )\n        grid = Grid(\"Server compromisable\")\n        grid.addheader(\"TO CHANGE\")\n        users_admin_of_servers = generic_formating.formatGridValues1Columns(\n            allValues, grid.getHeaders()\n        )\n        grid.setData(users_admin_of_servers)\n        page.addComponent(grid)\n        page.render()\n\n        self.data = self.servers_with_most_paths if self.servers_with_most_paths else 0\n\n        self.name_description = f\"Up to {self.data} users can compromise servers\"\n\n    def get_rating(self) -> int:\n        return hasPathToDA(self.users_admin_on_servers_all_data)\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/__init__.py": {
        "imported_elements": [
          "generic_formating"
        ],
        "code_map": {}
      },
      "ad_miner/sources/modules/common_analysis.py": {
        "imported_elements": [
          "hasPathToDA"
        ],
        "code_map": {
          "hasPathToDA": "def hasPathToDA(\n    req, criticity=1\n):  # ne marche que partiellement : besoin de rajouter l'attribut has_path_to_DA dans toutes les requêtes pertinentes + dans domains.py/findAndCreatePathToDaFromComputersList\n    if req is None:\n        return -1\n\n    for object in req:\n        # print(object)\n        if not object.get(\"has_path_to_da\"):\n            continue\n        if object[\"has_path_to_da\"] == True:\n            # print(object)\n            return criticity\n\n    if len(req) > 0:\n        return criticity + 1\n\n    return 5"
        }
      }
    },
    "requests_keys": [
      "users_admin_on_servers_list",
      "users_admin_on_servers_all_data",
      "servers_with_most_paths",
      "users_admin_on_servers"
    ]
  },
  {
    "title": "Kerberoastable accounts",
    "file_name": "kerberoastables.py",
    "control_category": "Kerberos",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\n\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\nfrom ad_miner.sources.modules.utils import grid_data_stringify, days_format\nfrom ad_miner.sources.modules.common_analysis import containsDAs\n\nfrom urllib.parse import quote\n\n\n@register_control\nclass kerberoastables(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"kerberos\"\n        self.control_key = \"kerberoastables\"\n\n        self.title = \"Kerberoastable accounts\"\n        self.description = \"Some accounts are vulnerable to a Kerberoasting attack. If their password is weak, it could be recovered in plaintext.\"\n        self.risk = \"This list should be as short as possible and restricted to service accounts. This list contains accounts that have Service Principal Name (SPN) set. Accounts like this could be compromised in case their password is weak.\"\n        self.poa = \"If the accounts listed here are not service accounts (i.e. if they don't have a strong, automatically-generated password), you should investigate as to why the account has an SPN. You should change the password for these accounts to something very strong, or remove the SPN from these accounts if it is not necessary.\"\n\n        self.child_page_dico_description: dict[str, str] = {\n            \"description\": \"The Service Principle Name associated to a given host. It identifies every service to its host. The presence of a SPN for a given account allows users to request a ticket that contains some cryptographical information about the account's password.\",\n            \"risk\": \"Because users' passwords are often weak, the ability to retrieve a ticket creates a risk of easily cracking the password of the user who has a SPN.\",\n            \"poa\": \"Review all account's SPNs to check if they are still relevant and if they are, ensure that the account's password is strong.\",\n        }\n\n        self.users_kerberoastable_users = requests_results[\"nb_kerberoastable_accounts\"]\n\n    def run(self):\n        if self.users_kerberoastable_users is None:\n            return\n\n        SPNs = []\n        child_headers = [\"Account\", \"SPN\"]\n        for user in self.users_kerberoastable_users:\n            n = 0\n            if not user.get(\"SPN\"):\n                continue\n            for s in user[\"SPN\"]:\n                child_dict = {}\n                child_dict[child_headers[0]] = user[\"name\"]\n                child_dict[child_headers[1]] = s\n                SPNs.append(child_dict)\n                n += 1\n            sortClass = str(n).zfill(\n                6\n            )  # used to make the sorting feature work with icons\n            user[\"SPN\"] = grid_data_stringify(\n                {\n                    \"link\": \"%s.html?parameter=%s\"\n                    % (\"kerberoastables_SPN\", quote(str(user[\"name\"]))),\n                    \"value\": f\"{n} SPN{'s' if n > 1 else ''}</span>\",\n                    \"before_link\": f'<i class=\"bi bi-list-task {sortClass}\"></i>',\n                }\n            )\n\n        child_page = Page(\n            self.arguments.cache_prefix,\n            \"kerberoastables_SPN\",\n            \"List of SPN\",\n            self.child_page_dico_description,\n        )\n        child_grid = Grid(\"SPN\")\n        child_grid.setheaders(child_headers)\n        child_grid.setData(SPNs)\n        child_page.addComponent(child_grid)\n        child_page.render()\n\n        page = Page(\n            self.arguments.cache_prefix,\n            \"kerberoastables\",\n            \"List of kerberoastable account\",\n            self.get_dico_description(),\n        )\n        grid = Grid(\"Kerberoastable users\")\n        grid.setheaders(\n            [\"domain\", \"name\", \"Last password change\", \"Account Creation Date\", \"SPN\"]\n        )\n\n        for elem in range(len(self.users_kerberoastable_users)):\n            if self.users_kerberoastable_users[elem][\"is_Domain_Admin\"] == True:\n                self.users_kerberoastable_users[elem][\"name\"] = (\n                    '<i class=\"bi bi-gem\" title=\"This user is domain admin\"></i> '\n                    + self.users_kerberoastable_users[elem][\"name\"]\n                )\n            else:\n                self.users_kerberoastable_users[elem][\"name\"] = (\n                    '<i class=\"bi bi-person-fill\"></i> '\n                    + self.users_kerberoastable_users[elem][\"name\"]\n                )\n\n        data = []\n        for dict in self.users_kerberoastable_users:\n            tmp_data = {\"domain\": '<i class=\"bi bi-globe2\"></i> ' + dict[\"domain\"]}\n            tmp_data[\"name\"] = dict[\"name\"]\n            tmp_data[\"Last password change\"] = days_format(dict[\"pass_last_change\"])\n            tmp_data[\"Account Creation Date\"] = days_format(dict[\"accountCreationDate\"])\n            tmp_data[\"SPN\"] = dict[\"SPN\"]\n            data.append(tmp_data)\n\n        # print(\"users_kerberoastable_users : \", json.dumps(self.users_kerberoastable_users))\n        grid.setData(data)\n        page.addComponent(grid)\n        page.render()\n\n        # TODO define the metric of your control\n        # it will be stored in the data json\n        self.data = (\n            len(self.users_kerberoastable_users)\n            if self.users_kerberoastable_users\n            else 0\n        )\n\n        self.name_description = f\"{self.data} kerberoastable accounts\"\n\n    def get_rating(self) -> int:\n        return containsDAs(self.users_kerberoastable_users)\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "ad_miner/sources/modules/utils.py": {
        "imported_elements": [
          "grid_data_stringify",
          ""
        ],
        "code_map": {
          "grid_data_stringify": "def grid_data_stringify(raw_data: dict) -> str:\n    \"\"\"\n    Transform a dict to a string for the grid formating. This is a dumb fix for the sorting with hyperlink.\n    dict format :\n    {\n        \"link\",\n        \"value\",\n        \"before_link\"\n    }\n    \"\"\"\n    link = raw_data['link'].replace(sep, '_').replace('/', '_')\n    try:\n        return f\"{raw_data['before_link']} <a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\"\n    except KeyError:\n        return f\"<a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\""
        }
      },
      "ad_miner/sources/modules/common_analysis.py": {
        "imported_elements": [
          "containsDAs"
        ],
        "code_map": {
          "containsDAs": "def containsDAs(req, criticity=1):\n    if req is None:\n        return -1\n\n    for object in req:\n        if object.get(\"is_Domain_Admin\"):\n            if object[\"is_Domain_Admin\"] == True:\n                return criticity\n        # if object.get(\"is_da\"):\n        #     if object[\"is_da\"] == True:\n        #         return criticity\n\n    if len(req) > 0:\n        return criticity + 1\n\n    return 5"
        }
      },
      "/Users/steverassinot/Repos/AD_Miner/urllib/parse/__init__.py": {
        "imported_elements": [
          "quote"
        ],
        "code_map": {}
      }
    },
    "requests_keys": [
      "nb_kerberoastable_accounts"
    ]
  },
  {
    "title": "ACL anomalies",
    "file_name": "anomaly_acl.py",
    "control_category": "Permissions",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\nfrom ad_miner.sources.modules import generic_formating, generic_computing\n\nfrom ad_miner.sources.modules.utils import grid_data_stringify\nfrom ad_miner.sources.modules.common_analysis import (\n    get_dico_admin_of_computer_id,\n    createGraphPage,\n    get_interest,\n)\n\nfrom urllib.parse import quote\nfrom tqdm import tqdm\n\n\n@register_control\nclass my_control_class_name(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"permissions\"\n        self.control_key = \"anomaly_acl\"\n\n        self.title = \"ACL anomalies\"\n        self.description = \"An ACL (Access Control List) is a security mechanism that defines permissions and access rights for objects within the Active Directory structure.\"\n        self.risk = \"Misconfigured ACL can create access points or privilege escalation that an attacker could use to compromise the domain.<br /><br /><i class='bi bi-star-fill'></i><i class='bi bi-star-fill'></i><i class='bi bi-star-fill'></i> : At least one domain admin as target<br /><i class='bi bi-star-fill'></i><i class='bi bi-star-fill'></i><i class='bi bi-star'></i> : At least one object has a path to domain admin<br /><i class='bi bi-star-fill'></i><i class='bi bi-star'></i><i class='bi bi-star'></i> : At least one object admin of a computer<br /><i class='bi bi-star'></i><i class='bi bi-star'></i><i class='bi bi-star'></i> : Other\"\n        self.poa = \"Regularly review and clean up ACL entries for users and groups that no longer require them.\"\n\n        self.anomaly_acl_1 = requests_results[\"anomaly_acl_1\"]\n        self.anomaly_acl_2 = requests_results[\"anomaly_acl_2\"]\n\n        self.users_admin_on_computers = requests_results[\"users_admin_on_computers\"]\n        self.dico_is_user_admin_on_computer = requests_results[\n            \"dico_is_user_admin_on_computer\"\n        ]\n        self.dico_paths_computers_to_DA = requests_results[\"dico_paths_computers_to_DA\"]\n\n        self.admin_list = requests_results[\"admin_list\"]\n\n        self.users_admin_computer_list = generic_computing.getListAdminTo(\n            self.users_admin_on_computers, \"user\", \"computer\"\n        )\n\n        self.dico_admin_of_computer_id = get_dico_admin_of_computer_id(\n            self.requests_results\n        )\n\n        self.dico_users_to_da = requests_results[\"dico_users_to_da\"]\n        self.dico_computers_to_da = requests_results[\"dico_computers_to_da\"]\n        self.dico_groups_to_da = requests_results[\"dico_groups_to_da\"]\n        self.dico_ou_to_da = requests_results[\"dico_ou_to_da\"]\n        self.dico_gpo_to_da = requests_results[\"dico_gpo_to_da\"]\n        self.domains_to_domain_admin = requests_results[\"domains_to_domain_admin\"]\n\n        self.list_computers_admin_computers = requests_results[\n            \"computers_admin_on_computers\"\n        ]\n        self.computers_admin_to_count = generic_computing.getCountValueFromKey(\n            self.list_computers_admin_computers, \"source_computer\"\n        )\n\n        self.unwanted_edges_list = [\n            \"DelegatedEnrollmentAgent\",\n            \"Enroll\",\n            \"EnrollOnBehalfOf\",\n            \"EnterpriseCAFor\",\n            \"ExtendedByPolicy\",\n            \"GetChanges\",\n            \"GetChangesAll\",\n            \"GetChangesInFilteredSet\",\n            \"HostsCAService\",\n            \"IssuedSignedBy\",\n            \"LocalToComputer\",\n            \"ManageCA\",\n            \"ManageCertificates\",\n            \"MemberOfLocalGroup\",\n            \"NTAuthStoreFor\",\n            \"OIDGroupLink\",\n            \"PublishedTo\",\n            \"RemoteInteractiveLogonPrivilege\",\n            \"RootCAFor\",\n            \"TrustedForNTAuth\",\n            \"WritePKIEnrollmentFlag\",\n            \"WritePKINameFlag\",\n        ]\n        self.unwanted_edges_dico = {e: True for e in self.unwanted_edges_list}\n\n    def run(self):\n\n        if self.anomaly_acl_1 is None and self.anomaly_acl_2 is None:\n            page = Page(\n                self.arguments.cache_prefix,\n                \"anomaly_acl\",\n                \"ACL Anomaly \",\n                self.get_dico_description(),\n            )\n            page.render()\n            return 0\n\n        for each in range(len(self.anomaly_acl_1)):\n            self.anomaly_acl_1[each][\"g.members_count\"] = \"-\"\n\n        self.anomaly_acl = self.anomaly_acl_1 + self.anomaly_acl_2\n\n        formated_data_details = []\n        formated_data = {}\n        anomaly_acl_extract = []\n        graph_page_already_generated = {}\n        self.max_interest = 0\n\n        for k in range(len(self.anomaly_acl)):\n\n            label = generic_formating.clean_label(self.anomaly_acl[k][\"LABELS(g)\"])\n\n            target_label = self.anomaly_acl[k][\"labels(n)\"]\n            target_label = filter(lambda x: x != \"Base\" and x != \"AZBase\", target_label)\n            target_label = list(target_label)  # filter returning generator in python3\n            target_label = target_label[0]\n\n            edge_type = self.anomaly_acl[k][\"type(r2)\"]\n            if edge_type in self.unwanted_edges_dico:\n                continue\n\n            name_label_instance = f\"{self.anomaly_acl[k]['g.name']}{label}{edge_type}\"\n\n            if (\n                formated_data.get(name_label_instance)\n                and formated_data[name_label_instance][\"type\"]\n                == self.anomaly_acl[k][\"type(r2)\"]\n                and formated_data[name_label_instance][\"label\"] == label\n            ):\n                formated_data[name_label_instance][\"targets\"].append(\n                    (self.anomaly_acl[k][\"n.name\"], target_label)\n                )\n            elif (\n                formated_data.get(name_label_instance)\n                and formated_data[name_label_instance][\"targets\"]\n                == [self.anomaly_acl[k][\"n.name\"]]\n                and self.anomaly_acl[k][\"type(r2)\"]\n                not in formated_data[name_label_instance][\"type\"]\n                and formated_data[name_label_instance][\"label\"] == label\n            ):\n                formated_data[name_label_instance][\n                    \"type\"\n                ] += f\" | {self.anomaly_acl[k]['type(r2)']}\"\n            else:\n                # it is possible to have an OU and a Group with the same name for example, that's why it is necessary to have the name + the label as key\n                formated_data[name_label_instance] = {\n                    \"name\": self.anomaly_acl[k][\"g.name\"],\n                    \"label\": label,\n                    \"type\": self.anomaly_acl[k][\"type(r2)\"],\n                    \"members_count\": self.anomaly_acl[k][\"g.members_count\"],\n                    \"targets\": [(self.anomaly_acl[k][\"n.name\"], target_label)],\n                }\n        for name_label_instance in tqdm(formated_data):\n            name_instance = formated_data[name_label_instance][\"name\"]\n\n            formated_data_details = []\n            interest = 0\n            for name, target_label in formated_data[name_label_instance][\"targets\"]:\n                interest = max(\n                    get_interest(self.requests_results, target_label, name), interest\n                )\n                tmp_dict = {}\n                paths = []\n                tmp_dict[\"Computers admin\"] = \"-\"\n                tmp_dict[\"Path to DA\"] = \"-\"\n                icon = \"\"\n\n                if target_label == \"User\":\n                    if name in self.admin_list:\n                        icon = \"bi-gem\"\n                    else:\n                        icon = \"bi-person-fill\"\n                        tmp_dict[\"targets\"] = (\n                            '<i class=\"bi bi-person-fill\"></i> ' + name\n                        )\n                    if name in self.dico_is_user_admin_on_computer:\n                        count = len(self.users_admin_computer_list[name])\n                        tmp_dict[\"Computers admin\"] = grid_data_stringify(\n                            {\n                                \"link\": f\"users_to_computers.html?node={self.dico_admin_of_computer_id[name]}\",\n                                \"value\": f\"Admin of {count} computer{'s' if count > 1 else ''}\",\n                                \"before_link\": f\"<i class='bi bi-pc-display-horizontal {str(count).zfill(6)}'></i>\",\n                            }\n                        )\n                    if name in self.dico_users_to_da:\n                        paths = self.dico_users_to_da[name]\n\n                elif target_label == \"Group\":\n                    icon = \"bi-people-fill\"\n\n                    if name in self.dico_groups_to_da:\n                        paths = self.dico_groups_to_da[name]\n\n                elif target_label == \"Computer\":\n                    icon = \"bi-pc-display\"\n\n                    if name in self.dico_computers_to_da:\n                        paths = self.dico_computers_to_da[name]\n\n                    if name in self.computers_admin_to_count:\n                        admin_count = self.computers_admin_to_count[name]\n                        sortClass = str(admin_count).zfill(6)\n                        tmp_dict[\"Computers admin\"] = grid_data_stringify(\n                            {\n                                \"value\": f\"{admin_count} computers\",\n                                \"link\": f\"computer_admin_{quote(str(name))}.html\",\n                                \"before_link\": f\"<i class='bi bi-pc-display {sortClass}'></i>\",\n                            }\n                        )\n\n                elif target_label == \"OU\":\n                    icon = \"bi-building\"\n\n                    if name in self.dico_ou_to_da:\n                        paths = self.dico_ou_to_da[name]\n\n                elif target_label == \"Container\":\n                    icon = \"bi-box\"\n\n                elif target_label == \"GPO\":\n                    icon = \"bi-journal-text\"\n\n                    if name in self.dico_gpo_to_da:\n                        paths = self.dico_gpo_to_da[name]\n\n                elif target_label == \"CertTemplate\":\n                    icon = \"bi-person-vcard\"\n\n                elif target_label == \"Domain\":\n                    icon = \"bi-globe\"\n                    if name in self.domains_to_domain_admin:\n                        paths = self.domains_to_domain_admin[name]\n\n                elif target_label == \"EnterpriseCA\":\n                    icon = \"bi-house-gear-fill\"\n\n                elif target_label == \"IssuancePolicy\":\n                    icon = \"bi-card-checklist\"\n\n                elif target_label == \"AIACA\":\n                    icon = \"bi-textarea\"\n\n                elif target_label == \"NTAuthStore\":\n                    icon = \"bi-shop-window\"\n\n                elif target_label == \"RootCA\":\n                    icon = \"bi-building-fill-gear\"\n\n                else:\n                    print(\n                        \"Object\",\n                        target_label,\n                        \"is unknown by anomaly_acl and will not be analyzed.\",\n                    )\n\n                if len(paths) > 0:\n                    teststring = target_label + name\n                    tmp_dict[\"Path to DA\"] = grid_data_stringify(\n                        {\n                            \"link\": f\"object_to_domain_admin_from_{quote(str(teststring.replace(' ', '_')))}.html\",\n                            \"value\": f'{len(paths)} path{\"s\" if len(paths) > 1 else \"\"} to Domain Admin',\n                            \"before_link\": f\"<i class='<i bi bi-shuffle {str(len(paths)).zfill(6)}'></i> \",\n                        }\n                    )\n                    if teststring not in graph_page_already_generated:\n                        # avoid generating pages multiple time\n                        graph_page_already_generated[teststring] = True\n                        createGraphPage(\n                            self.arguments.cache_prefix,\n                            f\"object_to_domain_admin_from_{teststring.replace(' ', '_')}\",\n                            f\"Paths to Domain Admin from {name}\",\n                            self.get_dico_description(),\n                            paths,\n                            self.requests_results,\n                        )\n\n                tmp_dict[\"targets\"] = f'<i class=\"bi {icon}\"></i> {name}'\n                formated_data_details.append(tmp_dict)\n\n            page = Page(\n                self.arguments.cache_prefix,\n                f\"anomaly_acl_details_{name_label_instance.replace(' ', '_')}\",\n                \"Group Anomaly ACL Details\",\n                self.get_dico_description(),\n            )\n\n            grid = Grid(\"Target Details\")\n\n            grid.setheaders([\"targets\", \"Computers admin\", \"Path to DA\"])\n            grid.setData(formated_data_details)\n            page.addComponent(grid)\n            page.render()\n\n            if len(formated_data[name_label_instance][\"targets\"]) > 1:\n                icon = \"bi-bullseye\"\n\n            # Color for stars\n            color = {3: \"red\", 2: \"orange\", 1: \"yellow\"}.get(interest, \"green\")\n\n            anomaly_acl_extract.append(\n                {\n                    \"name\": name_instance,\n                    \"label\": f\"{generic_formating.get_label_icon_dictionary()[formated_data[name_label_instance]['label']]} {formated_data[name_label_instance]['label']}\",\n                    \"type\": formated_data[name_label_instance][\"type\"],\n                    \"members count\": (\n                        f'<i class=\"{str(formated_data[name_label_instance][\"members_count\"]).zfill(6)} bi bi-people-fill\"></i> '\n                        + str(formated_data[name_label_instance][\"members_count\"])\n                        if formated_data[name_label_instance][\"members_count\"] != \"-\"\n                        else \"-\"\n                    ),\n                    \"targets count\": grid_data_stringify(\n                        {\n                            \"link\": f\"anomaly_acl_details_{quote(str(name_label_instance.replace(' ', '_')))}.html\",\n                            \"value\": f\"{str(len(formated_data[name_label_instance]['targets'])) +' targets' if len(formated_data[name_label_instance]['targets']) > 1 else formated_data[name_label_instance]['targets'][0][0]}\",\n                            \"before_link\": f\"<i class='<i bi {icon} {str(len(formated_data[name_label_instance]['targets'])).zfill(6)}'></i> \",\n                        }\n                    ),\n                    \"interest\": f\"<span class='{interest}'></span><i class='bi bi-star-fill' style='color: {color}'></i>\"\n                    * interest\n                    + f\"<i class='bi bi-star' style='color: {color}'></i>\"\n                    * (3 - interest),\n                }\n            )\n            self.max_interest = max(interest, self.max_interest)\n\n        page = Page(\n            self.arguments.cache_prefix,\n            \"anomaly_acl\",\n            \"ACL Anomaly\",\n            self.get_dico_description(),\n        )\n        grid = Grid(\"anomaly_acl\")\n        grid.setheaders(\n            [\"name\", \"label\", \"members count\", \"type\", \"targets count\", \"interest\"]\n        )\n\n        grid.setData(anomaly_acl_extract)\n        page.addComponent(grid)\n        page.render()\n\n        self.number_group_ACL_anomaly = len([*formated_data])\n\n        self.data = self.number_group_ACL_anomaly\n        self.name_description = (\n            f\"{self.number_group_ACL_anomaly} groups with potential ACL anomalies\"\n        )\n\n    def get_rating(self) -> int:\n        # -1 = grey, 1 = red, 2 = orange, 3 = yellow, 4 =green, 5 = green,\n        interest_to_rating = {0: 5, 1: 3, 2: 2, 3: 1}\n        return interest_to_rating[self.max_interest]\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/__init__.py": {
        "imported_elements": [
          "generic_formating",
          ""
        ],
        "code_map": {}
      },
      "ad_miner/sources/modules/utils.py": {
        "imported_elements": [
          "grid_data_stringify"
        ],
        "code_map": {
          "grid_data_stringify": "def grid_data_stringify(raw_data: dict) -> str:\n    \"\"\"\n    Transform a dict to a string for the grid formating. This is a dumb fix for the sorting with hyperlink.\n    dict format :\n    {\n        \"link\",\n        \"value\",\n        \"before_link\"\n    }\n    \"\"\"\n    link = raw_data['link'].replace(sep, '_').replace('/', '_')\n    try:\n        return f\"{raw_data['before_link']} <a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\"\n    except KeyError:\n        return f\"<a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\""
        }
      },
      "ad_miner/sources/modules/common_analysis.py": {
        "imported_elements": [
          "("
        ],
        "code_map": {}
      },
      "/Users/steverassinot/Repos/AD_Miner/urllib/parse/__init__.py": {
        "imported_elements": [
          "quote"
        ],
        "code_map": {}
      },
      "/Users/steverassinot/Repos/AD_Miner/tqdm/__init__.py": {
        "imported_elements": [
          "tqdm"
        ],
        "code_map": {}
      }
    },
    "requests_keys": [
      "dico_is_user_admin_on_computer",
      "admin_list",
      "computers_admin_on_computers",
      "dico_computers_to_da",
      "dico_groups_to_da",
      "domains_to_domain_admin",
      "anomaly_acl_1",
      "users_admin_on_computers",
      "dico_users_to_da",
      "dico_ou_to_da",
      "dico_gpo_to_da",
      "anomaly_acl_2",
      "dico_paths_computers_to_DA"
    ]
  },
  {
    "title": "Attack paths choke points",
    "file_name": "dangerous_paths.py",
    "control_category": "Permissions",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\nfrom ad_miner.sources.modules.histogram_class import Histogram\n\nfrom ad_miner.sources.modules.utils import grid_data_stringify\n\n\n@register_control\nclass dangerous_paths(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"permissions\"\n        self.control_key = \"dangerous_paths\"\n\n        self.title = \"Attack paths choke points\"\n        self.description = \"List of the main paths to become a domain administrator\"\n        self.risk = \"This representation exposes the most common links to become domain administrator, which means the more likely to be used during an attack.\"\n        self.poa = \"Tackling the most common paths is a good approach to limit the risk of a compromission as it removes most of the paths to domain administrator.\"\n\n        self.objects_to_domain_admin = requests_results[\"objects_to_domain_admin\"]\n        self.objects_to_dcsync = requests_results[\"objects_to_dcsync\"]\n        self.da_to_da = requests_results[\"da_to_da\"]\n\n    def run(self):\n\n        def analyse_cache(cache):\n            if cache == None:\n                return []\n            dico_node_rel_node = {}\n            for path in cache:\n                for i in range(1, len(path.nodes) - 2):\n                    node_rel_node_instance = f\"{path.nodes[i].name} ⮕ {path.nodes[i].relation_type} ⮕ {path.nodes[i+1].name}\"\n                    if dico_node_rel_node.get(node_rel_node_instance):\n                        dico_node_rel_node[node_rel_node_instance] += 1\n                    else:\n                        dico_node_rel_node[node_rel_node_instance] = 1\n\n            return dict(\n                sorted(dico_node_rel_node.items(), key=lambda item: item[1])[::-1][:100]\n            )\n\n        dico_objects_to_da = analyse_cache(self.objects_to_domain_admin)\n        dico_dcsync_to_da = analyse_cache(self.objects_to_dcsync)\n        dico_da_to_da = analyse_cache(self.da_to_da)\n\n        if self.objects_to_dcsync != None:\n            len_dcsync = len(self.objects_to_dcsync)\n        else:\n            len_dcsync = 0\n\n        if self.da_to_da != None:\n            len_da_to_da = len(self.da_to_da)\n        else:\n            len_da_to_da = 0\n\n        # Remove 1 to exclude the false positive of container USERS containing DOMAIN ADMIN group\n        self.total_dangerous_paths = max(\n            len_dcsync + len(self.objects_to_domain_admin) + len_da_to_da - 1, 0\n        )\n\n        page = Page(\n            self.arguments.cache_prefix,\n            \"dangerous_paths_dcsync_to_da\",\n            \"DCSync privileges to DA privileges\",\n            self.get_dico_description(),\n        )\n        histo = Histogram()\n        histo.setData(dico_dcsync_to_da, len_dcsync)\n        page.addComponent(histo)\n        page.render()\n\n        page = Page(\n            self.arguments.cache_prefix,\n            \"dangerous_paths_objects_to_da\",\n            \"Objects to DA privileges\",\n            self.get_dico_description(),\n        )\n        histo = Histogram()\n        histo.setData(dico_objects_to_da, len(self.objects_to_domain_admin))\n        page.addComponent(histo)\n        page.render()\n\n        page = Page(\n            self.arguments.cache_prefix,\n            \"dangerous_paths_da_to_da\",\n            \"DA privileges to DA privileges\",\n            self.get_dico_description(),\n        )\n        histo = Histogram()\n        histo.setData(dico_da_to_da, len_da_to_da)\n        page.addComponent(histo)\n        page.render()\n\n        page = Page(\n            self.arguments.cache_prefix,\n            \"dangerous_paths\",\n            \"Attack paths choke points\",\n            self.get_dico_description(),\n        )\n        grid = Grid(\"dangerous paths\")\n\n        grid.addheader(\"Type of Graphs\")\n        dangerous_path_data = [\n            {\n                \"Type of Graphs\": grid_data_stringify(\n                    {\n                        \"value\": \"DCSync privileges to DA privileges\",\n                        \"link\": \"dangerous_paths_dcsync_to_da.html\",\n                        \"before_link\": '<i class=\"bi bi-arrow-repeat\"></i>',\n                    }\n                )\n            },\n            {\n                \"Type of Graphs\": grid_data_stringify(\n                    {\n                        \"value\": \"Objects to DA privileges\",\n                        \"link\": \"dangerous_paths_objects_to_da.html\",\n                        \"before_link\": '<i class=\"bi bi-chevron-double-up\"></i>',\n                    }\n                )\n            },\n            {\n                \"Type of Graphs\": grid_data_stringify(\n                    {\n                        \"value\": \"DA privileges to DA privileges\",\n                        \"link\": \"dangerous_paths_da_to_da.html\",\n                        \"before_link\": '<i class=\"bi bi-arrow-left-right\"></i>',\n                    }\n                )\n            },\n        ]\n\n        grid.setData(dangerous_path_data)\n        page.addComponent(grid)\n        page.render()\n\n        self.data = self.total_dangerous_paths\n        self.name_description = (\n            f\"More than {self.total_dangerous_paths} dangerous paths to DA\"\n        )\n\n    def get_rating(self) -> int:\n        return 1 if self.total_dangerous_paths > 0 else 5\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "ad_miner/sources/modules/histogram_class.py": {
        "imported_elements": [
          "Histogram"
        ],
        "code_map": {
          "Histogram": "class Histogram:\n    def __init__(\n        self, title=None, template=\"histogram\", icon=None, color=\"cardHeaderMazGrey\"\n    ):\n        self.template_base_path = HTML_DIRECTORY / \"components/histogram/\"\n        self.title = title\n        self.icon = icon\n        self.template = template\n        self.color = color\n        self.data1 = {}\n        self.data2 = \"\"\n        self.number_paths_main_nodes = 0\n\n    def setData(self, data1, data2):\n        self.data1 = data1\n        self.data2 = data2\n\n    def render(self, page_f):\n\n        # write header\n        with open(\n            self.template_base_path / (self.template + \"_header.html\"), \"r\"\n        ) as header_f:\n            html_header = header_f.read()\n            page_f.write(html_header)\n        \n        with open(\n            self.template_base_path / (self.template + \"_footer.html\"), \"r\", encoding='utf-8'\n        ) as footer_f:\n            content = footer_f.read() % (self.data1, self.data2)\n            page_f.write(content.encode('utf-8', errors='replace').decode('utf-8'))"
        }
      },
      "ad_miner/sources/modules/utils.py": {
        "imported_elements": [
          "grid_data_stringify"
        ],
        "code_map": {
          "grid_data_stringify": "def grid_data_stringify(raw_data: dict) -> str:\n    \"\"\"\n    Transform a dict to a string for the grid formating. This is a dumb fix for the sorting with hyperlink.\n    dict format :\n    {\n        \"link\",\n        \"value\",\n        \"before_link\"\n    }\n    \"\"\"\n    link = raw_data['link'].replace(sep, '_').replace('/', '_')\n    try:\n        return f\"{raw_data['before_link']} <a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\"\n    except KeyError:\n        return f\"<a class=\\\"grid-link\\\" href='{link}'>{raw_data['value']}&nbsp;<i class='bi bi-box-arrow-up-right' style='color: #0969da;'></i></a>\""
        }
      }
    },
    "requests_keys": [
      "da_to_da",
      "objects_to_domain_admin",
      "objects_to_dcsync"
    ]
  },
  {
    "title": "Users with cleartext passwords",
    "file_name": "users_pwd_cleartext.py",
    "control_category": "Passwords",
    "code": "from ad_miner.sources.modules.controls import Control\nfrom ad_miner.sources.modules.controls import register_control\nfrom ad_miner.sources.modules.page_class import Page\nfrom ad_miner.sources.modules.grid_class import Grid\n\nfrom ad_miner.sources.modules.common_analysis import containsDAs\n\nimport json\n\n\n@register_control\nclass users_pwd_cleartext(Control):\n    \"Legacy control\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        super().__init__(arguments, requests_results)\n\n        self.azure_or_onprem = \"on_premise\"\n        self.category = \"passwords\"\n\n        self.control_key = \"users_pwd_cleartext\"\n\n        self.title = \"Users with cleartext passwords\"\n        self.description = (\n            \"These users have their passwords stored somewhere in plaintext.\"\n        )\n        self.risk = \"This list should be strictly zero. Any attacker finding a password in cleartext would be able to use it instantly to enter in the AD. This represents a major security issue.\"\n        self.poa = \"Review this list and change password for all of these accounts. Make sure their new passwords are not stored in cleartext anymore.\"\n\n        self.users_pwd_cleartext = requests_results[\"nb_user_password_cleartext\"]\n\n    def run(self):\n        if self.users_pwd_cleartext is None:\n            return\n        page = Page(\n            self.arguments.cache_prefix,\n            \"users_pwd_cleartext\",\n            \"Number of users with password in cleartext\",\n            self.get_dico_description(),\n        )\n        grid = Grid(\"Users with password in cleartext\")\n        grid.setheaders([\"user\", \"password\", \"is Domain Admin\"])\n        grid.setData(json.dumps(self.users_pwd_cleartext))\n        page.addComponent(grid)\n        page.render()\n\n        self.data = len(self.users_pwd_cleartext) if self.users_pwd_cleartext else 0\n\n        self.name_description = f\"{self.data} users with clear text password\"\n\n    def get_rating(self) -> int:\n        return containsDAs(self.users_pwd_cleartext)\n",
    "dependencies": {
      "/Users/steverassinot/Repos/AD_Miner/ad_miner/sources/modules/controls/__init__.py": {
        "imported_elements": [
          "Control",
          "register_control"
        ],
        "code_map": {
          "register_control": "def register_control(cls):\n    \"Decorator to register every control that should be run by AD Miner\"\n    control_list.append(cls)\n    return cls",
          "Control": "class Control:\n    \"\"\"Every control should inheritate from this class.\n    It contains requests results and define essential structure.\"\"\"\n\n    def __init__(self, arguments, requests_results) -> None:\n        self.arguments = arguments\n        self.requests_results = requests_results\n        self.title = \"\"\n        self.description = \"\"\n        self.interpretation = \"\"\n        self.risk = \"\"\n        self.poa = \"\"\n\n    def run(self):\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a run() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_rating(self) -> int:\n        error_message = \"Your control \" + str(self)\n        error_message += \" should have a get_rating() function defined.\"\n        raise NotImplementedError(error_message)\n\n    def get_dico_description(self) -> dict:\n        self.dico_description: dict[str, str] = {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"interpretation\": self.interpretation,\n            \"risk\": self.risk,\n            \"poa\": self.poa,\n        }\n        return self.dico_description"
        }
      },
      "ad_miner/sources/modules/page_class.py": {
        "imported_elements": [
          "Page"
        ],
        "code_map": {
          "Page": "class Page:\n    def __init__(\n        self,\n        render_prefix,\n        name,\n        title,\n        dico_description,\n        template_file=\"base\",\n        include_js=[],\n    ):\n        self.render_prefix = render_prefix\n        self.name = name + \".html\"\n        self.template = template_file\n        self.title = title\n        self.include_js = include_js\n        self.dico_description = dico_description\n\n        self.components = []\n\n    def addComponent(self, component):\n        self.components.append(component)\n\n    # TODO remove magic string foldername\n    def render(self):\n\n        # shutil.copyfile(self.template + \"_header\", \"./render/\" +  os.path.basename(self.template + ))\n\n        with open(\n            \"./render_%s/html/%s\" % (self.render_prefix, self.name.replace(sep, \"_\")),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as page_f:\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_header.html\"),\n                \"r\",\n                encoding=\"utf-8\",\n            ) as header_f:\n                page_f.write(\n                    header_f.read()\n                    % (\n                        self.title,\n                        self.dico_description[\"description\"],\n                        self.dico_description[\"risk\"],\n                        self.dico_description[\"poa\"],\n                    )\n                )\n\n            for component in self.components:\n                component.render(page_f)\n\n            for jsFile in self.include_js:\n                # open jsFile and write content to page_f in a <script> block\n                with open(JS_DIRECTORY / (jsFile + \".js\"), \"r\") as js_f:\n                    page_f.write(\"<script>%s</script>\" % js_f.read())\n\n            with open(\n                TEMPLATES_DIRECTORY / (self.template + \"_footer.html\"), \"r\"\n            ) as footer_f:\n                page_f.write(footer_f.read())"
        }
      },
      "ad_miner/sources/modules/grid_class.py": {
        "imported_elements": [
          "Grid"
        ],
        "code_map": {
          "Grid": "class Grid:\n    def __init__(self, title, template=\"grid\", classes=\"thead-light\"):\n        self.template_base_path = HTML_DIRECTORY / \"components/grid/\"\n        self.title = title\n        self.template = template\n        self.headers = []\n        self.data = \"\"\n        self.class_css = classes\n\n    def addheader(self, header):\n        self.headers.append(header)\n\n    def setheaders(self, header):\n        self.headers = header\n\n    def getHeaders(self):\n        return self.headers\n\n    def setData(self, data):\n        self.data = data\n\n    def render(self, page_f):\n        with open(self.template_base_path / (self.template + \"_template.html\"), \"r\") as grid_template:\n            # Grid data that will be inserted in the template\n            textToInsert = \"var columnDefs = [\"\n            for header in self.headers:\n                textToInsert += \"\"\"{\n                    field:\\\"%s\\\",\n                    cellRenderer: function(params) {\n                        if (typeof params.data[params.column.colId] === 'object') {\n                            if (params.data[params.column.colId].value == \\\"0\\\") {\n                                return params.data[params.column.colId].value;\n                            }\n                            if (params.data[params.column.colId].link == 'FALSE_LINK') {\n                                params.data[params.column.colId] = '<p>' + params.data[params.column.colId].value + '</p>';\n                                return params.data[params.column.colId];\n                            }\n                            if (params.data[params.column.colId].link != null) {\n                                if (params.data[params.column.colId].before_link != null) {\n                                    var prepend = params.data[params.column.colId].before_link;\n                                }\n                                else {\n                                    var prepend = \"\";\n                                }\n                                params.data[params.column.colId] = prepend + '<a onMouseOver=\"this.style.color=#99c3ff\" onMouseOut=\"this.style.color=#000\" href=\"' + params.data[params.column.colId].link + '\">'+ params.data[params.column.colId].value + '</a>';\n                                return params.data[params.column.colId];\n                            }\n                            return params.data[params.column.colId];\n                        }\n                        else {\n                            return params.value;\n                        }\n                    },\n                },\"\"\" % (\n                    header\n                )\n\n            textToInsert = textToInsert + \"];\\nvar rowData=%s;\\n\" % (self.data)\n\n            template_contents = grid_template.read()\n\n            new_contents = template_contents.replace(\"// DATA PLACEHOLDER\", textToInsert)\n\n            page_f.write(new_contents)"
        }
      },
      "ad_miner/sources/modules/common_analysis.py": {
        "imported_elements": [
          "containsDAs"
        ],
        "code_map": {
          "containsDAs": "def containsDAs(req, criticity=1):\n    if req is None:\n        return -1\n\n    for object in req:\n        if object.get(\"is_Domain_Admin\"):\n            if object[\"is_Domain_Admin\"] == True:\n                return criticity\n        # if object.get(\"is_da\"):\n        #     if object[\"is_da\"] == True:\n        #         return criticity\n\n    if len(req) > 0:\n        return criticity + 1\n\n    return 5"
        }
      }
    },
    "requests_keys": [
      "nb_user_password_cleartext"
    ]
  }
]